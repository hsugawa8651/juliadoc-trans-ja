<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.6.0_10_r10436" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>!!!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093933Z" creationid="hsugawa8651" creationdate="20181112T111813Z">
        <seg>!!! note</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032237Z" creationid="hsugawa8651" creationdate="20181114T032237Z">
        <seg>!&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!&lt;x1/&gt; indicates that it will mutate or destroy the
value of one or more of its arguments (compare, for example, &lt;x2/&gt;`sort`&lt;x3/&gt; and &lt;x4/&gt;`sort!`&lt;x5/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154213Z" creationid="hsugawa8651" creationdate="20181109T154213Z">
        <seg>&lt;x1/&gt;は、それが突然変異または破壊されることを示しています。 一つ以上の引数の値(例えば、&lt;x2/&gt;`sort'&lt;x3/&gt;、&lt;x4/&gt;`sort!"&lt;x5/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!x&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132152Z" creationid="hsugawa8651" creationdate="20181113T132152Z">
        <seg>!x&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""

hello"""</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020854Z" creationid="hsugawa8651" creationdate="20181116T020854Z">
        <seg>"""

hello"""</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""
    *(x, y, z...)

Multiplication operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020106Z" creationid="hsugawa8651" creationdate="20181116T020106Z">
        <seg>"""
    *(x, y, z...)

Multiplication operator.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""
...

...
"""
f(x, y) = ...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020045Z" creationid="hsugawa8651" creationdate="20181116T020045Z">
        <seg>"""
...

...
"""
f(x, y) = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""
Some nice documentation here.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020027Z" creationid="hsugawa8651" creationdate="20181116T020027Z">
        <seg>"""
Some nice documentation here.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""
function *(x, y, z...)
    &lt;x1/&gt; ... [implementation sold separately] ...
end

"""
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020110Z" creationid="hsugawa8651" creationdate="20181116T020110Z">
        <seg>"""
function *(x, y, z...)
    &lt;x1/&gt; ... [implementation sold separately] ...
end

"""
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""
hello"""</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020850Z" creationid="hsugawa8651" creationdate="20181116T020850Z">
        <seg>"""
hello"""</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""...

..."""
f(x, y) = ...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020053Z" creationid="hsugawa8651" creationdate="20181116T020053Z">
        <seg>"""...

..."""
f(x, y) = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"""hello"""</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020845Z" creationid="hsugawa8651" creationdate="20181116T020845Z">
        <seg>"""hello"""</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>""&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063211Z" creationid="hsugawa8651" creationdate="20181114T063211Z">
        <seg>""&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"$NBSP$char$NBSP" : "$char"
end


function table_entries(completions, unicode_dict)
    entries = [[
        "Code point(s)", "Character(s)",
        "Tab completion sequence(s)", "Unicode name(s)"
    ]]
    for (chars, inputs) in sort!(collect(completions), by = first)
        code_points, unicode_names, characters = String[], String[], String[]
        for char in chars
            push!(code_points, "U+$(uppercase(string(UInt32(char), base = 16, pad = 5)))")
            push!(unicode_names, get(unicode_dict, UInt32(char), "(No Unicode name)"))
            push!(characters, isempty(characters) ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022230Z" creationid="hsugawa8651" creationdate="20181116T022230Z">
        <seg>"$NBSP$char$NBSP" : "$char"
end


function table_entries(completions, unicode_dict)
    entries = [[
        "Code point(s)", "Character(s)",
        "Tab completion sequence(s)", "Unicode name(s)"
    ]]
    for (chars, inputs) in sort!(collect(completions), by = first)
        code_points, unicode_names, characters = String[], String[], String[]
        for char in chars
            push!(code_points, "U+$(uppercase(string(UInt32(char), base = 16, pad = 5)))")
            push!(unicode_names, get(unicode_dict, UInt32(char), "(No Unicode name)"))
            push!(characters, isempty(characters) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160149Z" creationid="hsugawa8651" creationdate="20181109T160147Z">
        <seg>1", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"..."
f(x) = x

"..."
function f(x)
    x
end

"..."
f(x)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020159Z" creationid="hsugawa8651" creationdate="20181116T020159Z">
        <seg>"..."
f(x) = x

"..."
function f(x)
    x
end

"..."
f(x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"..."
function f end

"..."
f</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020156Z" creationid="hsugawa8651" creationdate="20181116T020156Z">
        <seg>"..."
function f end

"..."
f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Is-Bits"   :: A &lt;x1/&gt;primitive type&lt;x2/&gt;, or a &lt;x3/&gt;struct&lt;x4/&gt; type where all fields are other &lt;x5/&gt;isbits&lt;x6/&gt; types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150729Z" creationid="hsugawa8651" creationdate="20181117T150729Z">
        <seg>「ビット」::&lt;x1/&gt;プリミティブ型&lt;x2/&gt;、または&lt;x3/&gt;構造体&lt;x4/&gt;型であり、すべてのフィールドはその他の&lt;x5/&gt;イスビトス&lt;x6/&gt;タイプである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Leaf Type" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150619Z" creationid="hsugawa8651" creationdate="20181117T150619Z">
        <seg>「リーフタイプ」::タイプタグを含む関連データのグループは、Julia GCによって管理され、オブジェクト識別によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Leaf Type" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no &lt;x1/&gt;TypeVars&lt;x2/&gt; are allowed) in order for the instance to be constructed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134329Z" creationid="hsugawa8651" creationdate="20181117T134329Z">
        <seg>「リーフタイプ」::タイプタグを含む関連データのグループは、ジュリアGCによって管理され、オブジェクト識別子によって定義されます。リーフタイプのタイプパラメータは、インスタンスが構築されるには完全に定義(&lt;x1/&gt;TypeVars&lt;x2/&gt;は許可されません)されている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Primitive Type" :: A type with no fields, but a size.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150703Z" creationid="hsugawa8651" creationdate="20181117T150703Z">
        <seg>「プリミティブ型」::フィールドがなくても、サイズがあるタイプです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Singleton" :: a Leaf Type or Struct with no fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150740Z" creationid="hsugawa8651" creationdate="20181117T150740Z">
        <seg>"Singleton"::a Leaf Type or Struct with no fields.(Singleton::a Leaf TypeまたはStruct with no fields.)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Struct" :: A type with all fields defined to be constant.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150713Z" creationid="hsugawa8651" creationdate="20181117T150713Z">
        <seg>"Struct"::A type with all fieldsが定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Super Type" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150637Z" creationid="hsugawa8651" creationdate="20181117T150637Z">
        <seg>「スーパータイプ」:インスタンス化できないスーパータイプ(リーフタイプではない)ですが、タイプのグループを記述するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Tuple" :: an immutable data-structure similar to an anonymous struct type, or a constant array.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150800Z" creationid="hsugawa8651" creationdate="20181117T150800Z">
        <seg>「タプル」:匿名構造型と似た不変のデータ構造、あるいは定数配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Tuple" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134345Z" creationid="hsugawa8651" creationdate="20181117T134345Z">
        <seg>「タプル」:匿名構造体タイプと同様の不変データ構造、あるいは定数配列です。配列または構造体のいずれかとして表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Type Parameter" :: A specialization of a type (typically used for dispatch or storage optimization).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150647Z" creationid="hsugawa8651" creationdate="20181117T150647Z">
        <seg>「Type Parameter」:タイプの特殊化(通常はディスパッチまたはストレージの最適化に使用されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"TypeVar" :: The &lt;x1/&gt;T&lt;x2/&gt; in the type parameter declaration is referred to as a TypeVar (short for type variable).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150650Z" creationid="hsugawa8651" creationdate="20181117T150650Z">
        <seg>「TypeVar」:&lt;x1/&gt;T&lt;x2/&gt;型パラメータ宣言の&lt;x1/&gt;は、TypeVar(型変数の短縮形)と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"less than" : "not less than")
less than

julia&gt; x = 1; y = 0;

julia&gt; println(x &lt; y ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230126Z" creationid="hsugawa8651" creationdate="20181109T230126Z">
        <seg>"less than" : "not less than")
less than

julia&gt; x = 1; y = 0;

julia&gt; println(x &lt; y ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"less than" : "not less than")
not less than</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230129Z" creationid="hsugawa8651" creationdate="20181109T230129Z">
        <seg>"less than" : "not less than")
not less than</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"x is greater than y" : "x is equal to y")
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230146Z" creationid="hsugawa8651" creationdate="20181109T230146Z">
        <seg>"x is greater than y" : "x is equal to y")
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"x is less than y"    :
                            x &gt; y ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230144Z" creationid="hsugawa8651" creationdate="20181109T230144Z">
        <seg>"x is less than y"    :
                            x &gt; y ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ cat -n Tmp/test/runtests.jl
 1	using Tmp
 2	Tmp.greet()</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022539Z" creationid="hsugawa8651" creationdate="20181116T022539Z">
        <seg>$ cat -n Tmp/test/runtests.jl
 1	using Tmp
 2	Tmp.greet()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ echo 'println("Greetings!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224456Z" creationid="hsugawa8651" creationdate="20181109T224456Z">
        <seg>$ echo 'println("Greetings!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' &gt; script.jl
$ julia script.jl foo bar
script.jl
foo
bar</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224352Z" creationid="hsugawa8651" creationdate="20181109T224352Z">
        <seg>$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' &gt; script.jl
$ julia script.jl foo bar
script.jl
foo
bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ julia  -e 'using Pkg;Pkg.activate("Tmp");Pkg.test()'
Updating registry at `&lt;x1/&gt;/.julia/registries/General`
Updating git-repo `https://github.com/JuliaRegistries/General.git`
Resolving package versions...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022542Z" creationid="hsugawa8651" creationdate="20181116T022542Z">
        <seg>$ julia  -e 'using Pkg;Pkg.activate("Tmp");Pkg.test()'
Updating registry at `&lt;x1/&gt;/.julia/registries/General`
Updating git-repo `https://github.com/JuliaRegistries/General.git`
Resolving package versions...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ julia --color=yes -O -- foo.jl arg1 arg2..</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224359Z" creationid="hsugawa8651" creationdate="20181109T224359Z">
        <seg>$ julia --color=yes -O -- foo.jl arg1 arg2..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar

foo
bar</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224343Z" creationid="hsugawa8651" creationdate="20181109T224343Z">
        <seg>$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar

foo
bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ julia -e 'using Pkg;Pkg.generate("Tmp")'
Generating project Tmp:
  Tmp/Project.toml
  Tmp/src/Tmp.jl
$ ls -R Tmp
Tmp:
Project.toml  src

Tmp/src:
Tmp.jl
$ cat -n Tmp/src/Tmp.jl
   1	module Tmp
   2
   3	greet() = print("Hello World!")
   4
   5	end &lt;x1/&gt; module</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022534Z" creationid="hsugawa8651" creationdate="20181116T022534Z">
        <seg>$ julia -e 'using Pkg;Pkg.generate("Tmp")'
Generating project Tmp:
  Tmp/Project.toml
  Tmp/src/Tmp.jl
$ ls -R Tmp
Tmp:
Project.toml  src

Tmp/src:
Tmp.jl
$ cat -n Tmp/src/Tmp.jl
   1	module Tmp
   2
   3	greet() = print("Hello World!")
   4
   5	end &lt;x1/&gt; module</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ julia script.jl arg1 arg2...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224325Z" creationid="hsugawa8651" creationdate="20181109T224325Z">
        <seg>$ julia script.jl arg1 arg2...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ mkdir Tmp/test</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022537Z" creationid="hsugawa8651" creationdate="20181116T022537Z">
        <seg>$ mkdir Tmp/test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032304Z" creationid="hsugawa8651" creationdate="20181114T032304Z">
        <seg>$&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$&lt;x1/&gt;s:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015209Z" creationid="hsugawa8651" creationdate="20181116T015209Z">
        <seg>$&lt;x1/&gt;s:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$JULIA_BINDIR/$DATAROOTDIR/julia/base</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054804Z" creationid="hsugawa8651" creationdate="20181116T054804Z">
        <seg>$JULIA_BINDIR/$DATAROOTDIR/julia/base</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl
$JULIA_BINDIR/../etc/julia/startup.jl</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054817Z" creationid="hsugawa8651" creationdate="20181116T054817Z">
        <seg>$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl
$JULIA_BINDIR/../etc/julia/startup.jl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$JULIA_BINDIR/julia
$JULIA_BINDIR/julia-debug</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054746Z" creationid="hsugawa8651" creationdate="20181116T054746Z">
        <seg>$JULIA_BINDIR/julia
$JULIA_BINDIR/julia-debug</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032308Z" creationid="hsugawa8651" creationdate="20181114T032308Z">
        <seg>%&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032324Z" creationid="hsugawa8651" creationdate="20181114T032324Z">
        <seg>&amp;&amp;&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;&lt;x1/&gt; followed by &lt;x2/&gt;\|\|&lt;x3/&gt; followed by &lt;x4/&gt;?&lt;x5/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030904Z" creationid="hsugawa8651" creationdate="20181114T030904Z">
        <seg>&amp;&amp;&lt;x1/&gt; followed by &lt;x2/&gt;\|\|&lt;x3/&gt; followed by &lt;x4/&gt;?&lt;x5/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032315Z" creationid="hsugawa8651" creationdate="20181114T032315Z">
        <seg>&amp;&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>''&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063508Z" creationid="hsugawa8651" creationdate="20181114T063508Z">
        <seg>''&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063017Z" creationid="hsugawa8651" creationdate="20181114T063017Z">
        <seg>'&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("function", "library")&lt;x1/&gt; where &lt;x2/&gt;function&lt;x3/&gt; is the C-exported function name.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161428Z" creationid="hsugawa8651" creationdate="20181114T161428Z">
        <seg>(「関数」、「ライブラリ」)&lt;x1/&gt;&lt;x2/&gt;&lt;x2/&gt;関数&lt;x3/&gt;は、Cエクスポートされた関数名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("function", "library")&lt;x1/&gt; where &lt;x2/&gt;function&lt;x3/&gt; is the C-exported function name. &lt;x4/&gt;library&lt;x5/&gt; refers
to the shared library name: shared libraries available in the (platform-specific) load path will
be resolved by name, and if necessary a direct path may be specified.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133743Z" creationid="hsugawa8651" creationdate="20181117T133743Z">
        <seg>(「関数」、「ライブラリ」)&lt;x1/&gt;&lt;x2/&gt;関数&lt;x3/&gt;は、Cエクスポートされた関数名です。&lt;x4/&gt;ライブラリ&lt;x5/&gt;は 共有ライブラリの名前:(プラットフォーム固有の)ロードパスで使用可能な共有ライブラリ 名前で解決する必要があり、必要に応じて直接パスを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032338Z" creationid="hsugawa8651" creationdate="20181114T032338Z">
        <seg>()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(...)&lt;x1/&gt; or &lt;x2/&gt;tuple(...)&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150743Z" creationid="hsugawa8651" creationdate="20181117T150743Z">
        <seg>(...)&lt;x1/&gt; or &lt;x2/&gt;tuple(...)&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(1, 2, 3)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150754Z" creationid="hsugawa8651" creationdate="20181117T150754Z">
        <seg>(1, 2, 3)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;x1/&gt;none&lt;x2/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112324Z" creationid="hsugawa8651" creationdate="20181112T112324Z">
        <seg>(&lt;x1/&gt;none&lt;x2/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;x1/&gt;undefined&lt;x2/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112222Z" creationid="hsugawa8651" creationdate="20181112T112222Z">
        <seg>(&lt;x1/&gt;undefined&lt;x2/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id extending-in-place-broadcast)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131444Z" creationid="hsugawa8651" creationdate="20181113T131444Z">
        <seg>(@id extending-in-place-broadcast)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id lib-arrays)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020215Z" creationid="hsugawa8651" creationdate="20181116T020215Z">
        <seg>(@id lib-arrays)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id lib-collections-iteration)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032020Z" creationid="hsugawa8651" creationdate="20181114T032020Z">
        <seg>(@id lib-collections-iteration)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id lib-constants)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043136Z" creationid="hsugawa8651" creationdate="20181112T043136Z">
        <seg>(@id lib-constants)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id lib-numbers)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044706Z" creationid="hsugawa8651" creationdate="20181112T044706Z">
        <seg>(@id lib-numbers)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id lib-strings)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150336Z" creationid="hsugawa8651" creationdate="20181117T150336Z">
        <seg>(@id lib-strings)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-anonymous-functions)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025951Z" creationid="hsugawa8651" creationdate="20181110T025951Z">
        <seg>(@id man-anonymous-functions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-array-indexing)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155105Z" creationid="hsugawa8651" creationdate="20181109T155105Z">
        <seg>(@id man-array-indexing)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-bits-types)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150804Z" creationid="hsugawa8651" creationdate="20181117T150804Z">
        <seg>(@id man-bits-types)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-byte-array-literals)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021041Z" creationid="hsugawa8651" creationdate="20181116T021041Z">
        <seg>(@id man-byte-array-literals)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-characters)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020513Z" creationid="hsugawa8651" creationdate="20181116T020513Z">
        <seg>(@id man-characters)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-concatenation)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020740Z" creationid="hsugawa8651" creationdate="20181116T020740Z">
        <seg>(@id man-concatenation)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-conditional-evaluation)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225826Z" creationid="hsugawa8651" creationdate="20181109T225826Z">
        <seg>(@id man-conditional-evaluation)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-dot-operators)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132431Z" creationid="hsugawa8651" creationdate="20181113T132431Z">
        <seg>(@id man-dot-operators)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-interface-array)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113200Z" creationid="hsugawa8651" creationdate="20181112T113200Z">
        <seg>(@id man-interface-array)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-loops)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230921Z" creationid="hsugawa8651" creationdate="20181109T230921Z">
        <seg>(@id man-loops)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-macros)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015249Z" creationid="hsugawa8651" creationdate="20181116T015249Z">
        <seg>(@id man-macros)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-method-design-ambiguities)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054400Z" creationid="hsugawa8651" creationdate="20181116T054400Z">
        <seg>(@id man-method-design-ambiguities)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-multi-dim-arrays)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064312Z" creationid="hsugawa8651" creationdate="20181114T064312Z">
        <seg>(@id man-multi-dim-arrays)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-raw-string-literals)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021121Z" creationid="hsugawa8651" creationdate="20181116T021121Z">
        <seg>(@id man-raw-string-literals)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-supported-index-types)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134939Z" creationid="hsugawa8651" creationdate="20181117T134939Z">
        <seg>(@id man-supported-index-types)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id man-version-number-literals)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021105Z" creationid="hsugawa8651" creationdate="20181116T021105Z">
        <seg>(@id man-version-number-literals)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id math-ops)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043422Z" creationid="hsugawa8651" creationdate="20181112T043422Z">
        <seg>(@id math-ops)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@id string-interpolation)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020800Z" creationid="hsugawa8651" creationdate="20181116T020800Z">
        <seg>(@id string-interpolation)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref &lt;:)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063600Z" creationid="hsugawa8651" creationdate="20181114T063600Z">
        <seg>(@ref &lt;:)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref ===)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063626Z" creationid="hsugawa8651" creationdate="20181114T063626Z">
        <seg>(@ref ===)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref &gt;:) (reverse of subtype operator)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063616Z" creationid="hsugawa8651" creationdate="20181114T063604Z">
        <seg>(@ref&gt;:)(サブタイプ演算子の逆)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref Base.EnvDict)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041814Z" creationid="hsugawa8651" creationdate="20181112T041814Z">
        <seg>(@ref Base.EnvDict)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref Base.ImmutableDict)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041818Z" creationid="hsugawa8651" creationdate="20181112T041818Z">
        <seg>(@ref Base.ImmutableDict)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref Base.getproperty)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025921Z" creationid="hsugawa8651" creationdate="20181110T025921Z">
        <seg>(@ref Base.getproperty)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref man-array-indexing)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022353Z" creationid="hsugawa8651" creationdate="20181113T022353Z">
        <seg>(@ref man-array-indexing)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref man-conditional-evaluation): &lt;x1/&gt;if&lt;x2/&gt;-&lt;x3/&gt;elseif&lt;x4/&gt;-&lt;x5/&gt;else&lt;x6/&gt; and &lt;x7/&gt;?:&lt;x8/&gt; (ternary operator).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225720Z" creationid="hsugawa8651" creationdate="20181109T225720Z">
        <seg>(@ref man条件付き評価):&lt;x1/&gt;-&lt;x2/&gt;-&lt;x3/&gt;else&lt;x4/&gt;-&lt;x5/&gt;else&lt;x6/&gt;および&lt;x7/&gt;?:&lt;x8/&gt;(三元演算子):&lt;x8/&gt;&lt;x8/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref man-dot-operators) such as &lt;x1/&gt;.+&lt;x2/&gt; and &lt;x3/&gt;.*&lt;x4/&gt; are equivalent
to &lt;x5/&gt;broadcast&lt;x6/&gt; calls (except that they fuse, as described below).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161313Z" creationid="hsugawa8651" creationdate="20181114T161313Z">
        <seg>(@ref man dot演算子)例えば&lt;x1/&gt;.+&lt;x2/&gt;&lt;x3/&gt;.*&lt;x4/&gt;は等価です。 &lt;x5/&gt;ブロードキャスト&lt;x6/&gt;コール(以下に説明するように融合することを除く)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@ref man-dot-operators) such as &lt;x1/&gt;.+&lt;x2/&gt; and &lt;x3/&gt;.*&lt;x4/&gt; are equivalent
to &lt;x5/&gt;broadcast&lt;x6/&gt; calls (except that they fuse, as described below). There is also a
&lt;x7/&gt;`broadcast!`&lt;x8/&gt; function to specify an explicit destination (which can also
be accessed in a fusing fashion by &lt;x9/&gt;.=&lt;x10/&gt; assignment). In fact, &lt;x11/&gt;f.(args...)&lt;x12/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135235Z" creationid="hsugawa8651" creationdate="20181117T135235Z">
        <seg>(@ref man dot演算子)例えば&lt;x1/&gt;.+&lt;x2/&gt;&lt;x3/&gt;.*&lt;x4/&gt;は等価です。 &lt;x5/&gt;ブロードキャスト&lt;x6/&gt;コール(以下に説明するように、これらのコールが融合されることを除く)に対しては、次のように設定されます。 &lt;x7/&gt;'ブロードキャスト!&lt;x8/&gt;関数は明示的な宛先を指定することができます(これは &lt;x9/&gt;.=&lt;x10/&gt;の割り当て方法でアクセスします。実際&lt;x11/&gt;f.(args.)&lt;x12/&gt;&lt;x12/&gt;&lt;x12/&gt;&lt;x12/&gt;&lt;x12/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Again, one should
&lt;x7/&gt;import Base.display&lt;x8/&gt; to add new methods to &lt;x9/&gt;display&lt;x10/&gt;.) The return values of these functions are
up to the implementation (since in some cases it may be useful to return a display "handle" of
some type).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043334Z" creationid="hsugawa8651" creationdate="20181112T043334Z">
        <seg>(再度 &lt;x7/&gt;import Base.display&lt;x8/&gt;to add new methods to&lt;x9/&gt;display&lt;x10/&gt;.これらの関数の戻り値は、次のようになります。 実装まで(ある場合には、「handle」の「handle」を返すことが役に立つことがあるので、それを実行することができます。 あるタイプ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(By convention, we tend to space operators more tightly if they get applied before other nearby
operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132219Z" creationid="hsugawa8651" creationdate="20181113T132219Z">
        <seg>(慣習的には、他の近傍に適用されると、オペレータの間隔が狭くなる傾向があります。 演算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For comparison
operations like &lt;x5/&gt;&lt;&lt;x6/&gt;, &lt;x7/&gt;only&lt;x8/&gt; the elementwise &lt;x9/&gt;.&lt;&lt;x10/&gt; version is applicable to arrays.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160021Z" creationid="hsugawa8651" creationdate="20181109T160021Z">
        <seg>(比較のために &lt;x5/&gt;&lt;x6/&gt;のような操作、&lt;x7/&gt;&lt;x6/&gt;&lt;x8/&gt;&lt;x10/&gt;&lt;x8/&gt;&lt;x10/&gt;は、配列に適用されます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Given &lt;x8/&gt;r::Iterators.Reverse{T}&lt;x9/&gt;, the underling iterator of type &lt;x10/&gt;T&lt;x11/&gt; is &lt;x12/&gt;r.itr&lt;x13/&gt;.)
In our &lt;x14/&gt;Squares&lt;x15/&gt; example, we would implement &lt;x16/&gt;Iterators.Reverse{Squares}&lt;x17/&gt; methods:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112931Z" creationid="hsugawa8651" creationdate="20181112T112931Z">
        <seg>(&lt;x8/&gt;r::Iterator.Reverse{T}&lt;x9/&gt;,the undering iterator of type&lt;x10/&gt;T&lt;x11/&gt;)は、&lt;x12/&gt;r.itr&lt;x13/&gt;である。 &lt;x14/&gt;Squares&lt;x15/&gt;の例では、&lt;x16/&gt;イテレータを実装します。逆{Squares}&lt;x17/&gt;メソッド:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the
wrapper was calling a Fortran function instead, the corresponding function input
signature should instead be &lt;x9/&gt;(Ref{Csize_t},)&lt;x10/&gt;, since Fortran variables are
passed by pointers.) Furthermore, &lt;x11/&gt;n&lt;x12/&gt; can be any type that is convertible to a
&lt;x13/&gt;Csize_t&lt;x14/&gt; integer; the &lt;x15/&gt;`ccall`&lt;x16/&gt; implicitly calls &lt;x17/&gt;`Base.cconvert(Csize_t,
n)`&lt;x18/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152055Z" creationid="hsugawa8651" creationdate="20181117T152055Z">
        <seg>( ラッパーは、代わりにFortran関数を呼び出し、対応する関数入力を呼び出しました。 Fortranの変数は次のようなものであるため、署名は&lt;x9/&gt;(Ref{Csize_t},)&lt;x10/&gt;でなければなりません。 ポインタによって渡される)。また、&lt;x11/&gt;n&lt;x12/&gt;は、変換可能な任意のタイプであることができます。 &lt;x13/&gt;Csize_t&lt;x14/&gt;integer;&lt;x15/&gt;`ccall`&lt;x16/&gt;は暗黙的に&lt;x17/&gt;`Base.チコンベルト(Csize_t n)`&lt;x18/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Julia values &lt;x13/&gt;v&lt;x14/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152549Z" creationid="hsugawa8651" creationdate="20181117T152549Z">
        <seg>(Julia values &lt;x13/&gt;v&lt;x14/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Non-library function calls in both C and Julia can
be inlined and thus may have even less overhead than calls to shared library functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160555Z" creationid="hsugawa8651" creationdate="20181109T160555Z">
        <seg>(CとJuliaの両方での非ライブラリ関数呼び出しは 共有ライブラリ関数への呼び出しよりも、インライン化されているため、オーバーヘッドが少なくて済みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;x1/&gt;Clang package&lt;x2/&gt; can be used to auto-generate
Julia code from a C header file.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150555Z" creationid="hsugawa8651" creationdate="20181117T150555Z">
        <seg>(&lt;x1/&gt;Clangパッケージ&lt;x2/&gt;は自動生成のために使用できます。 Cヘッダー・ファイルからのJuliaコード。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The above expression uses several features that have yet to be introduced, including &lt;x5/&gt;&lt;x6/&gt;&lt;x7/&gt;(@ref man-loops),
&lt;x8/&gt;&lt;x9/&gt;&lt;x10/&gt;(@ref man-strings), and &lt;x11/&gt;Interpolation&lt;x12/&gt;, but should be easy enough to understand for users
with some existing programming experience.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225610Z" creationid="hsugawa8651" creationdate="20181109T225610Z">
        <seg>(上記の式では、&lt;x5/&gt;&lt;x6/&gt;&lt;x7/&gt;(@ref man loops)など、まだ導入されていないいくつかの機能を使用しています。 &lt;x8/&gt;&lt;x9/&gt;&lt;x10/&gt;(@ref manストリング)、&lt;x11/&gt;補間&lt;x12/&gt;は、ユーザが理解するのに十分な大きさである必要があります。 既存のプログラミング経験があります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(generic function with 1 method)

julia&gt; change_array!(x)
5

julia&gt; x
3-element Array{Int64,1}:
 5
 2
 3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025053Z" creationid="hsugawa8651" creationdate="20181110T025053Z">
        <seg>(generic function with 1 method)

julia&gt; change_array!(x)
5

julia&gt; x
3-element Array{Int64,1}:
 5
 2
 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(generic function with 1 method)

julia&gt; change_value!(x)
17

julia&gt; x &lt;x1/&gt; x is unchanged!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025006Z" creationid="hsugawa8651" creationdate="20181110T025006Z">
        <seg>(generic function with 1 method)

julia&gt; change_value!(x)
17

julia&gt; x &lt;x1/&gt; x is unchanged!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(if &lt;x1/&gt;IndexCartesian&lt;x2/&gt;, where &lt;x3/&gt;N = ndims(A)&lt;x4/&gt;) N-dimensional scalar indexing</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094445Z" creationid="hsugawa8651" creationdate="20181118T094445Z">
        <seg>(もし&lt;x1/&gt;IndexCartesian&lt;x2/&gt;である場合&lt;x3/&gt;N = ndims(A)&lt;x4/&gt;)N-次元スカラーインデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(y, x) : (x, y)

julia&gt; range((min, max)) = max - min

julia&gt; range(minmax(10, 2))
8</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030043Z" creationid="hsugawa8651" creationdate="20181110T030043Z">
        <seg>(y, x) : (x, y)

julia&gt; range((min, max)) = max - min

julia&gt; range(minmax(10, 2))
8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* / % &amp; \ ÷&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030836Z" creationid="hsugawa8651" creationdate="20181114T030836Z">
        <seg>* / % &amp; \ ÷&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032336Z" creationid="hsugawa8651" creationdate="20181114T032336Z">
        <seg>*&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+ - \| ⊻&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030842Z" creationid="hsugawa8651" creationdate="20181114T030842Z">
        <seg>+ - \| ⊻&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+ x&lt;x4/&gt; or &lt;x5/&gt;1 .+ x&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132647Z" creationid="hsugawa8651" creationdate="20181113T132647Z">
        <seg>+ x&lt;x4/&gt; or &lt;x5/&gt;1 .+ x&lt;x6/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+(a, b) = +(promote(a, b)...)
&lt;x4/&gt; Once the elements have the same type, they can be added.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054210Z" creationid="hsugawa8651" creationdate="20181116T054210Z">
        <seg>+(a, b) = +(promote(a, b)...)
&lt;x4/&gt; Once the elements have the same type, they can be added.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+(a::Float64, b::Float64) = Core.add(a, b)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054218Z" creationid="hsugawa8651" creationdate="20181116T054218Z">
        <seg>+(a::Float64, b::Float64) = Core.add(a, b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+(a::Matrix, b::Matrix) = map(+, a, b)
&lt;x2/&gt; Then dispatch handles each element and selects the appropriate
&lt;x3/&gt; common element type for the computation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054205Z" creationid="hsugawa8651" creationdate="20181116T054205Z">
        <seg>+(a::Matrix, b::Matrix) = map(+, a, b)
&lt;x2/&gt; Then dispatch handles each element and selects the appropriate
&lt;x3/&gt; common element type for the computation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+1 : 0)
       end
mycompare (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022650Z" creationid="hsugawa8651" creationdate="20181116T022650Z">
        <seg>+1 : 0)
       end
mycompare (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132406Z" creationid="hsugawa8651" creationdate="20181113T132406Z">
        <seg>+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+x&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131941Z" creationid="hsugawa8651" creationdate="20181113T131941Z">
        <seg>+x&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>,&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063157Z" creationid="hsugawa8651" creationdate="20181114T063157Z">
        <seg>,&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-(A::AbstractArray{T}, b::Date) where {T&lt;:Date}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054448Z" creationid="hsugawa8651" creationdate="20181116T054448Z">
        <seg>-(A::AbstractArray{T}, b::Date) where {T&lt;:Date}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-(A::MyArrayType{T}, b::T) where {T}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054450Z" creationid="hsugawa8651" creationdate="20181116T054450Z">
        <seg>-(A::MyArrayType{T}, b::T) where {T}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--banner={yes\|no\|auto}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031804Z" creationid="hsugawa8651" creationdate="20181114T031804Z">
        <seg>--banner={yes\|no\|auto}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--check-bounds={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031833Z" creationid="hsugawa8651" creationdate="20181114T031833Z">
        <seg>--check-bounds={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--code-coverage&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031909Z" creationid="hsugawa8651" creationdate="20181114T031909Z">
        <seg>--code-coverage&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--code-coverage={none\|user\|all}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031849Z" creationid="hsugawa8651" creationdate="20181114T031849Z">
        <seg>--code-coverage={none\|user\|all}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--color={yes\|no\|auto}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031808Z" creationid="hsugawa8651" creationdate="20181114T031808Z">
        <seg>--color={yes\|no\|auto}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--compiled-modules={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031709Z" creationid="hsugawa8651" creationdate="20181114T031709Z">
        <seg>--compiled-modules={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--depwarn={yes\|no\|error}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031816Z" creationid="hsugawa8651" creationdate="20181114T031816Z">
        <seg>--depwarn={yes\|no\|error}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--handle-signals={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031655Z" creationid="hsugawa8651" creationdate="20181114T031655Z">
        <seg>--handle-signals={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--history-file={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031812Z" creationid="hsugawa8651" creationdate="20181114T031812Z">
        <seg>--history-file={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--inline={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031830Z" creationid="hsugawa8651" creationdate="20181114T031830Z">
        <seg>--inline={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--machine-file &lt;x1/&gt;&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031749Z" creationid="hsugawa8651" creationdate="20181114T031749Z">
        <seg>--machine-file &lt;x1/&gt;&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--project[={&lt;x1/&gt;\|@.}]&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031505Z" creationid="hsugawa8651" creationdate="20181114T031505Z">
        <seg>--project[={&lt;x1/&gt;\|@.}]&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--startup-file={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031700Z" creationid="hsugawa8651" creationdate="20181114T031700Z">
        <seg>--startup-file={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--sysimage-native-code={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031705Z" creationid="hsugawa8651" creationdate="20181114T031705Z">
        <seg>--sysimage-native-code={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--track-allocation&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031912Z" creationid="hsugawa8651" creationdate="20181114T031912Z">
        <seg>--track-allocation&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--track-allocation={none\|user\|all}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031905Z" creationid="hsugawa8651" creationdate="20181114T031905Z">
        <seg>--track-allocation={none\|user\|all}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--warn-overwrite={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031819Z" creationid="hsugawa8651" creationdate="20181114T031819Z">
        <seg>--warn-overwrite={yes\|no}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-1 : ((a &gt; b) ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022645Z" creationid="hsugawa8651" creationdate="20181116T022645Z">
        <seg>-1 : ((a &gt; b) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-2^127</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110210Z" creationid="hsugawa8651" creationdate="20181112T110210Z">
        <seg>-2^127</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-2^15</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110132Z" creationid="hsugawa8651" creationdate="20181112T110132Z">
        <seg>-2^15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-2^31</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110150Z" creationid="hsugawa8651" creationdate="20181112T110150Z">
        <seg>-2^31</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-2^63</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110200Z" creationid="hsugawa8651" creationdate="20181112T110200Z">
        <seg>-2^63</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-2^7</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110121Z" creationid="hsugawa8651" creationdate="20181112T110121Z">
        <seg>-2^7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-C&lt;x1/&gt;, &lt;x2/&gt;--cpu-target &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031822Z" creationid="hsugawa8651" creationdate="20181114T031822Z">
        <seg>-C&lt;x1/&gt;, &lt;x2/&gt;--cpu-target &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-E&lt;x1/&gt;, &lt;x2/&gt;--print &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031738Z" creationid="hsugawa8651" creationdate="20181114T031738Z">
        <seg>-E&lt;x1/&gt;, &lt;x2/&gt;--print &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-H&lt;x1/&gt;, &lt;x2/&gt;--home &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031548Z" creationid="hsugawa8651" creationdate="20181114T031548Z">
        <seg>-H&lt;x1/&gt;, &lt;x2/&gt;--home &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Inf16&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110818Z" creationid="hsugawa8651" creationdate="20181112T110818Z">
        <seg>-Inf16&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Inf32&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110819Z" creationid="hsugawa8651" creationdate="20181112T110819Z">
        <seg>-Inf32&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Inf&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110820Z" creationid="hsugawa8651" creationdate="20181112T110820Z">
        <seg>-Inf&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Inf&lt;x1/&gt; is equal to itself and less then everything else except &lt;x2/&gt;NaN&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030505Z" creationid="hsugawa8651" creationdate="20181114T030505Z">
        <seg>-Inf&lt;x1/&gt;はそれ自身と等しく、&lt;x2/&gt;NaN&lt;x3/&gt;以外のすべてのものはそれより小さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-J&lt;x1/&gt;, &lt;x2/&gt;--sysimage &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031542Z" creationid="hsugawa8651" creationdate="20181114T031542Z">
        <seg>-J&lt;x1/&gt;, &lt;x2/&gt;--sysimage &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-L&lt;x1/&gt;, &lt;x2/&gt;--load &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031733Z" creationid="hsugawa8651" creationdate="20181114T031733Z">
        <seg>-L&lt;x1/&gt;, &lt;x2/&gt;--load &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-O&lt;x1/&gt;, &lt;x2/&gt;--optimize={0,1,2,3}&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031825Z" creationid="hsugawa8651" creationdate="20181114T031825Z">
        <seg>-O&lt;x1/&gt;, &lt;x2/&gt;--optimize={0,1,2,3}&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-e&lt;x1/&gt;, &lt;x2/&gt;--eval &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031712Z" creationid="hsugawa8651" creationdate="20181114T031712Z">
        <seg>-e&lt;x1/&gt;, &lt;x2/&gt;--eval &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-g&lt;x1/&gt;, &lt;x2/&gt;-g &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031827Z" creationid="hsugawa8651" creationdate="20181114T031827Z">
        <seg>-g&lt;x1/&gt;, &lt;x2/&gt;-g &lt;x3/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-h&lt;x1/&gt;, &lt;x2/&gt;--help&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031510Z" creationid="hsugawa8651" creationdate="20181114T031510Z">
        <seg>-h&lt;x1/&gt;, &lt;x2/&gt;--help&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-i&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031753Z" creationid="hsugawa8651" creationdate="20181114T031753Z">
        <seg>-i&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-p&lt;x1/&gt;, &lt;x2/&gt;--procs {N\|auto&lt;x3/&gt;}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031745Z" creationid="hsugawa8651" creationdate="20181114T031745Z">
        <seg>-p&lt;x1/&gt;, &lt;x2/&gt;--procs {N\|auto&lt;x3/&gt;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-q&lt;x1/&gt;, &lt;x2/&gt;--quiet&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031758Z" creationid="hsugawa8651" creationdate="20181114T031758Z">
        <seg>-q&lt;x1/&gt;, &lt;x2/&gt;--quiet&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-v&lt;x1/&gt;, &lt;x2/&gt;--version&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224601Z" creationid="hsugawa8651" creationdate="20181109T224549Z">
        <seg>-v&lt;x1/&gt;, &lt;x2/&gt;--version&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-x&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131953Z" creationid="hsugawa8651" creationdate="20181113T131953Z">
        <seg>-x&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224510Z" creationid="hsugawa8651" creationdate="20181109T224510Z">
        <seg>...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063526Z" creationid="hsugawa8651" creationdate="20181114T063526Z">
        <seg>...&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...&lt;x1/&gt; (e.g. a vararg)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151603Z" creationid="hsugawa8651" creationdate="20181117T151603Z">
        <seg>...&lt;x1/&gt; (e.g. a vararg)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063530Z" creationid="hsugawa8651" creationdate="20181114T063530Z">
        <seg>.&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.&lt;x1/&gt; followed by &lt;x2/&gt;::&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030812Z" creationid="hsugawa8651" creationdate="20181114T030812Z">
        <seg>&lt;x1/&gt;に続いて&lt;x2/&gt;::&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/etc/julia/startup.jl</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054824Z" creationid="hsugawa8651" creationdate="20181116T054824Z">
        <seg>/etc/julia/startup.jl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110126Z" creationid="hsugawa8651" creationdate="20181112T110126Z">
        <seg>0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0xxxxxxx&lt;x1/&gt;;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020645Z" creationid="hsugawa8651" creationdate="20181116T020645Z">
        <seg>0xxxxxxx&lt;x1/&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 == 1.0 ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015426Z" creationid="hsugawa8651" creationdate="20181116T015426Z">
        <seg>1 == 1.0 ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1-dimensional &lt;x2/&gt;`Array`&lt;x3/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043131Z" creationid="hsugawa8651" creationdate="20181112T043131Z">
        <seg>1-dimensional &lt;x2/&gt;`Array`&lt;x3/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1-dimensional &lt;x2/&gt;`BitArray`&lt;x3/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043133Z" creationid="hsugawa8651" creationdate="20181112T043133Z">
        <seg>1-dimensional &lt;x2/&gt;`BitArray`&lt;x3/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.0

julia&gt; 0.5
0.5

julia&gt; .5
0.5

julia&gt; -1.23
-1.23

julia&gt; 1e10
1.0e10

julia&gt; 2.5e-4
0.00025</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110544Z" creationid="hsugawa8651" creationdate="20181112T110544Z">
        <seg>1.0

julia&gt; 0.5
0.5

julia&gt; .5
0.5

julia&gt; -1.23
-1.23

julia&gt; 1e10
1.0e10

julia&gt; 2.5e-4
0.00025</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025013Z" creationid="hsugawa8651" creationdate="20181110T025013Z">
        <seg>10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10-element Array{Base.StackTraces.StackFrame,1}:
 error at error.jl:33 [inlined]
 child() at REPL[1]:1
 parent() at REPL[2]:1
 grandparent() at REPL[3]:3
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020423Z" creationid="hsugawa8651" creationdate="20181116T020423Z">
        <seg>10-element Array{Base.StackTraces.StackFrame,1}:
 error at error.jl:33 [inlined]
 child() at REPL[1]:1
 parent() at REPL[2]:1
 grandparent() at REPL[3]:3
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10xxxxxx&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020630Z" creationid="hsugawa8651" creationdate="20181116T020630Z">
        <seg>10xxxxxx&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10xxxxxx&lt;x1/&gt;;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020628Z" creationid="hsugawa8651" creationdate="20181116T020628Z">
        <seg>10xxxxxx&lt;x1/&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>110xxxxx&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020626Z" creationid="hsugawa8651" creationdate="20181116T020626Z">
        <seg>110xxxxx&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1110xxxx&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020629Z" creationid="hsugawa8651" creationdate="20181116T020629Z">
        <seg>1110xxxx&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11110xxx&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020632Z" creationid="hsugawa8651" creationdate="20181116T020632Z">
        <seg>11110xxx&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>128</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110209Z" creationid="hsugawa8651" creationdate="20181112T110209Z">
        <seg>128</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>16</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110131Z" creationid="hsugawa8651" creationdate="20181112T110131Z">
        <seg>16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1:5   &lt;x1/&gt; not strided (there is no storage associated with this array.)
Vector(1:5)  &lt;x2/&gt; is strided with strides (1,)
A = [1 5; 2 6; 3 7; 4 8]  &lt;x3/&gt; is strided with strides (1,4)
V = view(A, 1:2, :)   &lt;x4/&gt; is strided with strides (1,4)
V = view(A, 1:2:3, 1:2)   &lt;x5/&gt; is strided with strides (2,4)
V = view(A, [1,2,4], :)   &lt;x6/&gt; is not strided, as the spacing between rows is not fixed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094616Z" creationid="hsugawa8651" creationdate="20181118T094616Z">
        <seg>1:5   &lt;x1/&gt; not strided (there is no storage associated with this array.)
Vector(1:5)  &lt;x2/&gt; is strided with strides (1,)
A = [1 5; 2 6; 3 7; 4 8]  &lt;x3/&gt; is strided with strides (1,4)
V = view(A, 1:2, :)   &lt;x4/&gt; is strided with strides (1,4)
V = view(A, 1:2:3, 1:2)   &lt;x5/&gt; is strided with strides (2,4)
V = view(A, [1,2,4], :)   &lt;x6/&gt; is not strided, as the spacing between rows is not fixed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2*x : x, (opr1, opr2))
           retexpr = Expr(:call, op, opr1f, opr2f)
           return retexpr
       end
make_expr2 (generic function with 1 method)

julia&gt; make_expr2(:+, 1, 2)
:(2 + 4)

julia&gt; ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))
:(2 + 5 * 8)

julia&gt; eval(ex)
42</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015247Z" creationid="hsugawa8651" creationdate="20181116T015247Z">
        <seg>2*x : x, (opr1, opr2))
           retexpr = Expr(:call, op, opr1f, opr2f)
           return retexpr
       end
make_expr2 (generic function with 1 method)

julia&gt; make_expr2(:+, 1, 2)
:(2 + 4)

julia&gt; ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))
:(2 + 5 * 8)

julia&gt; eval(ex)
42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2A^2 + sin(A)&lt;x16/&gt;, using the &lt;x17/&gt;&lt;x18/&gt;&lt;x19/&gt;(@ref @&lt;x20/&gt;dot&lt;x21/&gt;) macro) for
an array &lt;x22/&gt;A&lt;x23/&gt;, it performs a &lt;x24/&gt;single&lt;x25/&gt; loop over &lt;x26/&gt;A&lt;x27/&gt;, computing &lt;x28/&gt;2a^2 + sin(a)&lt;x29/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132558Z" creationid="hsugawa8651" creationdate="20181113T132553Z">
        <seg>2a^2+sin(A)&lt;x16/&gt;&lt;x19/&gt;&lt;x19/&gt;(@ref@&lt;x20/&gt;dot&lt;X21/&gt;)マクロを使用して array&lt;x22/&gt;A&lt;x23/&gt;&lt;x26/&gt;A&lt;x27/&gt;で&lt;x24/&gt;ループを実行し、&lt;x28/&gt;2A^2+sin(a)&lt;x29/&gt;を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^127 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110211Z" creationid="hsugawa8651" creationdate="20181112T110211Z">
        <seg>2^127 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^128 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110216Z" creationid="hsugawa8651" creationdate="20181112T110216Z">
        <seg>2^128 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^15 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110133Z" creationid="hsugawa8651" creationdate="20181112T110133Z">
        <seg>2^15 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^16 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110139Z" creationid="hsugawa8651" creationdate="20181112T110139Z">
        <seg>2^16 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^31 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110151Z" creationid="hsugawa8651" creationdate="20181112T110151Z">
        <seg>2^31 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^32 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110155Z" creationid="hsugawa8651" creationdate="20181112T110155Z">
        <seg>2^32 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^63 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110201Z" creationid="hsugawa8651" creationdate="20181112T110201Z">
        <seg>2^63 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^64 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110205Z" creationid="hsugawa8651" creationdate="20181112T110205Z">
        <seg>2^64 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^7 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110122Z" creationid="hsugawa8651" creationdate="20181112T110122Z">
        <seg>2^7 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2^8 - 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110127Z" creationid="hsugawa8651" creationdate="20181112T110127Z">
        <seg>2^8 - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3-argument conditional operator (used like: &lt;x1/&gt;conditional ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063206Z" creationid="hsugawa8651" creationdate="20181114T063206Z">
        <seg>3引数条件付き演算子(&lt;x1/&gt;条件付きのように使用されますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>32</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110149Z" creationid="hsugawa8651" creationdate="20181112T110149Z">
        <seg>32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110158Z" creationid="hsugawa8651" creationdate="20181112T110158Z">
        <seg>64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110043Z" creationid="hsugawa8651" creationdate="20181112T110043Z">
        <seg>8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150421Z" creationid="hsugawa8651" creationdate="20181117T150421Z">
        <seg>:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:
Nomenclature: while the term "constructor" generally refers to the entire function which constructs
objects of a type, it is common to abuse terminology slightly and refer to specific constructor
methods as "constructors".</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155659Z" creationid="hsugawa8651" creationdate="20181117T155659Z">
        <seg>: 命名法:「コンストラクタ」という用語は、一般的には、次のような機能を構成する関数全体を指します。 タイプのオブジェクトで、用語をわずかに乱用し、特定のコンストラクタを参照することが一般的です。 「コンストラクタ」としてのメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:
The unary operators &lt;x1/&gt;+&lt;x2/&gt; and &lt;x3/&gt;-&lt;x4/&gt; require explicit parentheses around their argument to disambiguate them from the operator &lt;x5/&gt;++&lt;x6/&gt;, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030927Z" creationid="hsugawa8651" creationdate="20181114T030915Z">
        <seg>: 単項演算子&lt;x1/&gt;+&lt;x2/&gt;と&lt;x3/&gt;は、演算子&lt;x5/&gt;++&lt;x6/&gt;などからそれらを区別するために、引数の周りに明示的な括弧を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>: &lt;x1/&gt;iid&lt;x2/&gt;, independently and identically distributed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064449Z" creationid="hsugawa8651" creationdate="20181114T064449Z">
        <seg>&lt;x1/&gt;iid&lt;x2/&gt;、独立して、同一に分布している。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:( )&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063553Z" creationid="hsugawa8651" creationdate="20181114T063553Z">
        <seg>:( )&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:( println("Hello, world!") )</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015259Z" creationid="hsugawa8651" creationdate="20181116T015259Z">
        <seg>:( println("Hello, world!") )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>::&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063547Z" creationid="hsugawa8651" creationdate="20181114T063547Z">
        <seg>::&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063544Z" creationid="hsugawa8651" creationdate="20181114T063544Z">
        <seg>:&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:a : (@static Sys.isapple() ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225018Z" creationid="hsugawa8651" creationdate="20181109T225018Z">
        <seg>:a : (@static Sys.isapple() ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:a&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063556Z" creationid="hsugawa8651" creationdate="20181114T063556Z">
        <seg>:a&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:b : :c)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225020Z" creationid="hsugawa8651" creationdate="20181109T225020Z">
        <seg>:b : :c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>;&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063149Z" creationid="hsugawa8651" creationdate="20181114T063149Z">
        <seg>;&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;:&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063559Z" creationid="hsugawa8651" creationdate="20181114T063559Z">
        <seg>&lt;:&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;\|&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030856Z" creationid="hsugawa8651" creationdate="20181114T030856Z">
        <seg>&lt;\|&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c21&gt;&lt;s22&gt;user&lt;/s22&gt;&lt;/c21&gt; defaults to current user,
&lt;c23&gt;&lt;s24&gt;port&lt;/s24&gt;&lt;/c23&gt; to the standard ssh port.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085227Z" creationid="hsugawa8651" creationdate="20181118T084952Z">
        <seg>デフォルトでは、&lt;c21&gt;&lt;s22&gt;user&lt;/s22&gt;&lt;/c21&gt; は現在のユーザー、 &lt;c23&gt;&lt;s24&gt;port&lt;/s24&gt;&lt;/c23&gt; は標準のsshポートになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c25&gt;&lt;s26&gt;count&lt;/s26&gt;&lt;/c25&gt; is the number of workers to spawn
on the node, and defaults to 1.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085203Z" creationid="hsugawa8651" creationdate="20181118T085004Z">
        <seg>&lt;c25&gt;&lt;s26&gt;count&lt;/s26&gt;&lt;/c25&gt; はノードで作成されるワーカーの数で、デフォルトは1です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;&lt;s5&gt;-p&lt;/s5&gt; &lt;s6&gt;n&lt;/s6&gt;&lt;/c4&gt; will launch an additional &lt;c7&gt;&lt;s8&gt;n&lt;/s8&gt;&lt;/c7&gt; worker
processes, while &lt;c9&gt;&lt;s10&gt;--machinefile&lt;/s10&gt; &lt;s11&gt;file&lt;/s11&gt;&lt;/c9&gt; will launch a worker for each line in
file &lt;c12&gt;&lt;s13&gt;file&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084910Z" creationid="hsugawa8651" creationdate="20181118T084910Z">
        <seg>-p n でn個のワーカーを追加で起動することができ、 --machinefile file では file ファイルの各行ごとにワーカーが起動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c6&gt;&lt;s7&gt;ARGS&lt;/s7&gt;&lt;/c6&gt; is also set when script code
is given using the &lt;c8&gt;&lt;s9&gt;-e&lt;/s9&gt;&lt;/c8&gt; option on the command line (see the &lt;c10&gt;&lt;s11&gt;julia&lt;/s11&gt;&lt;/c10&gt;
help output below).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084517Z" creationid="hsugawa8651" creationdate="20181118T084517Z">
        <seg>コマンドラインで -e オプションが設定された際にも ARGS は設定されます（下の julia ヘルプ出力を参照してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;&lt;/s0&gt;$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083821Z" creationid="hsugawa8651" creationdate="20181118T083821Z">
        <seg>&lt;s0&gt;&lt;/s0&gt;$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.&lt;s0&gt;&lt;/s0&gt;$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;&lt;/s0&gt;&lt;s1&gt;$&lt;/s1&gt; &lt;s2&gt;julia&lt;/s2&gt; &lt;s3&gt;script&lt;/s3&gt;&lt;s4&gt;.&lt;/s4&gt;&lt;s5&gt;jl&lt;/s5&gt; &lt;s6&gt;arg1&lt;/s6&gt; &lt;s7&gt;arg2&lt;/s7&gt;&lt;s8&gt;...&lt;/s8&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084039Z" creationid="hsugawa8651" creationdate="20181118T084039Z">
        <seg>&lt;s0&gt;&lt;/s0&gt;&lt;s1&gt;$&lt;/s1&gt; &lt;s2&gt;julia&lt;/s2&gt; &lt;s3&gt;script&lt;/s3&gt;&lt;s4&gt;.&lt;/s4&gt;&lt;s5&gt;jl&lt;/s5&gt; &lt;s6&gt;arg1&lt;/s6&gt; &lt;s7&gt;arg2&lt;/s7&gt;&lt;s8&gt;...&lt;/s8&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;&lt;/s0&gt;julia [switches] -- [programfile] [args...]
 -v, --version             Display version information
 -h, --help                Print this message

 -J, --sysimage &lt;file&gt;     Start up with the given system image file
 --precompiled={yes|no}    Use precompiled code from system image if available
 -H, --home &lt;dir&gt;          Set location of `julia` executable
 --startup-file={yes|no}   Load ~/.juliarc.jl
 -f, --no-startup          Don't load ~/.juliarc (deprecated, use --startup-file=no)
 -F                        Load ~/.juliarc (deprecated, use --startup-file=yes)
 --handle-signals={yes|no} Enable or disable Julia's default signal handlers

 -e, --eval &lt;expr&gt;         Evaluate &lt;expr&gt;
 -E, --print &lt;expr&gt;        Evaluate and show &lt;expr&gt;
 -P, --post-boot &lt;expr&gt;    Evaluate &lt;expr&gt;, but don't disable interactive mode (deprecated, use -i -e instead)
 -L, --load &lt;file&gt;         Load &lt;file&gt; immediately on all processors

 -p, --procs {N|auto}      Integer value N launches N additional local worker processes
                           "auto" launches as many workers as the number of local cores
 --machinefile &lt;file&gt;      Run processes on hosts listed in &lt;file&gt;

 -i                        Interactive mode; REPL runs and isinteractive() is true
 -q, --quiet               Quiet startup (no banner)
 --color={yes|no}          Enable or disable color text
 --history-file={yes|no}   Load or save history
 --no-history-file         Don't load history file (deprecated, use --history-file=no)

 --compile={yes|no|all}    Enable or disable compiler, or request exhaustive compilation
 -C, --cpu-target &lt;target&gt; Limit usage of cpu features up to &lt;target&gt;
 -O, --optimize            Run time-intensive code optimizations
 --inline={yes|no}         Control whether inlining is permitted (overrides functions declared as @inline)
 --check-bounds={yes|no}   Emit bounds checks always or never (ignoring declarations)
 --math-mode={ieee,fast}   Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)

 --depwarn={yes|no|error}  Enable or disable syntax and method deprecation warnings ("error" turns warnings into errors)

 --output-o name           Generate an object file (including system image data)
 --output-ji name          Generate a system image data file (.ji)
 --output-bc name          Generate LLVM bitcode (.bc)

 --output-incremental=no   Generate an incremental output file (rather than complete)

 --code-coverage={none|user|all}, --code-coverage
                           Count executions of source lines (omitting setting is equivalent to "user")
 --track-allocation={none|user|all}, --track-allocation
                           Count bytes allocated by each source line</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085527Z" creationid="hsugawa8651" creationdate="20181118T085527Z">
        <seg>&lt;s0&gt;&lt;/s0&gt;julia [switches] -- [programfile] [args...]
 -v, --version             Display version information
 -h, --help                Print this message

 -J, --sysimage &lt;file&gt;     Start up with the given system image file
 --precompiled={yes|no}    Use precompiled code from system image if available
 -H, --home &lt;dir&gt;          Set location of `julia` executable
 --startup-file={yes|no}   Load ~/.juliarc.jl
 -f, --no-startup          Don't load ~/.juliarc (deprecated, use --startup-file=no)
 -F                        Load ~/.juliarc (deprecated, use --startup-file=yes)
 --handle-signals={yes|no} Enable or disable Julia's default signal handlers

 -e, --eval &lt;expr&gt;         Evaluate &lt;expr&gt;
 -E, --print &lt;expr&gt;        Evaluate and show &lt;expr&gt;
 -P, --post-boot &lt;expr&gt;    Evaluate &lt;expr&gt;, but don't disable interactive mode (deprecated, use -i -e instead)
 -L, --load &lt;file&gt;         Load &lt;file&gt; immediately on all processors

 -p, --procs {N|auto}      Integer value N launches N additional local worker processes
                           "auto" launches as many workers as the number of local cores
 --machinefile &lt;file&gt;      Run processes on hosts listed in &lt;file&gt;

 -i                        Interactive mode; REPL runs and isinteractive() is true
 -q, --quiet               Quiet startup (no banner)
 --color={yes|no}          Enable or disable color text
 --history-file={yes|no}   Load or save history
 --no-history-file         Don't load history file (deprecated, use --history-file=no)

 --compile={yes|no|all}    Enable or disable compiler, or request exhaustive compilation
 -C, --cpu-target &lt;target&gt; Limit usage of cpu features up to &lt;target&gt;
 -O, --optimize            Run time-intensive code optimizations
 --inline={yes|no}         Control whether inlining is permitted (overrides functions declared as @inline)
 --check-bounds={yes|no}   Emit bounds checks always or never (ignoring declarations)
 --math-mode={ieee,fast}   Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)

 --depwarn={yes|no|error}  Enable or disable syntax and method deprecation warnings ("error" turns warnings into errors)

 --output-o name           Generate an object file (including system image data)
 --output-ji name          Generate a system image data file (.ji)
 --output-bc name          Generate LLVM bitcode (.bc)

 --output-incremental=no   Generate an incremental output file (rather than complete)

 --code-coverage={none|user|all}, --code-coverage
                           Count executions of source lines (omitting setting is equivalent to "user")
 --track-allocation={none|user|all}, --track-allocation
                           Count bytes allocated by each source line</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; 32-bit or 64-bit system:
julia&gt; typeof(3000000000)
Int64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225311Z" creationid="hsugawa8651" creationdate="20181109T225311Z">
        <seg>&lt;x1/&gt; 32-bit or 64-bit system:
julia&gt; typeof(3000000000)
Int64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; Int
Int32
julia&gt; UInt
UInt32

&lt;x2/&gt; 64-bit system:
julia&gt; Int
Int64
julia&gt; UInt
UInt64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110343Z" creationid="hsugawa8651" creationdate="20181112T110343Z">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; Int
Int32
julia&gt; UInt
UInt32

&lt;x2/&gt; 64-bit system:
julia&gt; Int
Int64
julia&gt; UInt
UInt64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; Sys.WORD_SIZE
32

&lt;x2/&gt; 64-bit system:
julia&gt; Sys.WORD_SIZE
64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110333Z" creationid="hsugawa8651" creationdate="20181112T110333Z">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; Sys.WORD_SIZE
32

&lt;x2/&gt; 64-bit system:
julia&gt; Sys.WORD_SIZE
64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; UInt
UInt32

&lt;x2/&gt; 64-bit system:
julia&gt; UInt
UInt64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022040Z" creationid="hsugawa8651" creationdate="20181116T022040Z">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; UInt
UInt32

&lt;x2/&gt; 64-bit system:
julia&gt; UInt
UInt64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; typeof(1)
Int32

&lt;x2/&gt; 64-bit system:
julia&gt; typeof(1)
Int64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225233Z" creationid="hsugawa8651" creationdate="20181109T225233Z">
        <seg>&lt;x1/&gt; 32-bit system:
julia&gt; typeof(1)
Int32

&lt;x2/&gt; 64-bit system:
julia&gt; typeof(1)
Int64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; 32-bit system:
primitive type Ptr{T} 32 end

&lt;x2/&gt; 64-bit system:
primitive type Ptr{T} 64 end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022002Z" creationid="hsugawa8651" creationdate="20181116T022002Z">
        <seg>&lt;x1/&gt; 32-bit system:
primitive type Ptr{T} 32 end

&lt;x2/&gt; 64-bit system:
primitive type Ptr{T} 64 end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; Examples
```jldoctest
julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
"""</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020023Z" creationid="hsugawa8651" creationdate="20181116T020023Z">
        <seg>&lt;x1/&gt; Examples
```jldoctest
julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
"""</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; The corresponding C signature is
&lt;x2/&gt;     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), &lt;x3/&gt; name of C function and library
        Cvoid,                             &lt;x4/&gt; output type
        (Ref{gsl_permutation},),          &lt;x5/&gt; tuple of input types
        p                                 &lt;x6/&gt; name of Julia variable to pass in
    )
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152059Z" creationid="hsugawa8651" creationdate="20181117T152059Z">
        <seg>&lt;x1/&gt; The corresponding C signature is
&lt;x2/&gt;     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), &lt;x3/&gt; name of C function and library
        Cvoid,                             &lt;x4/&gt; output type
        (Ref{gsl_permutation},),          &lt;x5/&gt; tuple of input types
        p                                 &lt;x6/&gt; name of Julia variable to pass in
    )
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt; The corresponding C signature is
&lt;x2/&gt;    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
&lt;x3/&gt;                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax &lt; nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), &lt;x4/&gt; name of C function and library
        Cint,                               &lt;x5/&gt; output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),&lt;x6/&gt; tuple of input types
        nmin, nmax, x, result_array         &lt;x7/&gt; names of Julia variables to pass in
    )
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152147Z" creationid="hsugawa8651" creationdate="20181117T152147Z">
        <seg>&lt;x1/&gt; The corresponding C signature is
&lt;x2/&gt;    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
&lt;x3/&gt;                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax &lt; nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), &lt;x4/&gt; name of C function and library
        Cint,                               &lt;x5/&gt; output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),&lt;x6/&gt; tuple of input types
        nmin, nmax, x, result_array         &lt;x7/&gt; names of Julia variables to pass in
    )
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;!/bin/bash
&lt;x2/&gt;=
exec julia --color=yes --startup-file=no -e 'include(popfirst!(ARGS))' \
    "${BASH_SOURCE[0]}" "$@"
=&lt;x3/&gt;

@show ARGS  &lt;x4/&gt; put any Julia code here</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024929Z" creationid="hsugawa8651" creationdate="20181110T024929Z">
        <seg>&lt;x1/&gt;!/bin/bash
&lt;x2/&gt;=
exec julia --color=yes --startup-file=no -e 'include(popfirst!(ARGS))' \
    "${BASH_SOURCE[0]}" "$@"
=&lt;x3/&gt;

@show ARGS  &lt;x4/&gt; put any Julia code here</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032247Z" creationid="hsugawa8651" creationdate="20181114T032247Z">
        <seg>&lt;x1/&gt;&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;=&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032251Z" creationid="hsugawa8651" creationdate="20181114T032251Z">
        <seg>&lt;x1/&gt;=&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;IndexLinear()&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022821Z" creationid="hsugawa8651" creationdate="20181113T022821Z">
        <seg>&lt;x1/&gt;IndexLinear()&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;Recursive data structures&lt;x2/&gt;,
especially those that may be self-referential, often cannot be constructed cleanly without first
being created in an incomplete state and then altered programmatically to be made whole, as a
separate step from object creation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155652Z" creationid="hsugawa8651" creationdate="20181117T155652Z">
        <seg>&lt;x1/&gt;再帰データ構造体&lt;x2/&gt; 特に、自己参照することができるものは、しばしば、最初には、きれいに構築することはできない は不完全な状態で作成され、次にプログラムによって変更されて全体として作成されます。 オブジェクト作成とは別のステップです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;`CartesianIndex` and arrays of `CartesianIndex` are not compatible with the&lt;x2/&gt;&lt;x3/&gt;`end` keyword to represent the last index of a dimension.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155752Z" creationid="hsugawa8651" creationdate="20181109T155752Z">
        <seg>&lt;x1/&gt;`CartesianIndex'と「CartesianIndex」の配列は、次元の最後のインデックスを表すために、&lt;x2/&gt;&lt;x3/&gt;'end"キーワードと互換性がない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;`CartesianIndex` and arrays of `CartesianIndex` are not compatible with the&lt;x2/&gt;&lt;x3/&gt;`end` keyword to represent the last index of a dimension. Do not use `end`&lt;x4/&gt;&lt;x5/&gt;in indexing expressions that may contain either `CartesianIndex` or arrays thereof.&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135101Z" creationid="hsugawa8651" creationdate="20181117T135101Z">
        <seg>&lt;x1/&gt;`CartesianIndex'と「CartesianIndex」の配列は、次元の最後のインデックスを表すために&lt;x2/&gt;&lt;x/&gt;&lt;x/&gt;&lt;x3/&gt;'end"キーワードとは互換性がありません。"end"&lt;x4/&gt;&lt;x5/&gt;は、「CartesianIndex」またはその配列のいずれかを含むことができるインデックス表現では使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;`Task`&lt;x2/&gt;s
are not so standard: they provide non-local control flow, making it possible to switch between
temporarily-suspended computations.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225746Z" creationid="hsugawa8651" creationdate="20181109T225746Z">
        <seg>&lt;x1/&gt;`タスク`&lt;x2/&gt;s はあまり標準的ではないため、ローカルではない制御フローを提供することができます。 一時的に中断された計算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;```c&lt;x2/&gt;&lt;x3/&gt;int main(int argc, char **argv);&lt;x4/&gt;&lt;x5/&gt;```&lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;&lt;x9/&gt;can be called via the following Julia code:&lt;x10/&gt;&lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;```julia&lt;x14/&gt;&lt;x15/&gt;argv = [ "a.out", "arg1", "arg2" ]&lt;x16/&gt;&lt;x17/&gt;ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)&lt;x18/&gt;&lt;x19/&gt;```&lt;x20/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151041Z" creationid="hsugawa8651" creationdate="20181117T151041Z">
        <seg>&lt;x1/&gt;`"c&lt;x2/&gt;&lt;x3/&gt;int主(int argc,char**argv);&lt;x4/&gt;&lt;x5/&gt;`"&lt;x6/&gt;&lt;x8/&gt;&lt;x9/&gt;&lt;x10/&gt;&lt;x11/&gt;&lt;x13/&gt;`"julia&lt;x14/&gt;&lt;x15/&gt;&lt;x20/&gt;""julia&lt;x14/&gt;&lt;x15/&gt;&lt;x20/&gt;&lt;x17/&gt;&lt;x15/&gt;&lt;x17/&gt;"x18/&gt;&lt;x19/&gt;&lt;x19/&gt;"&lt;x18/&gt;&lt;x19/&gt;&lt;x20/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;```jldoctest&lt;x2/&gt;&lt;x3/&gt;julia&gt; x = 0x01; typeof(x)&lt;x4/&gt;&lt;x5/&gt;UInt8&lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;&lt;x9/&gt;julia&gt; x *= 2 &lt;x10/&gt; Same as x = x * 2&lt;x11/&gt;&lt;x12/&gt;2&lt;x13/&gt;&lt;x14/&gt;&lt;x15/&gt;&lt;x16/&gt;julia&gt; typeof(x)&lt;x17/&gt;&lt;x18/&gt;Int64&lt;x19/&gt;&lt;x20/&gt;```&lt;x21/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132427Z" creationid="hsugawa8651" creationdate="20181113T132427Z">
        <seg>&lt;x1/&gt;```jldoctest&lt;x2/&gt;&lt;x3/&gt;julia&gt; x = 0x01; typeof(x)&lt;x4/&gt;&lt;x5/&gt;UInt8&lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;&lt;x9/&gt;julia&gt; x *= 2 &lt;x10/&gt; Same as x = x * 2&lt;x11/&gt;&lt;x12/&gt;2&lt;x13/&gt;&lt;x14/&gt;&lt;x15/&gt;&lt;x16/&gt;julia&gt; typeof(x)&lt;x17/&gt;&lt;x18/&gt;Int64&lt;x19/&gt;&lt;x20/&gt;```&lt;x21/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;include &lt;immintrin.h&gt;

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151318Z" creationid="hsugawa8651" creationdate="20181117T151318Z">
        <seg>&lt;x1/&gt;include &lt;immintrin.h&gt;

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;strides(A)[i]&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083450Z" creationid="hsugawa8651" creationdate="20181113T083450Z">
        <seg>&lt;x1/&gt;strides(A)[i]&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x1/&gt;x&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132233Z" creationid="hsugawa8651" creationdate="20181113T132233Z">
        <seg>&lt;x1/&gt;x&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;:
The operators &lt;x14/&gt;+&lt;x15/&gt;, &lt;x16/&gt;++&lt;x17/&gt; and &lt;x18/&gt;*&lt;x19/&gt; are non-associative.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030943Z" creationid="hsugawa8651" creationdate="20181114T030934Z">
        <seg>&lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;: 演算子&lt;x14/&gt;+&lt;x15/&gt;、&lt;x16/&gt;++&lt;x17/&gt;、&lt;x18/&gt;*&lt;x19/&gt;は、非自動調整ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x12/&gt;user&lt;x13/&gt; defaults to current user,
&lt;x14/&gt;port&lt;x15/&gt; to the standard ssh port.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092522Z" creationid="hsugawa8651" creationdate="20181109T224441Z">
        <seg>デフォルトでは、&lt;x12/&gt;user&lt;x13/&gt; は現在のユーザー、 &lt;x14/&gt;port&lt;x15/&gt; は標準のsshポートになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x16/&gt;count&lt;x17/&gt; is the number of workers to spawn on the node, and defaults
to 1.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092547Z" creationid="hsugawa8651" creationdate="20181109T224446Z">
        <seg>&lt;x16/&gt;count&lt;x17/&gt;はノードで作成されるワーカーの数で、デフォルトは1です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x2/&gt;QuickSort&lt;x3/&gt; is the default algorithm for numeric values, including
integers and floats.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064035Z" creationid="hsugawa8651" creationdate="20181114T064035Z">
        <seg>&lt;x2/&gt;QuickSort&lt;x3/&gt;は、次のような数値のデフォルト・アルゴリズムです。 整数と浮動小数点を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x20/&gt;a + b + c&lt;x21/&gt; is parsed as &lt;x22/&gt;+(a, b, c)&lt;x23/&gt; not &lt;x24/&gt;+(+(a, b),
c)&lt;x25/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030937Z" creationid="hsugawa8651" creationdate="20181114T030937Z">
        <seg>&lt;x20/&gt;a + b + c&lt;x21/&gt; is parsed as &lt;x22/&gt;+(a, b, c)&lt;x23/&gt; not &lt;x24/&gt;+(+(a, b),
c)&lt;x25/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x21/&gt;DenseArray&lt;x22/&gt; is a
very specific example of a strided array where the elements are arranged contiguously, thus it
provides its subtypes with the appropriate definition of &lt;x23/&gt;strides&lt;x24/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160511Z" creationid="hsugawa8651" creationdate="20181109T160511Z">
        <seg>&lt;X21/&gt;DenseArray&lt;x22/&gt;は エレメントが隣接して配置されたストローブ配列の非常に特異的な例であり、したがって は、&lt;x23/&gt;の拡張&lt;x24/&gt;の適切な定義を使用してサブタイプを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x23/&gt;App&lt;x24/&gt; has a direct dependency on your private &lt;x25/&gt;Priv&lt;x26/&gt; package, and an indirect dependency, through &lt;x27/&gt;Pub&lt;x28/&gt;, on the new public &lt;x29/&gt;Priv&lt;x30/&gt; package.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152902Z" creationid="hsugawa8651" creationdate="20181117T152902Z">
        <seg>&lt;x23/&gt;アプリケーション&lt;x24/&gt;は、&lt;x27/&gt;Priv&lt;x26/&gt;パッケージに直接依存します。また、&lt;x27/&gt;Pub&lt;x28/&gt;を介して、新しい&lt;x29/&gt;Priv&lt;x30/&gt;パッケージ上の間接的な依存関係もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x28/&gt;`StridedVector`&lt;x29/&gt; and &lt;x30/&gt;`StridedMatrix`&lt;x31/&gt; are convenient aliases for many of the builtin array types that
are considered strided arrays, allowing them to dispatch to select specialized implementations that
call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160519Z" creationid="hsugawa8651" creationdate="20181109T160519Z">
        <seg>&lt;x28/&gt;「StridedVector」&lt;x29/&gt;および&lt;x30/&gt;「StridedMatrix」&lt;x31/&gt;は、組み込み型の配列タイプの多くにとって便利なエイリアスです。 は、ストレーテッド・アレイとみなされ、選択された特殊な実装にディスパッチできるようになります。 ポインタと前進だけを使って、BLASとLAPACK関数を高度に調整し、最適化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x3/&gt;
import REPL, Markdown
const NBSP = '\u00A0'

function tab_completions(symbols...)
    completions = Dict{String, Vector{String}}()
    for each in symbols, (k, v) in each
        completions[v] = push!(get!(completions, v, String[]), k)
    end
    return completions
end

function unicode_data()
    file = normpath(Sys.BINDIR, "..", "..", "doc", "UnicodeData.txt")
    names = Dict{UInt32, String}()
    open(file) do unidata
        for line in readlines(unidata)
            id, name, desc = split(line, ";")[[1, 2, 11]]
            codepoint = parse(UInt32, "0x$id")
            names[codepoint] = titlecase(lowercase(
                name == "" ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022214Z" creationid="hsugawa8651" creationdate="20181116T022214Z">
        <seg>&lt;x3/&gt;
import REPL, Markdown
const NBSP = '\u00A0'

function tab_completions(symbols...)
    completions = Dict{String, Vector{String}}()
    for each in symbols, (k, v) in each
        completions[v] = push!(get!(completions, v, String[]), k)
    end
    return completions
end

function unicode_data()
    file = normpath(Sys.BINDIR, "..", "..", "doc", "UnicodeData.txt")
    names = Dict{UInt32, String}()
    open(file) do unidata
        for line in readlines(unidata)
            id, name, desc = split(line, ";")[[1, 2, 11]]
            codepoint = parse(UInt32, "0x$id")
            names[codepoint] = titlecase(lowercase(
                name == "" ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x4/&gt;Cstring&lt;x5/&gt; can also be used as
the &lt;x6/&gt;`ccall`&lt;x7/&gt; return type, but in that case it obviously does not introduce any extra
checks and is only meant to improve readability of the call.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150955Z" creationid="hsugawa8651" creationdate="20181117T150955Z">
        <seg>&lt;x4/&gt;Cstring&lt;x5/&gt;は、次のように使用することもできます。 &lt;x6/&gt;`ccall'&lt;x7/&gt;return typeであるが、この場合は明らかに余分なものは導入されない。 は、呼び出しの可読性を向上させることを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x4/&gt;library&lt;x5/&gt; refers
to the shared library name: shared libraries available in the (platform-specific) load path will
be resolved by name, and if necessary a direct path may be specified.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161423Z" creationid="hsugawa8651" creationdate="20181114T161423Z">
        <seg>&lt;x4/&gt;ライブラリ&lt;x5/&gt;は以下のとおりです。 共有ライブラリの名前:(プラットフォーム固有の)ロードパスで使用可能な共有ライブラリ 名前で解決する必要があり、必要に応じて直接パスを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x5/&gt;X .+= Y&lt;x6/&gt; etcetera is equivalent to &lt;x7/&gt;X .= X .+ Y&lt;x8/&gt; and results in a fused in-place assignment;
see also &lt;x9/&gt;&lt;x10/&gt;&lt;x11/&gt;(@ref man-dot-operators).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T105916Z" creationid="hsugawa8651" creationdate="20181112T105916Z">
        <seg>&lt;x5/&gt;X.+=Y&lt;x6/&gt;eteteraは&lt;x7/&gt;Xと同等であり、X.+Y&lt;x8/&gt;Y&lt;x8/&gt;となり、結果は融合されたインプレース割り当てになります。 &lt;x9/&gt;&lt;x10/&gt;&lt;x11/&gt;(@ref man dot演算子)も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x7/&gt;DefaultArrayStyle&lt;x8/&gt; and the abstract supertype, &lt;x9/&gt;AbstractArrayStyle&lt;x10/&gt;, store the dimensionality as a type parameter to support specialized
array types that have fixed dimensionality requirements.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131806Z" creationid="hsugawa8651" creationdate="20181113T131806Z">
        <seg>&lt;x7/&gt;DefaultArrayStyle&lt;x8/&gt;と抽象型スーパータイプ&lt;x9/&gt;AbstractArrayStyle&lt;x10/&gt;は、特殊化されたものをサポートするために、次元をタイプパラメータとして格納します。 固定された次元要件を持つ配列タイプ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x7/&gt;Priv&lt;x8/&gt; is a private package that you created, whereas &lt;x9/&gt;Pub&lt;x10/&gt; is a public package that you use but don't control.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152850Z" creationid="hsugawa8651" creationdate="20181117T152850Z">
        <seg>&lt;x7/&gt;Priv&lt;x8/&gt;は、作成したプライベート・パッケージですが、&lt;x9/&gt;Pub&lt;x10/&gt;は使用するパブリック・パッケージですが、制御することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x7/&gt;`AbstractVector`&lt;x8/&gt; and &lt;x9/&gt;`AbstractMatrix`&lt;x10/&gt; are
aliases for the 1-d and 2-d cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161351Z" creationid="hsugawa8651" creationdate="20181114T161351Z">
        <seg>&lt;x7/&gt;'AbstractVector'&lt;x8/&gt;および&lt;x9/&gt;'AbstractMatrix&lt;x10/&gt;は 1-dおよび2-dケースのエイリアス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x7/&gt;`ccall`&lt;x8/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152231Z" creationid="hsugawa8651" creationdate="20181117T152231Z">
        <seg>&lt;x7/&gt;`ccall`&lt;x8/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x7/&gt;compare&lt;x8/&gt; is a callback function which takes pointers to two elements &lt;x9/&gt;a&lt;x10/&gt; and &lt;x11/&gt;b&lt;x12/&gt; and returns
an integer less/greater than zero if &lt;x13/&gt;a&lt;x14/&gt; should appear before/after &lt;x15/&gt;b&lt;x16/&gt; (or zero if any order
is permitted).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150526Z" creationid="hsugawa8651" creationdate="20181117T150526Z">
        <seg>&lt;x7/&gt;比較&lt;x8/&gt;は、2つの要素&lt;x9/&gt;a&lt;x10/&gt;と&lt;x11/&gt;b&lt;x12/&gt;と&lt;x12/&gt;b&lt;x12/&gt;のポインタを取得するコールバック関数であり &lt;x15/&gt;b&lt;x16/&gt;の前/後&lt;x15/&gt;b&lt;x16/&gt;(いずれかの順序がある場合は0)の前に&lt;x13/&gt;a&lt;x14/&gt;を表示する必要がある場合は、0より小さい/大きい整数 が許可されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;x8/&gt;`view`&lt;x9/&gt; stores the input index vectors in a
&lt;x10/&gt;SubArray&lt;x11/&gt; object, which can later be used to index the original array
indirectly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160440Z" creationid="hsugawa8651" creationdate="20181109T160440Z">
        <seg>&lt;x8/&gt;'view'&lt;x9/&gt;は、入力インデックスベクトルを &lt;x10/&gt;サブアレイ&lt;x11/&gt;オブジェクトで、後でオリジナルの配列をインデックス化するために使用できます。 間接的に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= += -= *= /= //= \= ^= ÷= %= \|= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030912Z" creationid="hsugawa8651" creationdate="20181114T030912Z">
        <seg>= += -= *= /= //= \= ^= ÷= %= \|= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=&lt;x1/&gt;&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032255Z" creationid="hsugawa8651" creationdate="20181114T032255Z">
        <seg>=&lt;x1/&gt;&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=&lt;x1/&gt;&lt;x2/&gt; is ignored by &lt;x3/&gt;bash&lt;x4/&gt; since it stops
parsing the file once it reaches to the &lt;x5/&gt;exec&lt;x6/&gt; statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024947Z" creationid="hsugawa8651" creationdate="20181110T024947Z">
        <seg>=&lt;x1/&gt;&lt;x2/&gt;は、&lt;x3/&gt;bash&lt;x4/&gt;によって無視されます。なぜならば、それは停止するからです。 &lt;x5/&gt;exec&lt;x6/&gt;ステートメントに到達したファイルを解析します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>===&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063624Z" creationid="hsugawa8651" creationdate="20181114T063624Z">
        <seg>===&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=&gt;&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030907Z" creationid="hsugawa8651" creationdate="20181114T030907Z">
        <seg>=&gt;&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; &lt; &gt;= &lt;= == === != !== &lt;:&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030859Z" creationid="hsugawa8651" creationdate="20181114T030859Z">
        <seg>&gt; &lt; &gt;= &lt;= == === != !== &lt;:&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;:&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063602Z" creationid="hsugawa8651" creationdate="20181114T063602Z">
        <seg>&gt;:&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063201Z" creationid="hsugawa8651" creationdate="20181114T063201Z">
        <seg>?&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?cos
?@time
?r""</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020059Z" creationid="hsugawa8651" creationdate="20181116T020059Z">
        <seg>?cos
?@time
?r""</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@doc (@doc foo!) foo</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020125Z" creationid="hsugawa8651" creationdate="20181116T020125Z">
        <seg>@doc (@doc foo!) foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@doc raw"""
...
"""
f(x) = x</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020121Z" creationid="hsugawa8651" creationdate="20181116T020121Z">
        <seg>@doc raw"""
...
"""
f(x) = x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@eval begin
    &lt;x1/&gt; multiple lines
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015609Z" creationid="hsugawa8651" creationdate="20181116T015609Z">
        <seg>@eval begin
    &lt;x1/&gt; multiple lines
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@eval ccall(($(string("a", "b")), "lib"), ...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152304Z" creationid="hsugawa8651" creationdate="20181117T152304Z">
        <seg>@eval ccall(($(string("a", "b")), "lib"), ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@m&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150220Z" creationid="hsugawa8651" creationdate="20181117T150220Z">
        <seg>@m&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@name (expr1, expr2, ...)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015403Z" creationid="hsugawa8651" creationdate="20181116T015403Z">
        <seg>@name (expr1, expr2, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@name expr1 expr2 ...
@name(expr1, expr2, ...)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015400Z" creationid="hsugawa8651" creationdate="20181116T015400Z">
        <seg>@name expr1 expr2 ...
@name(expr1, expr2, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@name[a b] * v
@name([a b]) * v</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015406Z" creationid="hsugawa8651" creationdate="20181116T015406Z">
        <seg>@name[a b] * v
@name([a b]) * v</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@static Sys.iswindows() ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225012Z" creationid="hsugawa8651" creationdate="20181109T225012Z">
        <seg>@static Sys.iswindows() ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@static if Sys.islinux()
    linux_specific_thing(a)
else
    generic_thing(a)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224958Z" creationid="hsugawa8651" creationdate="20181109T224958Z">
        <seg>@static if Sys.islinux()
    linux_specific_thing(a)
else
    generic_thing(a)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
great deal of care has been taken to ensure that Julia does them correctly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030659Z" creationid="hsugawa8651" creationdate="20181114T030659Z">
        <seg>A ジュリアが正しいことをすることを保証するために、細心の注意が払われてきました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "strided" array is stored in memory with elements laid out in regular offsets such that
an instance with a supported &lt;x1/&gt;isbits&lt;x2/&gt; element type can be passed to
external C and Fortran functions that expect this memory layout.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160455Z" creationid="hsugawa8651" creationdate="20181109T160455Z">
        <seg>"stried"配列は、規則的なオフセットに配置された要素を含むメモリに格納されます。 サポートされる&lt;x1/&gt;イスビトス&lt;x2/&gt;エレメントタイプを持つインスタンスは このメモリレイアウトを期待する外部CとFortranの関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;x1/&gt;(:function, "library")&lt;x2/&gt; pair, which must be written as a literal constant,</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223837Z" creationid="hsugawa8651" creationdate="20181109T223837Z">
        <seg>&lt;x1/&gt;(:関数、"ライブラリ")&lt;x2/&gt;ペアで、リテラル定数として記述される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;x1/&gt;(name, library)&lt;x2/&gt; function specification must be a constant expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152259Z" creationid="hsugawa8651" creationdate="20181117T152259Z">
        <seg>&lt;x1/&gt;(名前、ライブラリ)&lt;x2/&gt;関数仕様は、定数式でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;x1/&gt;package&lt;x2/&gt; is a source tree with a standard layout providing functionality that can be reused by other Julia projects.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152804Z" creationid="hsugawa8651" creationdate="20181117T152804Z">
        <seg>&lt;x1/&gt;パッケージ&lt;x2/&gt;は、他のジュリアプロジェクトによって再利用可能な機能を提供する標準的なレイアウトを備えたソースツリーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;x17/&gt;MethodError&lt;x18/&gt; should be thrown if &lt;x19/&gt;x&lt;x20/&gt; cannot be displayed
as that MIME type; this is automatic if one calls &lt;x21/&gt;show&lt;x22/&gt; or &lt;x23/&gt;repr&lt;x24/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043316Z" creationid="hsugawa8651" creationdate="20181112T043316Z">
        <seg>&lt;x19/&gt;x&lt;x20/&gt;が表示されない場合は、&lt;x17/&gt;MethodError&lt;x18/&gt;をスローする必要があります。 このMIMEタイプは、&lt;X21/&gt;show&lt;x22/&gt;または&lt;x23/&gt;repr&lt;x24/&gt;を呼び出すと自動的に表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;x4/&gt;SubArray&lt;x5/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150516Z" creationid="hsugawa8651" creationdate="20181117T150509Z">
        <seg>&lt;x4/&gt;サブアレイ&lt;x5/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A = [ F(x,y,...) for x=rx, y=ry, ... ]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064529Z" creationid="hsugawa8651" creationdate="20181114T064529Z">
        <seg>A = [ F(x,y,...) for x=rx, y=ry, ... ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Julia Function</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133904Z" creationid="hsugawa8651" creationdate="20181117T133904Z">
        <seg>ジュリア関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A classic example is the standard C library &lt;x1/&gt;qsort&lt;x2/&gt; function, declared as:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133921Z" creationid="hsugawa8651" creationdate="20181117T133921Z">
        <seg>典型的な例として、標準的なCライブラリ&lt;x1/&gt;qsort&lt;x2/&gt;関数があり、次のように宣言されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constructor is just like any other function in Julia in that its overall behavior is defined
by the combined behavior of its methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155705Z" creationid="hsugawa8651" creationdate="20181117T155705Z">
        <seg>コンストラクタは、その全体的な振る舞いが定義されているという点で、Juliaの他の関数と同じです。 それは、その方法の組み合わせによるものである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A curated list of useful learning resources to help new users get started can be found on the &lt;x1/&gt;learning&lt;x2/&gt; page of the main Julia web site.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224812Z" creationid="hsugawa8651" creationdate="20181109T224812Z">
        <seg>新しいユーザを支援するための有用な学習リソースのリストは、Julia Webサイトの&lt;x1/&gt;学習&lt;x2/&gt;ページに掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function &lt;x1/&gt;`display(x)`&lt;x2/&gt; to request the richest available multimedia display of a Julia object
&lt;x3/&gt;x&lt;x4/&gt; (with a plain-text fallback).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043225Z" creationid="hsugawa8651" creationdate="20181112T043225Z">
        <seg>Juliaオブジェクトの最もリッチなマルチメディアディスプレイを要求する関数&lt;x1/&gt;`display(x)`&lt;x2/&gt; &lt;x3/&gt;x&lt;x4/&gt;(プレーンテキストのフォールバックを使用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function is called using the traditional parenthesis syntax:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025625Z" creationid="hsugawa8651" creationdate="20181110T025625Z">
        <seg>関数は、従来の括弧構文を使用して呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function name may be used alone in place of the tuple (just &lt;x1/&gt;:function&lt;x2/&gt; or &lt;x3/&gt;"function"&lt;x4/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223757Z" creationid="hsugawa8651" creationdate="20181109T223757Z">
        <seg>関数の関数名はタプルの代わりに単独で使用することができる(単に&lt;x1/&gt;:関数&lt;x2/&gt;または&lt;x3/&gt;"関数&lt;x4/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function name may be used alone in place of the tuple (just &lt;x1/&gt;:function&lt;x2/&gt; or &lt;x3/&gt;"function"&lt;x4/&gt;). In
this case the name is resolved within the current process. This form can be used to call C library
functions, functions in the Julia runtime, or functions in an application linked to Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133752Z" creationid="hsugawa8651" creationdate="20181117T133752Z">
        <seg>タプルの代わりに関数名を使用することができます(単に&lt;x1/&gt;:関数&lt;x2/&gt;または&lt;x3/&gt;"関数&lt;x4/&gt;&lt;x x/&gt;&lt;x4/&gt;&lt;x/&gt;)。 この場合、現在のプロセス内で名前が解決されます。このフォームを使用してCライブラリを呼び出すことができます。 関数、Juliaランタイム内の関数、またはJuliaにリンクされたアプリケーションの関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key part in defining an &lt;x1/&gt;AbstractArray&lt;x2/&gt; subtype is &lt;x3/&gt;`IndexStyle`&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022659Z" creationid="hsugawa8651" creationdate="20181113T022659Z">
        <seg>&lt;x1/&gt;AbstractArray&lt;x2/&gt;サブタイプの定義における重要な部分は&lt;x3/&gt;'IndexStyleである&lt;x4/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A literal tuple of input types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133909Z" creationid="hsugawa8651" creationdate="20181117T133909Z">
        <seg>入力タイプのリテラル・タプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A logical index
must be a vector of the same length as the dimension it indexes into, or it
must be the only index provided and match the size and dimensionality of the
array it indexes into.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155807Z" creationid="hsugawa8651" creationdate="20181109T155807Z">
        <seg>論理インデックス は、インデックスを作成する寸法と同じ長さのベクトルである必要があります。また 指定された唯一のインデックスであり にインデックスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A lot of the power and extensibility in Julia comes from a collection of informal interfaces.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112047Z" creationid="hsugawa8651" creationdate="20181112T112047Z">
        <seg>Juliaのパワーと拡張性の多くは、インフォーマルなインターフェースの集合から生まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nested tree of
&lt;x5/&gt;Broadcasted&lt;x6/&gt; containers is directly constructed by the implicit dot syntax; &lt;x7/&gt;5 .+ 2.*x&lt;x8/&gt; is
transiently represented by &lt;x9/&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;x10/&gt;, for example.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131520Z" creationid="hsugawa8651" creationdate="20181113T131520Z">
        <seg>ネストされたツリー &lt;x5/&gt;ブロードキャスト&lt;x6/&gt;コンテナは、暗黙的なドット構文によって構成されます。&lt;x7/&gt;5.+2.*x&lt;x8/&gt;は &lt;x9/&gt;ブロードキャスト(+,5,ブロードキャスト(*, 2, x))&lt;x10/&gt;などによって一時的に表現される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A notable exception is &lt;x25/&gt;AbstractString&lt;x26/&gt;;
strings are special-cased to behave as scalars for the purposes of broadcast even though
they are iterable collections of their characters (see &lt;x27/&gt;Strings&lt;x28/&gt; for more).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131103Z" creationid="hsugawa8651" creationdate="20181113T131103Z">
        <seg>注目すべき例外は&lt;x25/&gt;AbstractString&lt;x26/&gt;です。 文字列は、ブロードキャストの目的で、ブロードキャストのために それらは、それらの文字(詳細は&lt;x27/&gt;の文字列&lt;x28/&gt;を参照)のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A notable exception is &lt;x5/&gt;`unsafe_wrap`&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152246Z" creationid="hsugawa8651" creationdate="20181117T152246Z">
        <seg>注目すべき例外は、&lt;x5/&gt;'insafe_wrap'&lt;x6/&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A package directory&lt;x1/&gt; is a directory containing the source trees of a set of packages as subdirectories.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152923Z" creationid="hsugawa8651" creationdate="20181117T152923Z">
        <seg>パッケージディレクトリ&lt;x1/&gt;は、サブディレクトリとしてパッケージセットのソースツリーを格納したディレクトリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A package is loaded by &lt;x3/&gt;import X&lt;x4/&gt; or  &lt;x5/&gt;using X&lt;x6/&gt; statements.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152801Z" creationid="hsugawa8651" creationdate="20181117T152801Z">
        <seg>X&lt;x6/&gt;ステートメントを使用して、&lt;x3/&gt;インポートX&lt;x4/&gt;または&lt;x5/&gt;を使用してパッケージをロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pointer
to memory allocated by Julia must be of type &lt;x13/&gt;Ref{gsl_permutation}&lt;x14/&gt;, to ensure that the memory
address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed
to correctly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152134Z" creationid="hsugawa8651" creationdate="20181117T152134Z">
        <seg>ポインタ Juliaによって割り当てられたメモリは、メモリを確保するためには&lt;x13/&gt;Ref{gsl_mutation}&lt;x14/&gt;のようにする必要があります。 指定されたアドレスは有効であり、ジュリアのガーベッジ・コレクターは、指定されたメモリーのチャンクを管理しています。 正確に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A prefix &lt;x1/&gt;&amp;&lt;x2/&gt; is used on an argument to &lt;x3/&gt;`ccall`&lt;x4/&gt; to indicate that a pointer to a scalar
argument should be passed instead of the scalar value itself (required for all Fortran function
arguments, as noted above).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151844Z" creationid="hsugawa8651" creationdate="20181117T151844Z">
        <seg>プレフィックス&lt;x1/&gt;&amp;&lt;x2/&gt;は、スカラーへのポインタを示すために、&lt;x3/&gt;'ccall'&lt;x4/&gt;への引数で使用されます。 スカラー値自体の代わりに引数を渡す必要があります(すべてのFortran関数に対して必要です)。 引数は前述のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A project environment&lt;x1/&gt; is a directory with a project file and an optional manifest file.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152917Z" creationid="hsugawa8651" creationdate="20181117T152917Z">
        <seg>プロジェクト環境&lt;x1/&gt;は、プロジェクトファイルとオプションのマニフェストファイルを持つディレクトリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rich language of types for constructing and describing objects,
that can also optionally be used to make type declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082102Z" creationid="hsugawa8651" creationdate="20181118T082013Z">
        <seg>オブジェクトを作成したり説明したりするのに使うことができる、型に関する豊富な機能を提供します。プログラマ自身で型を宣言することもできます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar index.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150441Z" creationid="hsugawa8651" creationdate="20181117T150441Z">
        <seg>スカラーインデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar index. By default this includes:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134945Z" creationid="hsugawa8651" creationdate="20181117T134945Z">
        <seg>スカラー・インデックスです。デフォルトでは、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A similar example can be constructed for &lt;x6/&gt;`@cfunction`&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152315Z" creationid="hsugawa8651" creationdate="20181117T152315Z">
        <seg>同様の例は、&lt;x6/&gt;`@cfunction`&lt;x7/&gt;のために構成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple example is an iterable sequence of square numbers with a defined length:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112450Z" creationid="hsugawa8651" creationdate="20181112T112450Z">
        <seg>単純な例は、定義された長さの2乗数のiterableシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stacked environment&lt;x1/&gt; is an ordered set of project environments and package directories, overlaid to make a single composite environment in which all the packages available in its constituent environments are available.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152930Z" creationid="hsugawa8651" creationdate="20181117T152930Z">
        <seg>スタック環境&lt;x1/&gt;は、プロジェクト環境とパッケージディレクトリの順序付きセットで、その構成環境で使用可能なすべてのパッケージが利用可能な単一の複合環境を作成するためにオーバーレイされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A strided array is a subtype of &lt;x1/&gt;AbstractArray&lt;x2/&gt; whose entries are stored in memory with fixed strides.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083457Z" creationid="hsugawa8651" creationdate="20181113T083457Z">
        <seg>ストローブされたアレイは、&lt;x1/&gt;AbstractArray&lt;x2/&gt;のサブタイプであり、そのエントリは固定された歩進でメモリ内に格納される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple of input types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223952Z" creationid="hsugawa8651" creationdate="20181109T223952Z">
        <seg>入力タイプのタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued
variable or expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133810Z" creationid="hsugawa8651" creationdate="20181117T133810Z">
        <seg>入力タイプのタプル。入力タイプはタプルではなくリテラル・タプルとして記述される必要があります。 変数または式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A typical example of a user-defined strided array is one
that wraps a standard &lt;x3/&gt;Array&lt;x4/&gt; with additional structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083506Z" creationid="hsugawa8651" creationdate="20181113T083506Z">
        <seg>ユーザ定義のストローブ配列の典型的な例は一つです。 これは、標準的な&lt;x3/&gt;アレイ&lt;x/&gt;を追加の構造でラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A typical usage of such a pair of return values, however, extracts each value into a variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101451Z" creationid="hsugawa8651" creationdate="20181112T101451Z">
        <seg>しかし、このような戻り値の典型的な使用法は、それぞれの値を変数に抽出することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A way to determine that a file is run in
this fashion is to check if &lt;x3/&gt;abspath(PROGRAM_FILE) == @__FILE__&lt;x4/&gt; is &lt;x5/&gt;true&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024900Z" creationid="hsugawa8651" creationdate="20181110T024900Z">
        <seg>ファイルが実行されることを判別する方法 この方法は、&lt;x3/&gt;アブスパス(PROGRAM_FILE)==@_FILE__&lt;x4/&gt;が&lt;x6/&gt;真&lt;x6/&gt;であるかどうかをチェックすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A'&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025859Z" creationid="hsugawa8651" creationdate="20181110T025859Z">
        <seg>A'&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A.n = x&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025934Z" creationid="hsugawa8651" creationdate="20181110T025934Z">
        <seg>A.n = x&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A.n&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025918Z" creationid="hsugawa8651" creationdate="20181110T025918Z">
        <seg>A.n&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A&lt;x1/&gt; is overwritten with the value &lt;x2/&gt;X[i_1, i_2, ..., i_n]&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155417Z" creationid="hsugawa8651" creationdate="20181109T155417Z">
        <seg>&lt;x1/&gt;は、&lt;x2/&gt;X[i_1,i_2,…,i_n]&lt;x3/&gt;の値で上書きされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A&lt;x1/&gt; is overwritten with the value &lt;x2/&gt;X[i_1, i_2, ..., i_n]&lt;x3/&gt;. If &lt;x4/&gt;X&lt;x5/&gt; is not an array, its value
is written to all referenced locations of &lt;x6/&gt;A&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134928Z" creationid="hsugawa8651" creationdate="20181117T134928Z">
        <seg>&lt;x1/&gt;は値&lt;x2/&gt;X[i_1,i_2,…i_n]&lt;x3/&gt;で上書きされます。&lt;x4/&gt;X&lt;x5/&gt;が配列でない場合、その値はその値を返します。 は、&lt;x6/&gt;A&lt;x7/&gt;の参照されたすべての場所に書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A&lt;x1/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132601Z" creationid="hsugawa8651" creationdate="20181113T132601Z">
        <seg>A&lt;x1/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A[I_1, I_2, ..., I_n] = X</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134919Z" creationid="hsugawa8651" creationdate="20181117T134919Z">
        <seg>A[I_1, I_2, ..., I_n] = X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A[i] = x&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025915Z" creationid="hsugawa8651" creationdate="20181110T025915Z">
        <seg>A[i] = x&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A[i]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025906Z" creationid="hsugawa8651" creationdate="20181110T025906Z">
        <seg>A[i]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aardvark/
    src/Aardvark.jl:
        import Bobcat
        import Cobra

Bobcat/
    Project.toml:
        [deps]
        Cobra = "4725e24d-f727-424b-bca0-c4307a3456fa"
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Bobcat.jl:
        import Cobra
        import Dingo

Cobra/
    Project.toml:
        uuid = "4725e24d-f727-424b-bca0-c4307a3456fa"
        [deps]
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Cobra.jl:
        import Dingo

Dingo/
    Project.toml:
        uuid = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Dingo.jl:
        &lt;x1/&gt; no imports</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015945Z" creationid="hsugawa8651" creationdate="20181116T015945Z">
        <seg>Aardvark/
    src/Aardvark.jl:
        import Bobcat
        import Cobra

Bobcat/
    Project.toml:
        [deps]
        Cobra = "4725e24d-f727-424b-bca0-c4307a3456fa"
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Bobcat.jl:
        import Cobra
        import Dingo

Cobra/
    Project.toml:
        uuid = "4725e24d-f727-424b-bca0-c4307a3456fa"
        [deps]
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Cobra.jl:
        import Dingo

Dingo/
    Project.toml:
        uuid = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Dingo.jl:
        &lt;x1/&gt; no imports</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract number types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044708Z" creationid="hsugawa8651" creationdate="20181112T044708Z">
        <seg>Abstract number types</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AbstractString&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041613Z" creationid="hsugawa8651" creationdate="20181112T041613Z">
        <seg>AbstractString&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Data through a Pointer</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152522Z" creationid="hsugawa8651" creationdate="20181117T152522Z">
        <seg>ポインタを介してデータにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Global Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152506Z" creationid="hsugawa8651" creationdate="20181117T152506Z">
        <seg>グローバル変数へのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accordingly, you can add functionality to a constructor
by simply defining new methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155707Z" creationid="hsugawa8651" creationdate="20181117T155707Z">
        <seg>したがって、コンストラクタに機能を追加することができます。 新しい方法を定義することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding an integer to a &lt;x5/&gt;Ptr&lt;x6/&gt; in Julia always moves the pointer by some number of
&lt;x7/&gt;bytes&lt;x8/&gt;, not elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152616Z" creationid="hsugawa8651" creationdate="20181117T152616Z">
        <seg>ジュリアの&lt;x6/&gt;Ptr&lt;x6/&gt;に整数を追加すると、常にポインタがいくつかの数だけ移動します。 &lt;x7/&gt;バイト&lt;x8/&gt;で、要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding parentheses lets
us add a third argument to &lt;x3/&gt;`map`&lt;x4/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154956Z" creationid="hsugawa8651" creationdate="20181109T154956Z">
        <seg>括弧を追加すると &lt;x3/&gt;'map`&lt;x4/&gt;:に3番目の引数を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional
convenience constructor methods, supplying default values or auxiliary transformations, should
be provided as outer constructors that call the inner constructors to do the heavy lifting.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155833Z" creationid="hsugawa8651" creationdate="20181117T155833Z">
        <seg>追加 便利なコンストラクタメソッド、デフォルト値または補助変換を提供する必要があります。 内部コンストラクタを呼び出す外部コンストラクタとして提供され、このコンストラクタは重いリフティングを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional functionality is available from a growing collection of available packages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150049Z" creationid="hsugawa8651" creationdate="20181110T041650Z">
        <seg>その他の機能は、利用可能なパッケージのコレクションから入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally,
there is a macro &lt;x7/&gt;@static&lt;x8/&gt; which makes it possible to use these functions to conditionally hide
invalid code, as demonstrated in the following examples.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224947Z" creationid="hsugawa8651" creationdate="20181109T224947Z">
        <seg>さらに マクロ&lt;x7/&gt;@static&lt;x8/&gt;があるため、これらの関数を使用して条件付きで非表示にすることができます。 次の例で示されているように、無効なコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, &lt;x1/&gt;`broadcast`&lt;x2/&gt; is not limited to arrays (see the function documentation),
it also handles tuples and treats any argument that is not an array, tuple or &lt;x3/&gt;`Ref`&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160134Z" creationid="hsugawa8651" creationdate="20181109T160134Z">
        <seg>さらに、&lt;x1/&gt;`broadcast'&lt;x2/&gt;は配列に限定されるものではありません(関数の文書を参照してください)。 また、タプルや、配列ではない引数、タプル、&lt;x3/&gt;`Ref"&lt;x4/&gt;を処理することもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, Julia provides
software support for &lt;x1/&gt;Arbitrary Precision Arithmetic&lt;x2/&gt;, which can handle operations on numeric
values that cannot be represented effectively in native hardware representations, but at the cost
of relatively slower performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225054Z" creationid="hsugawa8651" creationdate="20181109T225054Z">
        <seg>さらに、ジュリアは &lt;x1/&gt;任意精度算術演算&lt;x2/&gt;のソフトウェアサポートで、数値の操作を処理できます。 ネイティブのハードウェア表現では効果的に表現できないが、コストでは効果的に表現できない値 比較的遅いパフォーマンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, full support for &lt;x1/&gt;Complex and Rational Numbers&lt;x2/&gt; is built on top of these primitive
numeric types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225152Z" creationid="hsugawa8651" creationdate="20181109T225152Z">
        <seg>さらに、&lt;x1/&gt;ComplexおよびRational Numbers&lt;x2/&gt;の完全なサポートは、これらのプリミティブに基づいて構築されています。 数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication
of the expression by the variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111834Z" creationid="hsugawa8651" creationdate="20181112T111834Z">
        <seg>さらに、括弧で括られた表現は変数の係数として使用され、乗算を意味します。 変数による表現は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, to support the syntax &lt;x1/&gt;S[end]&lt;x2/&gt;, we must define &lt;x3/&gt;`lastindex`&lt;x4/&gt; to specify the last
valid index.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113116Z" creationid="hsugawa8651" creationdate="20181112T113116Z">
        <seg>さらに、構文&lt;x1/&gt;S[end]&lt;x2/&gt;をサポートするためには、最後の値を指定するために&lt;x3/&gt;`lastindex'&lt;x4/&gt;を定義する必要があります。 有効なインデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All comma-separated expressions after &lt;x1/&gt;for&lt;x2/&gt; are interpreted as ranges.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154952Z" creationid="hsugawa8651" creationdate="20181109T154948Z">
        <seg>&lt;x2/&gt;のために&lt;x1/&gt;の後にコンマで区切られたすべての式は、範囲として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All comma-separated expressions after &lt;x1/&gt;for&lt;x2/&gt; are interpreted as ranges. Adding parentheses lets
us add a third argument to &lt;x3/&gt;`map`&lt;x4/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134816Z" creationid="hsugawa8651" creationdate="20181117T134816Z">
        <seg>&lt;x2/&gt;で&lt;x1/&gt;の後にカンマで区切られたすべての式は、範囲として解釈されます。括弧を追加すると &lt;x3/&gt;'map`&lt;x4/&gt;:に3番目の引数を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All dimensions indexed with scalars are dropped.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160835Z" creationid="hsugawa8651" creationdate="20181114T160835Z">
        <seg>スカラーでインデックス付けされたすべての次元は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All numeric types interoperate naturally without explicit casting, thanks to a
flexible, user-extensible &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref conversion-and-promotion).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225156Z" creationid="hsugawa8651" creationdate="20181109T225156Z">
        <seg>すべての数値型は、明示的なキャストなしで自然に相互運用されます。 柔軟なユーザー拡張可能な&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref変換とプロモーション)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other types are stored as a pointer
to the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151139Z" creationid="hsugawa8651" creationdate="20181117T151139Z">
        <seg>他のすべてのタイプはポインタとして保存されます。 データに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the looping is performed compile-time,
and we avoid looping during execution entirely.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032336Z" creationid="hsugawa8651" creationdate="20181116T032336Z">
        <seg>すべてのループはコンパイル時に実行されます。 実行中のループを完全に回避することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the sorting and order related functions rely on a "less than" relation defining a total order
on the values to be manipulated.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063939Z" creationid="hsugawa8651" creationdate="20181112T045027Z">
        <seg>ソートと順序の関連関数はすべて、合計オーダーを定義する「より少ない」リレーションに依存しています。 操作する値を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allocation of output container</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083532Z" creationid="hsugawa8651" creationdate="20181113T083532Z">
        <seg>Allocation of output container</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alright, now that we have a better understanding of how generated functions work, let's use them
to build some more advanced (and valid) functionality...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032239Z" creationid="hsugawa8651" creationdate="20181116T032239Z">
        <seg>分かりました、生成された関数がどのように機能するかをよく理解してから、それを使ってみましょう。 より高度な(かつ有効な)機能を構築するために。。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also &lt;x3/&gt;in&lt;x4/&gt; and &lt;x5/&gt;isa&lt;x6/&gt; are parsed as infix operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041805Z" creationid="hsugawa8651" creationdate="20181110T041805Z">
        <seg>&lt;x4/&gt;では&lt;x3/&gt;、&lt;x5/&gt;では&lt;x6/&gt;である&lt;x6/&gt;は、インフィックス演算子として解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also notice the difference between &lt;x1/&gt;max.(a,b)&lt;x2/&gt;, which &lt;x3/&gt;`broadcast`&lt;x4/&gt;s &lt;x5/&gt;`max`&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160027Z" creationid="hsugawa8651" creationdate="20181109T160027Z">
        <seg>また、&lt;x1/&gt;の最大値(a,b)&lt;x2/&gt;は、&lt;x3/&gt;"ブロードキャスト"&lt;x4/&gt;"max"&lt;x6/&gt;"max'&lt;x6/&gt;の差があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also recommended is Bruce Dawson's &lt;x1/&gt;series of blog posts on floating-point numbers&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111500Z" creationid="hsugawa8651" creationdate="20181112T111500Z">
        <seg>また、浮動小数点数&lt;x2/&gt;についてはBruce Dawsonの&lt;x1/&gt;シリーズのブログ記事をお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, &lt;x1/&gt;every&lt;x2/&gt; binary operator supports a &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man-dot-operators)
that can be applied to arrays (and combinations of arrays and scalars) in such
&lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref man-vectorized), e.g. &lt;x9/&gt;z .== sin.(x .* y)&lt;x10/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160010Z" creationid="hsugawa8651" creationdate="20181109T160010Z">
        <seg>また、&lt;x2/&gt;バイナリ演算子の&lt;x1/&gt;は、&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man dot演算子)をサポートします。 は、配列(および配列とスカラーの組み合わせ)に適用することができます。 &lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref manベクトル化)、例えば&lt;x9/&gt;z.=sin.(x .* y)&lt;x10/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, note that there is no compatibility layer that ensures the intrinsic makes
sense and works on the current target,
unlike the equivalent Julia functions exposed by &lt;x3/&gt;Core.Intrinsics&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152503Z" creationid="hsugawa8651" creationdate="20181117T152503Z">
        <seg>また、固有のmakeを確実にする互換性レイヤーは存在しないことに注意してください。 現在の目標を意識して これは、&lt;x3/&gt;コアによって露出される同等のジュリア関数とは異なります。inintrics&lt;x4/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, when calling a Fortran function, all inputs must be passed as
pointers to allocated values on the heap or stack.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223810Z" creationid="hsugawa8651" creationdate="20181109T223810Z">
        <seg>また、Fortran関数を呼び出す場合は、すべての入力を次のように指定する必要があります。 ヒープまたはスタック上の割り当てられた値へのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, &lt;x1/&gt;using Module&lt;x2/&gt; will import all exported &lt;x3/&gt;Module&lt;x4/&gt; functions into the current namespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041717Z" creationid="hsugawa8651" creationdate="20181110T041717Z">
        <seg>あるいは、モジュール&lt;x2/&gt;を使用する&lt;x1/&gt;は、エクスポートされたすべての&lt;x3/&gt;モジュール&lt;x4/&gt;関数を現在の名前空間にインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the precision
or the rounding can be changed only within the execution of a particular block of code by using
the same functions with a &lt;x4/&gt;do&lt;x5/&gt; block:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111701Z" creationid="hsugawa8651" creationdate="20181112T111701Z">
        <seg>あるいは、精度 または、次のようにして、特定のコード・ブロックを実行する場合にのみ、丸めを変更することができます。 &lt;x4/&gt;do&lt;x5/&gt;ブロックを持つ同じ機能を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can use &lt;x7/&gt;julia -e 'include(popfirst!(ARGS))'
file.jl&lt;x8/&gt; to execute a script while being able to catch
&lt;x9/&gt;InterruptException&lt;x10/&gt; in the &lt;x11/&gt;`try`&lt;x12/&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024913Z" creationid="hsugawa8651" creationdate="20181110T024913Z">
        <seg>または、&lt;x7/&gt;julia-e'include(ポプファースト!(ARGS))'を使用することもできます。 ファイル.jl&lt;x8/&gt;を実行すると、スクリプトをキャッチしながらスクリプトを実行することができます。 &lt;x11/&gt;'try'&lt;x12/&gt;ブロックで&lt;x9/&gt;InterruptException&lt;x10/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it is generally a good idea to return a fully initialized object from an inner constructor,
it is possible to return incompletely initialized objects:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155923Z" creationid="hsugawa8651" creationdate="20181117T155923Z">
        <seg>一般的には、内部コンストラクタから完全に初期化されたオブジェクトを返すことは、良い考えです。 不完全に初期化されたオブジェクトを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it is typical, there is no requirement that &lt;x3/&gt;begin&lt;x4/&gt; blocks be multiline
or that &lt;x5/&gt;(;)&lt;x6/&gt; chains be single-line:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225821Z" creationid="hsugawa8651" creationdate="20181109T225821Z">
        <seg>典型的なものではあるが、&lt;x3/&gt;が&lt;x4/&gt;ブロックがマルチラインである必要はない。 または&lt;x5/&gt;(;)&lt;x6/&gt;鎖は単一行である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although one sometimes speaks of dynamic languages as being “typeless”,
they are definitely not: every object, whether primitive or
user-defined, has a type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082226Z" creationid="hsugawa8651" creationdate="20181118T082226Z">
        <seg>動的言語は「型がない」と言われることがありますが、そんなことはありません。 プリミティブであれユーザー定義であれ、全てのオブジェクトは何らかの型を持ちます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;x1/&gt;environment&lt;x2/&gt; determines what &lt;x3/&gt;import X&lt;x4/&gt; and &lt;x5/&gt;using X&lt;x6/&gt; mean in various code contexts and what files these statements cause to be loaded.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152914Z" creationid="hsugawa8651" creationdate="20181117T152914Z">
        <seg>&lt;x1/&gt;環境&lt;x2/&gt;は、X&lt;x6/&gt;のインポートX&lt;x4/&gt;および&lt;x5/&gt;を、さまざまなコードコンテキストでX&lt;x6/&gt;平均を使用して決定し、これらの文がロードするファイルを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array is a collection of objects stored in a multi-dimensional grid.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154138Z" creationid="hsugawa8651" creationdate="20181109T154138Z">
        <seg>配列は、多次元グリッドに格納されたオブジェクトの集合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array of scalar indices.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155517Z" creationid="hsugawa8651" creationdate="20181109T155517Z">
        <seg>スカラー・インデックスの配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array of scalar indices. This includes:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134957Z" creationid="hsugawa8651" creationdate="20181117T134957Z">
        <seg>スカラー・インデックスの配列です。これには次のようなものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array with a specific element type can be constructed using the syntax &lt;x1/&gt;T[A, B, C, ...]&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154659Z" creationid="hsugawa8651" creationdate="20181109T154659Z">
        <seg>特定の要素タイプを持つ配列は、構文&lt;x1/&gt;T[A,B,C,…]&lt;x2/&gt;を使用して構築することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array with a specific element type can be constructed using the syntax &lt;x1/&gt;T[A, B, C, ...]&lt;x2/&gt;. This
will construct a 1-d array with element type &lt;x3/&gt;T&lt;x4/&gt;, initialized to contain elements &lt;x5/&gt;A&lt;x6/&gt;, &lt;x7/&gt;B&lt;x8/&gt;, &lt;x9/&gt;C&lt;x10/&gt;,
etc. For example, &lt;x11/&gt;Any[x, y, z]&lt;x12/&gt; constructs a heterogeneous array that can contain any values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134641Z" creationid="hsugawa8651" creationdate="20181117T134641Z">
        <seg>特定のエレメントタイプを持つ配列は、構文&lt;x1/&gt;T[A,B,C,…]&lt;x2/&gt;を使用して構築できます。 要素タイプ&lt;x3/&gt;T&lt;x4/&gt;を持つ1dアレイを構築し、要素&lt;x5/&gt;A&lt;x6/&gt;、&lt;x7/&gt;B&lt;x8/&gt;、&lt;x9/&gt;C&lt;x10/&gt;を含むように初期化します。 たとえば、&lt;x11/&gt;任意の[x,y,z]&lt;x12/&gt;は、任意の値を含むことができる異機種間配列を構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An inefficient way to do this would
be to replicate the vector to the size of the matrix:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160043Z" creationid="hsugawa8651" creationdate="20181109T160043Z">
        <seg>非効率的な方法は ベクトルをマトリックスのサイズに複製することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An inner constructor method
is like an outer constructor method, except for two differences:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155735Z" creationid="hsugawa8651" creationdate="20181117T155735Z">
        <seg>内部コンストラクタのメソッド は、2つの違いを除いて、外部コンストラクタメソッドのようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object that represents an array of scalar indices and can be converted to such by &lt;x1/&gt;`to_indices`&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155534Z" creationid="hsugawa8651" creationdate="20181109T155534Z">
        <seg>スカラーインデックスの配列を表すオブジェクトであって、&lt;x1/&gt;"to_indices"&lt;x2/&gt;によって変換されることが可能である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object that represents an array of scalar indices and can be converted to such by &lt;x1/&gt;`to_indices`&lt;x2/&gt;. By default this includes:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135000Z" creationid="hsugawa8651" creationdate="20181117T135000Z">
        <seg>スカラーインデックスの配列を表すオブジェクトで、&lt;x1/&gt;によって変換されて、&lt;x1/&gt;によって変換されます。デフォルトでは、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Julia type that is not a subtype of &lt;x5/&gt;`Signed`&lt;x6/&gt; is assumed to be unsigned.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150822Z" creationid="hsugawa8651" creationdate="20181117T150822Z">
        <seg>&lt;x5/&gt;'署名された&lt;x6/&gt;のサブタイプではないジュリア型は、符号なしであると仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any custom array of scalar indices that is a subtype of &lt;x1/&gt;AbstractArray&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155529Z" creationid="hsugawa8651" creationdate="20181109T155529Z">
        <seg>&lt;x1/&gt;AbstractArray&lt;x2/&gt;のサブタイプであるスカラーインデックスの任意のカスタム配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any object that defines this function is iterable and can be used in the &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref lib-collections-iteration).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112432Z" creationid="hsugawa8651" creationdate="20181112T112432Z">
        <seg>この関数を定義するすべてのオブジェクトは、iterableであることができ、&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref libコレクション反復)で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any object that has &lt;x10/&gt;`axes`&lt;x11/&gt; and supports
indexing can participate as an argument in broadcasting, and by default the result is stored
in an &lt;x12/&gt;Array&lt;x13/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131018Z" creationid="hsugawa8651" creationdate="20181113T131018Z">
        <seg>&lt;x10/&gt;'軸&lt;x11/&gt;を持つすべてのオブジェクトをサポートします。 インデックス作成はブロードキャスト時に引き数として参加することができ、デフォルトではその結果は格納される &lt;x12/&gt;アレイ&lt;x13/&gt;で使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any operation that throws an error is probably currently unimplemented and should be posted as
a bug so that it can be resolved.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152604Z" creationid="hsugawa8651" creationdate="20181117T152604Z">
        <seg>エラーをスローする操作は、現在実装されていないため、次のように記述する必要があります。 バグを解決できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112202Z" creationid="hsugawa8651" creationdate="20181112T112202Z">
        <seg>Any&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any&lt;x1/&gt;, &lt;x2/&gt;AbstractArray{T, N}&lt;x3/&gt;, &lt;x4/&gt;Complex{T}&lt;x5/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150633Z" creationid="hsugawa8651" creationdate="20181117T150633Z">
        <seg>Any&lt;x1/&gt;, &lt;x2/&gt;AbstractArray{T, N}&lt;x3/&gt;, &lt;x4/&gt;Complex{T}&lt;x5/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applied to the &lt;x1/&gt;sub2ind&lt;x2/&gt; example above, it would look like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032353Z" creationid="hsugawa8651" creationdate="20181116T032353Z">
        <seg>上記の&lt;x1/&gt;sub2ind&lt;x2/&gt;の例に適用されますが、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments
to &lt;x3/&gt;`ccall`&lt;x4/&gt; are as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223834Z" creationid="hsugawa8651" creationdate="20181109T223834Z">
        <seg>引数 &lt;x3/&gt;'ccall'&lt;x4/&gt;は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments to &lt;x3/&gt;`@cfunction`&lt;x4/&gt; are as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153935Z" creationid="hsugawa8651" creationdate="20181109T153935Z">
        <seg>&lt;x3/&gt;`@cfunction`&lt;x4/&gt;への引数は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arithmetic Operators</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094728Z" creationid="hsugawa8651" creationdate="20181118T094728Z">
        <seg>算術演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arithmetic on the &lt;x1/&gt;Ptr&lt;x2/&gt; type in Julia (e.g. using &lt;x3/&gt;+&lt;x4/&gt;) does not behave the same as C's pointer
arithmetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152613Z" creationid="hsugawa8651" creationdate="20181117T152613Z">
        <seg>&lt;x1/&gt;Ptr&lt;x2/&gt;の算術は、ジュリア(例えば&lt;x3/&gt;+&lt;x4/&gt;)の場合と同じように、Cのポインタと同じように動作しません。 演算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array and Vectorized Operators and Functions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135137Z" creationid="hsugawa8651" creationdate="20181117T135137Z">
        <seg>配列演算子とベクトル化演算子と関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array data structures are typically
defined in one of two ways: either it most efficiently accesses its elements using just one index
(linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022707Z" creationid="hsugawa8651" creationdate="20181113T022707Z">
        <seg>アレイ・データ構造は通常 2つの方法の一つで定義されています:1つのインデックスのみを使用して、その要素に最も効率的にアクセスすることができます (linear indexing)または本質的に、すべての次元に指定されたインデックスを持つ要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array functions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020245Z" creationid="hsugawa8651" creationdate="20181116T020245Z">
        <seg>Array functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array traits</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150444Z" creationid="hsugawa8651" creationdate="20181117T150444Z">
        <seg>配列特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays can be constructed and also concatenated using the following functions:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154543Z" creationid="hsugawa8651" creationdate="20181109T154543Z">
        <seg>配列は、次の関数を使用して構成したり、連結することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays can easily be sorted according to an arbitrary transformation of their values:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063824Z" creationid="hsugawa8651" creationdate="20181114T063824Z">
        <seg>配列は、値の任意の変換に従って簡単に並べ替えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of &lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt; (see below for more details)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155531Z" creationid="hsugawa8651" creationdate="20181109T155531Z">
        <seg>&lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt;(詳細については以下を参照)のアレイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of &lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt; are also supported.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161022Z" creationid="hsugawa8651" creationdate="20181114T161022Z">
        <seg>&lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt;のアレイもサポートされている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of &lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt; are also supported. They represent a collection
of scalar indices that each span &lt;x3/&gt;N&lt;x4/&gt; dimensions, enabling a form of indexing
that is sometimes referred to as pointwise indexing. For example, it enables
accessing the diagonal elements from the first "page" of &lt;x5/&gt;A&lt;x6/&gt; from above:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135025Z" creationid="hsugawa8651" creationdate="20181117T135025Z">
        <seg>&lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt;の配列もサポートされています。これらはコレクションを表します。 各スパン&lt;x3/&gt;N&lt;x4/&gt;の各次元を使用可能にするスカラー指数のことで、索引の形式が可能になります。 これはポイントインデキシングと呼ばれることがあります。たとえば、次のようになります。 上からの&lt;x5/&gt;A&lt;x6/&gt;の最初の「ページ」からの対角線要素へのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of booleans, which select elements at their &lt;x1/&gt;true&lt;x2/&gt; indices (see below for more details)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155544Z" creationid="hsugawa8651" creationdate="20181109T155544Z">
        <seg>ブール値の配列で、&lt;x1/&gt;真の&lt;x2/&gt;インデックスで要素を選択します(詳細については、以下を参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of parameters can be expressed with &lt;x1/&gt;NTuple&lt;x2/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151154Z" creationid="hsugawa8651" creationdate="20181117T151154Z">
        <seg>パラメータの配列は、&lt;x1/&gt;NUpset&lt;x2/&gt;で表現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of unknown size (C99-compliant variable length structs specified by &lt;x1/&gt;[]&lt;x2/&gt; or &lt;x3/&gt;[0]&lt;x4/&gt;) are not directly supported.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022808Z" creationid="hsugawa8651" creationdate="20181116T022808Z">
        <seg>Arrays of unknown size (C99-compliant variable length structs specified by &lt;x1/&gt;[]&lt;x2/&gt; or &lt;x3/&gt;[0]&lt;x4/&gt;) are not directly supported.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array{Ref,1}&lt;x1/&gt; to hold these values, until
the C library notifies you that it is finished with them.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152238Z" creationid="hsugawa8651" creationdate="20181117T152238Z">
        <seg>配列{Ref,1}&lt;x1/&gt;を指定して、次の値を保持します。 Cライブラリは、それが完了したことを通知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array{S}(undef, dims)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022453Z" creationid="hsugawa8651" creationdate="20181113T022453Z">
        <seg>Array{S}(undef, dims)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array{T,N}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134455Z" creationid="hsugawa8651" creationdate="20181117T134455Z">
        <seg>Array{T,N}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a complete but simple example, the following calls the &lt;x1/&gt;clock&lt;x2/&gt; function from the standard C
library:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224014Z" creationid="hsugawa8651" creationdate="20181109T224014Z">
        <seg>完全ではあるが単純な例として、以下の呼び出しは標準Cから&lt;x1/&gt;クロック&lt;x2/&gt;関数を呼び出します。 ライブラリ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built
on top of &lt;x1/&gt;`Dict`&lt;x2/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083217Z" creationid="hsugawa8651" creationdate="20181113T083217Z">
        <seg>より複雑な例として、独自の玩具N次元の疎な配列タイプの配列を作成します。 top of&lt;x1/&gt;'Dict'&lt;x2/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the code may produce a memory leak if &lt;x14/&gt;result_array&lt;x15/&gt; never gets
freed by the garbage collector, or if the garbage collector prematurely frees &lt;x16/&gt;result_array&lt;x17/&gt;,
the C function may end up throwing an invalid memory access exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152221Z" creationid="hsugawa8651" creationdate="20181117T152221Z">
        <seg>結果として、&lt;x14/&gt;result_array&lt;x15/&gt;が決して実行されない場合、コードはメモリリークを生成する可能性があります。 ガーベッジ・コレクタによって解放されるか、ガーベッジ・コレクタが&lt;x16/&gt;の結果_array&lt;x17/&gt;を早期に解放するか C関数は、無効なメモリアクセス例外をスローする可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the type of the
variable may change.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132421Z" creationid="hsugawa8651" creationdate="20181113T132421Z">
        <seg>その結果 変数が変更される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special part of this syntax, the &lt;x1/&gt;end&lt;x2/&gt; keyword may be used to represent the last index of
each dimension within the indexing brackets, as determined by the size of the innermost array
being indexed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155252Z" creationid="hsugawa8651" creationdate="20181109T155252Z">
        <seg>この構文の特殊な部分として、&lt;x1/&gt;end&lt;x2/&gt;キーワードを使用して、最後のインデックスを表すことができます。 最も内側の配列のサイズによって決定される、索引付けブラケット内の各寸法 インデックス化されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special part of this syntax, the &lt;x1/&gt;end&lt;x2/&gt; keyword may be used to represent the last index of
each dimension within the indexing brackets, as determined by the size of the innermost array
being indexed. Indexing syntax without the &lt;x3/&gt;end&lt;x4/&gt; keyword is equivalent to a call to &lt;x5/&gt;`getindex`&lt;x6/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134841Z" creationid="hsugawa8651" creationdate="20181117T134841Z">
        <seg>この構文の特殊な部分として、&lt;x1/&gt;end&lt;x2/&gt;キーワードを使用して、最後のインデックスを表すことができます。 最も内側の配列のサイズによって決定される、索引付けブラケット内の各寸法 インデックス作成されています。&lt;x3/&gt;end&lt;x4/&gt;キーワードなしのインデックス構文は、&lt;x5/&gt;`getindex'&lt;x6/&gt;への呼び出しと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the builtin &lt;x1/&gt;AbstractRange&lt;x2/&gt; objects use this machinery to optimize pieces
of broadcasted expressions that can be eagerly evaluated purely in terms of the start,
step, and length (or stop) instead of computing every single element.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131616Z" creationid="hsugawa8651" creationdate="20181113T131616Z">
        <seg>たとえば、組み込みの&lt;x1/&gt;AbstractRange&lt;x2/&gt;オブジェクトは、この機械を使用してピースを最適化します。 純粋に評価された表現の始まりです 1つの要素を計算するのではなく、ステップと長さ(または停止)を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As can be seen, &lt;x1/&gt;A&lt;x2/&gt; is changed to the sorted array &lt;x3/&gt;[-2.7, 1.3, 3.1, 4.4]&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150538Z" creationid="hsugawa8651" creationdate="20181117T150538Z">
        <seg>図示されるように、&lt;x1/&gt;A&lt;x2/&gt;は、ソートされたアレイ&lt;x3/&gt;[-2.7、1.3、3.1、4.4]&lt;x4/&gt;に変更される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As can be seen, &lt;x1/&gt;A&lt;x2/&gt; is changed to the sorted array &lt;x3/&gt;[-2.7, 1.3, 3.1, 4.4]&lt;x4/&gt;. Note that Julia
knows how to convert an array into a &lt;x5/&gt;Ptr{Cdouble}&lt;x6/&gt;, how to compute the size of a type in bytes
(identical to C's &lt;x7/&gt;sizeof&lt;x8/&gt; operator), and so on. For fun, try inserting a &lt;x9/&gt;println("mycompare($a, $b)")&lt;x10/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134209Z" creationid="hsugawa8651" creationdate="20181117T134209Z">
        <seg>図のように、&lt;x1/&gt;A&lt;x2/&gt;はソートされた配列&lt;x3/&gt;[-2.7、1.3、3.1、4.4]&lt;x4/&gt;に変更されることに注意してください。 配列を&lt;x5/&gt;Ptr{Cdouble}&lt;x6/&gt;に変換する方法を知っています。バイト単位でタイプのサイズを計算する方法 (Cの&lt;x7/&gt;sizeof&lt;x8/&gt;演算子と同じ)。遊びの場合は&lt;x9/&gt;println("ミコンパレ($a, $b)")を挿入してください。&lt;x10/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As for hexadecimal literals, binary and octal literals produce unsigned integer types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225505Z" creationid="hsugawa8651" creationdate="20181109T225505Z">
        <seg>16進数のリテラルに関しては、バイナリと8進数のリテラルは符号なしの整数型を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion
of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished)
may make sense.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064234Z" creationid="hsugawa8651" creationdate="20181114T064234Z">
        <seg>数値配列については、概念が存在する配列タイプに対して、安定していないデフォルトアルゴリズムを選択してください。 安定したソートは意味がありません(つまり、等しい値を比較する2つの値が区別されない場合) 意味があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in C and most other imperative
or functional languages, the &lt;x5/&gt;return&lt;x6/&gt; keyword causes a function to return immediately, providing
an expression whose value is returned:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025731Z" creationid="hsugawa8651" creationdate="20181110T025731Z">
        <seg>Cとその他のほとんどの命令 または関数を使用すると、&lt;x5/&gt;return&lt;x6/&gt;キーワードによって関数が即座に返され、次の関数が返されます。 値が返される式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, one can also define new display backends.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043304Z" creationid="hsugawa8651" creationdate="20181112T043304Z">
        <seg>上記のように、新しいディスプレイバックエンドを定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, it's also possible to define custom array types by inheriting
from &lt;x1/&gt;`AbstractArray`&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154132Z" creationid="hsugawa8651" creationdate="20181109T154132Z">
        <seg>このように、カスタム配列タイプを継承することによって、カスタム配列タイプを定義することも可能です。 &lt;x1/&gt;'AbstractArray'&lt;x2/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the example implies, the following command-line arguments to &lt;c0&gt;&lt;s1&gt;julia&lt;/s1&gt;&lt;/c0&gt;
are taken as command-line arguments to the program &lt;c2&gt;&lt;s3&gt;script.jl&lt;/s3&gt;&lt;/c2&gt;, passed
in the global constant &lt;c4&gt;&lt;s5&gt;ARGS&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084705Z" creationid="hsugawa8651" creationdate="20181118T084507Z">
        <seg>上の例が示すように、後ろの引数は &lt;c2&gt;&lt;s3&gt;script.jl&lt;/s3&gt;&lt;/c2&gt; というプログラムのコマンドライン引数として取られ、 グローバル定数 &lt;c4&gt;&lt;s5&gt;ARGS&lt;/s5&gt;&lt;/c4&gt;に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the example implies, the following command-line arguments to &lt;x1/&gt;julia&lt;x2/&gt; are interpreted as
command-line arguments to the program &lt;x3/&gt;script.jl&lt;x4/&gt;, passed in the global constant &lt;x5/&gt;ARGS&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091747Z" creationid="hsugawa8651" creationdate="20181109T224332Z">
        <seg>上の例が示すように、後ろの引数は &lt;x1/&gt;script.jl&lt;x2/&gt;というプログラムのコマンドライン引数として取られ、 グローバル定数 &lt;x5/&gt;ARGS&lt;x6/&gt;に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As user code never has to look inside the &lt;x9/&gt;gsl_permutation&lt;x10/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151936Z" creationid="hsugawa8651" creationdate="20181117T151936Z">
        <seg>ユーザコードは、&lt;x9/&gt;gsl_mutation&lt;x10/&gt;の中では絶対に内部を見る必要がない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any &lt;x1/&gt;ccall&lt;x2/&gt;, it is essential to get the argument signature exactly correct.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152501Z" creationid="hsugawa8651" creationdate="20181117T152501Z">
        <seg>任意の&lt;x1/&gt;ccall&lt;x2/&gt;と同様に、引数シグニチャを正確に取得することが必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134913Z" creationid="hsugawa8651" creationdate="20181117T134913Z">
        <seg>割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At &lt;x1/&gt;-O3&lt;x2/&gt;, the compiler &lt;x3/&gt;might&lt;x4/&gt; automatically vectorize operations on such tuples.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063651Z" creationid="hsugawa8651" creationdate="20181114T063651Z">
        <seg>&lt;x1/&gt;-O3&lt;x2/&gt;では、コンパイラ&lt;x/&gt;は、そのようなタプル上のオペレーションを自動的にベクトル化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Auto-conversion:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150557Z" creationid="hsugawa8651" creationdate="20181117T150557Z">
        <seg>自動変換:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic generation of efficient, specialized code for different
argument types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082127Z" creationid="hsugawa8651" creationdate="20181118T082127Z">
        <seg>それぞれの引数の型ごとに最適化されたコードを自動生成します
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base Modules</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150102Z" creationid="hsugawa8651" creationdate="20181117T150102Z">
        <seg>Base Modules</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.:-(::Any)
Base.:(+)
Base.:-(::Any, ::Any)
Base.:*(::Any, ::Any...)
Base.:(/)
Base.:\(::Any, ::Any)
Base.:^(::Number, ::Number)
Base.fma
Base.muladd
Base.inv(::Number)
Base.div
Base.fld
Base.cld
Base.mod
Base.rem
Base.rem2pi
Base.Math.mod2pi
Base.divrem
Base.fldmod
Base.fld1
Base.mod1
Base.fldmod1
Base.:(//)
Base.rationalize
Base.numerator
Base.denominator
Base.:(&lt;&lt;)
Base.:(&gt;&gt;)
Base.:(&gt;&gt;&gt;)
Base.:(:)
Base.range
Base.OneTo
Base.StepRangeLen
Base.:(==)
Base.:(!=)
Base.:(!==)
Base.:(&lt;)
Base.:(&lt;=)
Base.:(&gt;)
Base.:(&gt;=)
Base.cmp
Base.:(&lt;x1/&gt;)
Base.:(&amp;)
Base.:(|)
Base.xor
Base.:(!)
&amp;&amp;
||</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043423Z" creationid="hsugawa8651" creationdate="20181112T043423Z">
        <seg>Base.:-(::Any)
Base.:(+)
Base.:-(::Any, ::Any)
Base.:*(::Any, ::Any...)
Base.:(/)
Base.:\(::Any, ::Any)
Base.:^(::Number, ::Number)
Base.fma
Base.muladd
Base.inv(::Number)
Base.div
Base.fld
Base.cld
Base.mod
Base.rem
Base.rem2pi
Base.Math.mod2pi
Base.divrem
Base.fldmod
Base.fld1
Base.mod1
Base.fldmod1
Base.:(//)
Base.rationalize
Base.numerator
Base.denominator
Base.:(&lt;&lt;)
Base.:(&gt;&gt;)
Base.:(&gt;&gt;&gt;)
Base.:(:)
Base.range
Base.OneTo
Base.StepRangeLen
Base.:(==)
Base.:(!=)
Base.:(!==)
Base.:(&lt;)
Base.:(&lt;=)
Base.:(&gt;)
Base.:(&gt;=)
Base.cmp
Base.:(&lt;x1/&gt;)
Base.:(&amp;)
Base.:(|)
Base.xor
Base.:(!)
&amp;&amp;
||</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.@__dot__</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020229Z" creationid="hsugawa8651" creationdate="20181116T020229Z">
        <seg>Base.@__dot__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.@threadcall</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044703Z" creationid="hsugawa8651" creationdate="20181112T044703Z">
        <seg>Base.@threadcall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.AbstractRange
Base.OrdinalRange
Base.AbstractUnitRange
Base.StepRange
Base.UnitRange
Base.LinRange</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041618Z" creationid="hsugawa8651" creationdate="20181112T041618Z">
        <seg>Base.AbstractRange
Base.OrdinalRange
Base.AbstractUnitRange
Base.StepRange
Base.UnitRange
Base.LinRange</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Base
Base.Broadcast
Base.Docs
Base.Iterators
Base.Libc
Base.Meta
Base.StackTraces
Base.Sys
Base.Threads
Base.GC</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041817Z" creationid="hsugawa8651" creationdate="20181110T041817Z">
        <seg>Base.Base
Base.Broadcast
Base.Docs
Base.Iterators
Base.Libc
Base.Meta
Base.StackTraces
Base.Sys
Base.Threads
Base.GC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Broadcast.broadcasted(f, args...)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083628Z" creationid="hsugawa8651" creationdate="20181113T083628Z">
        <seg>Base.Broadcast.broadcasted(f, args...)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Broadcast.instantiate(bc::Broadcasted{DestStyle})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083641Z" creationid="hsugawa8651" creationdate="20181113T083641Z">
        <seg>Base.Broadcast.instantiate(bc::Broadcasted{DestStyle})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle
Base.Broadcast.AbstractArrayStyle
Base.Broadcast.ArrayStyle
Base.Broadcast.DefaultArrayStyle
Base.Broadcast.broadcastable</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020231Z" creationid="hsugawa8651" creationdate="20181116T020231Z">
        <seg>Base.BroadcastStyle
Base.Broadcast.AbstractArrayStyle
Base.Broadcast.ArrayStyle
Base.Broadcast.DefaultArrayStyle
Base.Broadcast.broadcastable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131750Z" creationid="hsugawa8651" creationdate="20181113T131750Z">
        <seg>Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle(::Style1, ::Style2) = Style12()</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131741Z" creationid="hsugawa8651" creationdate="20181113T131741Z">
        <seg>Base.BroadcastStyle(::Style1, ::Style2) = Style12()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle(::Style1, ::Style2) = Style12()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083536Z" creationid="hsugawa8651" creationdate="20181113T083536Z">
        <seg>Base.BroadcastStyle(::Style1, ::Style2) = Style12()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle(::Type{&lt;:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()
&lt;x1/&gt; output</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131405Z" creationid="hsugawa8651" creationdate="20181113T131405Z">
        <seg>Base.BroadcastStyle(::Type{&lt;:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()
&lt;x1/&gt; output</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.ArrayStyle{MyType}()&lt;x1/&gt; is preferred
if &lt;x2/&gt;MyType&lt;x3/&gt; is an &lt;x4/&gt;AbstractArray&lt;x5/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131239Z" creationid="hsugawa8651" creationdate="20181113T131152Z">
        <seg>Base.BroadcastStyle(::Type{&lt;:MyType})=ブロードキャスト.ArrayStyle{MyType}()&lt;x1/&gt;は優先されます。 &lt;x2/&gt;MyType&lt;x3/&gt;が&lt;x4/&gt;AbstractArray&lt;x5/&gt;である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.Style{MyType}()&lt;x1/&gt; can be
used for arbitrary types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131144Z" creationid="hsugawa8651" creationdate="20181113T131144Z">
        <seg>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.Style{MyType}()&lt;x1/&gt; can be
used for arbitrary types.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle(::Type{SrcType}) = SrcStyle()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083522Z" creationid="hsugawa8651" creationdate="20181113T083522Z">
        <seg>Base.BroadcastStyle(::Type{SrcType}) = SrcStyle()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.BroadcastStyle&lt;x1/&gt; is the abstract type from which all broadcast styles are derived.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131117Z" creationid="hsugawa8651" creationdate="20181113T131117Z">
        <seg>Base.BroadcastStyle&lt;x1/&gt;は、すべてのブロードキャストスタイルが派生する抽象型のタイプです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Dict
Base.IdDict
Base.WeakKeyDict
Base.ImmutableDict
Base.haskey
Base.get(::Any, ::Any, ::Any)
Base.get
Base.get!(::Any, ::Any, ::Any)
Base.get!(::Function, ::Any, ::Any)
Base.getkey
Base.delete!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041800Z" creationid="hsugawa8651" creationdate="20181112T041800Z">
        <seg>Base.Dict
Base.IdDict
Base.WeakKeyDict
Base.ImmutableDict
Base.haskey
Base.get(::Any, ::Any, ::Any)
Base.get
Base.get!(::Any, ::Any, ::Any)
Base.get!(::Function, ::Any, ::Any)
Base.getkey
Base.delete!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Filesystem.pwd
Base.Filesystem.cd(::AbstractString)
Base.Filesystem.cd(::Function)
Base.Filesystem.readdir
Base.Filesystem.walkdir
Base.Filesystem.mkdir
Base.Filesystem.mkpath
Base.Filesystem.symlink
Base.Filesystem.readlink
Base.Filesystem.chmod
Base.Filesystem.chown
Base.RawFD
Base.stat
Base.Filesystem.lstat
Base.Filesystem.ctime
Base.Filesystem.mtime
Base.Filesystem.filemode
Base.Filesystem.filesize
Base.Filesystem.uperm
Base.Filesystem.gperm
Base.Filesystem.operm
Base.Filesystem.cp
Base.download
Base.Filesystem.mv
Base.Filesystem.rm
Base.Filesystem.touch
Base.Filesystem.tempname
Base.Filesystem.tempdir
Base.Filesystem.mktemp(::Any)
Base.Filesystem.mktemp(::Function, ::Any)
Base.Filesystem.mktempdir(::Any)
Base.Filesystem.mktempdir(::Function, ::Any)
Base.Filesystem.isblockdev
Base.Filesystem.ischardev
Base.Filesystem.isdir
Base.Filesystem.isfifo
Base.Filesystem.isfile
Base.Filesystem.islink
Base.Filesystem.ismount
Base.Filesystem.ispath
Base.Filesystem.issetgid
Base.Filesystem.issetuid
Base.Filesystem.issocket
Base.Filesystem.issticky
Base.Filesystem.homedir
Base.Filesystem.dirname
Base.Filesystem.basename
Base.@__FILE__
Base.@__DIR__
Base.@__LINE__
Base.Filesystem.isabspath
Base.Filesystem.isdirpath
Base.Filesystem.joinpath
Base.Filesystem.abspath
Base.Filesystem.normpath
Base.Filesystem.realpath
Base.Filesystem.relpath
Base.Filesystem.expanduser
Base.Filesystem.splitdir
Base.Filesystem.splitdrive
Base.Filesystem.splitext
Base.Filesystem.splitpath</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043207Z" creationid="hsugawa8651" creationdate="20181112T043207Z">
        <seg>Base.Filesystem.pwd
Base.Filesystem.cd(::AbstractString)
Base.Filesystem.cd(::Function)
Base.Filesystem.readdir
Base.Filesystem.walkdir
Base.Filesystem.mkdir
Base.Filesystem.mkpath
Base.Filesystem.symlink
Base.Filesystem.readlink
Base.Filesystem.chmod
Base.Filesystem.chown
Base.RawFD
Base.stat
Base.Filesystem.lstat
Base.Filesystem.ctime
Base.Filesystem.mtime
Base.Filesystem.filemode
Base.Filesystem.filesize
Base.Filesystem.uperm
Base.Filesystem.gperm
Base.Filesystem.operm
Base.Filesystem.cp
Base.download
Base.Filesystem.mv
Base.Filesystem.rm
Base.Filesystem.touch
Base.Filesystem.tempname
Base.Filesystem.tempdir
Base.Filesystem.mktemp(::Any)
Base.Filesystem.mktemp(::Function, ::Any)
Base.Filesystem.mktempdir(::Any)
Base.Filesystem.mktempdir(::Function, ::Any)
Base.Filesystem.isblockdev
Base.Filesystem.ischardev
Base.Filesystem.isdir
Base.Filesystem.isfifo
Base.Filesystem.isfile
Base.Filesystem.islink
Base.Filesystem.ismount
Base.Filesystem.ispath
Base.Filesystem.issetgid
Base.Filesystem.issetuid
Base.Filesystem.issocket
Base.Filesystem.issticky
Base.Filesystem.homedir
Base.Filesystem.dirname
Base.Filesystem.basename
Base.@__FILE__
Base.@__DIR__
Base.@__LINE__
Base.Filesystem.isabspath
Base.Filesystem.isdirpath
Base.Filesystem.joinpath
Base.Filesystem.abspath
Base.Filesystem.normpath
Base.Filesystem.realpath
Base.Filesystem.relpath
Base.Filesystem.expanduser
Base.Filesystem.splitdir
Base.Filesystem.splitdrive
Base.Filesystem.splitext
Base.Filesystem.splitpath</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.GC.gc
Base.GC.enable
Base.GC.@preserve
Meta.lower
Meta.@lower
Meta.parse(::AbstractString, ::Int)
Meta.parse(::AbstractString)
Meta.ParseError
Base.macroexpand
Base.@macroexpand
Base.@macroexpand1
Base.code_lowered
Base.code_typed
Base.precompile</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042021Z" creationid="hsugawa8651" creationdate="20181110T042021Z">
        <seg>Base.GC.gc
Base.GC.enable
Base.GC.@preserve
Meta.lower
Meta.@lower
Meta.parse(::AbstractString, ::Int)
Meta.parse(::AbstractString)
Meta.ParseError
Base.macroexpand
Base.@macroexpand
Base.@macroexpand1
Base.code_lowered
Base.code_typed
Base.precompile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155911Z" creationid="hsugawa8651" creationdate="20181109T155911Z">
        <seg>Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Iterators.Stateful
Base.Iterators.zip
Base.Iterators.enumerate
Base.Iterators.rest
Base.Iterators.countfrom
Base.Iterators.take
Base.Iterators.drop
Base.Iterators.cycle
Base.Iterators.repeated
Base.Iterators.product
Base.Iterators.flatten
Base.Iterators.partition
Base.Iterators.filter
Base.Iterators.reverse</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043416Z" creationid="hsugawa8651" creationdate="20181112T043416Z">
        <seg>Base.Iterators.Stateful
Base.Iterators.zip
Base.Iterators.enumerate
Base.Iterators.rest
Base.Iterators.countfrom
Base.Iterators.take
Base.Iterators.drop
Base.Iterators.cycle
Base.Iterators.repeated
Base.Iterators.product
Base.Iterators.flatten
Base.Iterators.partition
Base.Iterators.filter
Base.Iterators.reverse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Libc.malloc
Base.Libc.calloc
Base.Libc.realloc
Base.Libc.free
Base.Libc.errno
Base.Libc.strerror
Base.Libc.GetLastError
Base.Libc.FormatMessage
Base.Libc.time(::Base.Libc.TmStruct)
Base.Libc.strftime
Base.Libc.strptime
Base.Libc.TmStruct
Base.Libc.flush_cstdio</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043420Z" creationid="hsugawa8651" creationdate="20181112T043420Z">
        <seg>Base.Libc.malloc
Base.Libc.calloc
Base.Libc.realloc
Base.Libc.free
Base.Libc.errno
Base.Libc.strerror
Base.Libc.GetLastError
Base.Libc.FormatMessage
Base.Libc.time(::Base.Libc.TmStruct)
Base.Libc.strftime
Base.Libc.strptime
Base.Libc.TmStruct
Base.Libc.flush_cstdio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.MPFR.BigFloat(::Any)
Base.precision
Base.MPFR.precision(::Type{BigFloat})
Base.MPFR.setprecision
Base.MPFR.BigFloat(x, prec::Int)
Base.MPFR.BigFloat(x::Union{Integer, AbstractFloat, String}, rounding::RoundingMode)
Base.MPFR.BigFloat(x, prec::Int, rounding::RoundingMode)
Base.GMP.BigInt(::Any)
Base.@big_str</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044736Z" creationid="hsugawa8651" creationdate="20181112T044736Z">
        <seg>Base.MPFR.BigFloat(::Any)
Base.precision
Base.MPFR.precision(::Type{BigFloat})
Base.MPFR.setprecision
Base.MPFR.BigFloat(x, prec::Int)
Base.MPFR.BigFloat(x::Union{Integer, AbstractFloat, String}, rounding::RoundingMode)
Base.MPFR.BigFloat(x, prec::Int, rounding::RoundingMode)
Base.GMP.BigInt(::Any)
Base.@big_str</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Missing
Base.missing
Base.coalesce
Base.ismissing
Base.skipmissing</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041934Z" creationid="hsugawa8651" creationdate="20181110T041934Z">
        <seg>Base.Missing
Base.missing
Base.coalesce
Base.ismissing
Base.skipmissing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Multimedia.display
Base.Multimedia.redisplay
Base.Multimedia.displayable
Base.show(::Any, ::Any, ::Any)
Base.Multimedia.showable
Base.repr(::MIME, ::Any)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043300Z" creationid="hsugawa8651" creationdate="20181112T043300Z">
        <seg>Base.Multimedia.display
Base.Multimedia.redisplay
Base.Multimedia.displayable
Base.show(::Any, ::Any, ::Any)
Base.Multimedia.showable
Base.repr(::MIME, ::Any)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Multimedia.pushdisplay
Base.Multimedia.popdisplay
Base.Multimedia.TextDisplay
Base.Multimedia.istextmime</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043352Z" creationid="hsugawa8651" creationdate="20181112T043352Z">
        <seg>Base.Multimedia.pushdisplay
Base.Multimedia.popdisplay
Base.Multimedia.TextDisplay
Base.Multimedia.istextmime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Pair
Iterators.Pairs</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043135Z" creationid="hsugawa8651" creationdate="20181112T043135Z">
        <seg>Base.Pair
Iterators.Pairs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Set
Base.BitSet
Base.union
Base.union!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041821Z" creationid="hsugawa8651" creationdate="20181112T041821Z">
        <seg>Base.Set
Base.BitSet
Base.union
Base.union!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Sort.partialsort
Base.Sort.partialsortperm
Base.Sort.partialsortperm!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063957Z" creationid="hsugawa8651" creationdate="20181114T063957Z">
        <seg>Base.Sort.partialsort
Base.Sort.partialsortperm
Base.Sort.partialsortperm!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Sort.sortslices</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150326Z" creationid="hsugawa8651" creationdate="20181117T150326Z">
        <seg>Base.Sort.sortslices</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.StackTraces.StackFrame
Base.StackTraces.StackTrace
Base.StackTraces.stacktrace</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064238Z" creationid="hsugawa8651" creationdate="20181114T064238Z">
        <seg>Base.StackTraces.StackFrame
Base.StackTraces.StackTrace
Base.StackTraces.stacktrace</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.StackTraces.lookup
Base.StackTraces.remove_frames!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064252Z" creationid="hsugawa8651" creationdate="20181114T064252Z">
        <seg>Base.StackTraces.lookup
Base.StackTraces.remove_frames!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.AbstractLock
Base.lock
Base.unlock
Base.trylock
Base.islocked
Base.ReentrantLock
Base.Threads.Mutex
Base.Threads.SpinLock
Base.Threads.RecursiveSpinLock
Base.Semaphore
Base.acquire
Base.release</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044705Z" creationid="hsugawa8651" creationdate="20181112T044705Z">
        <seg>Base.Threads.AbstractLock
Base.lock
Base.unlock
Base.trylock
Base.islocked
Base.ReentrantLock
Base.Threads.Mutex
Base.Threads.SpinLock
Base.Threads.RecursiveSpinLock
Base.Semaphore
Base.acquire
Base.release</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_add!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044652Z" creationid="hsugawa8651" creationdate="20181112T044652Z">
        <seg>Base.Threads.atomic_add!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_and!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044655Z" creationid="hsugawa8651" creationdate="20181112T044655Z">
        <seg>Base.Threads.atomic_and!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_fence</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044701Z" creationid="hsugawa8651" creationdate="20181112T044701Z">
        <seg>Base.Threads.atomic_fence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_max!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044659Z" creationid="hsugawa8651" creationdate="20181112T044659Z">
        <seg>Base.Threads.atomic_max!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_min!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044700Z" creationid="hsugawa8651" creationdate="20181112T044700Z">
        <seg>Base.Threads.atomic_min!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_nand!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044656Z" creationid="hsugawa8651" creationdate="20181112T044656Z">
        <seg>Base.Threads.atomic_nand!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_or!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044657Z" creationid="hsugawa8651" creationdate="20181112T044657Z">
        <seg>Base.Threads.atomic_or!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_sub!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044654Z" creationid="hsugawa8651" creationdate="20181112T044654Z">
        <seg>Base.Threads.atomic_sub!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_xchg!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044651Z" creationid="hsugawa8651" creationdate="20181112T044651Z">
        <seg>Base.Threads.atomic_xchg!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.atomic_xor!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044658Z" creationid="hsugawa8651" creationdate="20181112T044658Z">
        <seg>Base.Threads.atomic_xor!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Threads.threadid
Base.Threads.nthreads
Base.Threads.@threads
Base.Threads.Atomic
Base.Threads.atomic_cas!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044650Z" creationid="hsugawa8651" creationdate="20181112T044650Z">
        <seg>Base.Threads.threadid
Base.Threads.nthreads
Base.Threads.@threads
Base.Threads.Atomic
Base.Threads.atomic_cas!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.Timer(::Function, ::Real)
Base.Timer
Base.AsyncCondition
Base.AsyncCondition(::Function)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042015Z" creationid="hsugawa8651" creationdate="20181110T042015Z">
        <seg>Base.Timer(::Function, ::Real)
Base.Timer
Base.AsyncCondition
Base.AsyncCondition(::Function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.VersionNumber
Base.@v_str</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041945Z" creationid="hsugawa8651" creationdate="20181110T041945Z">
        <seg>Base.VersionNumber
Base.@v_str</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.abs
Base.Checked.checked_abs
Base.Checked.checked_neg
Base.Checked.checked_add
Base.Checked.checked_sub
Base.Checked.checked_mul
Base.Checked.checked_div
Base.Checked.checked_rem
Base.Checked.checked_fld
Base.Checked.checked_mod
Base.Checked.checked_cld
Base.Checked.add_with_overflow
Base.Checked.sub_with_overflow
Base.Checked.mul_with_overflow
Base.abs2
Base.copysign
Base.sign
Base.signbit
Base.flipsign
Base.sqrt(::Real)
Base.isqrt
Base.Math.cbrt
Base.real(::Complex)
Base.imag
Base.reim
Base.conj
Base.angle
Base.cis
Base.binomial
Base.factorial
Base.gcd
Base.lcm
Base.gcdx
Base.ispow2
Base.nextpow
Base.prevpow
Base.nextprod
Base.invmod
Base.powermod
Base.ndigits
Base.widemul
Base.Math.@evalpoly
Base.FastMath.@fastmath</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043426Z" creationid="hsugawa8651" creationdate="20181112T043426Z">
        <seg>Base.abs
Base.Checked.checked_abs
Base.Checked.checked_neg
Base.Checked.checked_add
Base.Checked.checked_sub
Base.Checked.checked_mul
Base.Checked.checked_div
Base.Checked.checked_rem
Base.Checked.checked_fld
Base.Checked.checked_mod
Base.Checked.checked_cld
Base.Checked.add_with_overflow
Base.Checked.sub_with_overflow
Base.Checked.mul_with_overflow
Base.abs2
Base.copysign
Base.sign
Base.signbit
Base.flipsign
Base.sqrt(::Real)
Base.isqrt
Base.Math.cbrt
Base.real(::Complex)
Base.imag
Base.reim
Base.conj
Base.angle
Base.cis
Base.binomial
Base.factorial
Base.gcd
Base.lcm
Base.gcdx
Base.ispow2
Base.nextpow
Base.prevpow
Base.nextprod
Base.invmod
Base.powermod
Base.ndigits
Base.widemul
Base.Math.@evalpoly
Base.FastMath.@fastmath</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.accumulate
Base.accumulate!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041610Z" creationid="hsugawa8651" creationdate="20181110T041610Z">
        <seg>Base.accumulate
Base.accumulate!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.all(::Any)
Base.all(::AbstractArray, ::Any)
Base.all!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041641Z" creationid="hsugawa8651" creationdate="20181112T041641Z">
        <seg>Base.all(::Any)
Base.all(::AbstractArray, ::Any)
Base.all!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.allunique
Base.reduce(::Any, ::Any)
Base.foldl(::Any, ::Any)
Base.foldr(::Any, ::Any)
Base.maximum
Base.maximum!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041633Z" creationid="hsugawa8651" creationdate="20181112T041633Z">
        <seg>Base.allunique
Base.reduce(::Any, ::Any)
Base.foldl(::Any, ::Any)
Base.foldr(::Any, ::Any)
Base.maximum
Base.maximum!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.any(::Any)
Base.any(::AbstractArray, ::Any)
Base.any!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041640Z" creationid="hsugawa8651" creationdate="20181112T041640Z">
        <seg>Base.any(::Any)
Base.any(::AbstractArray, ::Any)
Base.any!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.append!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041923Z" creationid="hsugawa8651" creationdate="20181112T041923Z">
        <seg>Base.append!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.bitstring
Base.parse
Base.tryparse
Base.big
Base.signed
Base.unsigned
Base.float(::Any)
Base.Math.significand
Base.Math.exponent
Base.complex(::Complex)
Base.bswap
Base.hex2bytes
Base.hex2bytes!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044714Z" creationid="hsugawa8651" creationdate="20181112T044714Z">
        <seg>Base.bitstring
Base.parse
Base.tryparse
Base.big
Base.signed
Base.unsigned
Base.float(::Any)
Base.Math.significand
Base.Math.exponent
Base.complex(::Complex)
Base.bswap
Base.hex2bytes
Base.hex2bytes!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.broadcast
Base.Broadcast.broadcast!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150011Z" creationid="hsugawa8651" creationdate="20181117T150011Z">
        <seg>Base.broadcast
Base.Broadcast.broadcast!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.broadcastable(x)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083544Z" creationid="hsugawa8651" creationdate="20181113T083544Z">
        <seg>Base.broadcastable(x)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.bytes2hex</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044715Z" creationid="hsugawa8651" creationdate="20181112T044715Z">
        <seg>Base.bytes2hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.bytesavailable
Base.ntoh
Base.hton
Base.ltoh
Base.htol
Base.ENDIAN_BOM</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043413Z" creationid="hsugawa8651" creationdate="20181112T043413Z">
        <seg>Base.bytesavailable
Base.ntoh
Base.hton
Base.ltoh
Base.htol
Base.ENDIAN_BOM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.cat
Base.vcat
Base.hcat
Base.hvcat
Base.vect
Base.circshift
Base.circshift!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020237Z" creationid="hsugawa8651" creationdate="20181116T020237Z">
        <seg>Base.cat
Base.vcat
Base.hcat
Base.hvcat
Base.vect
Base.circshift
Base.circshift!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.copy(bc::Broadcasted{DestStyle})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083600Z" creationid="hsugawa8651" creationdate="20181113T083600Z">
        <seg>Base.copy(bc::Broadcasted{DestStyle})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.copyto!(dest, bc::Broadcasted{DestStyle})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083609Z" creationid="hsugawa8651" creationdate="20181113T083609Z">
        <seg>Base.copyto!(dest, bc::Broadcasted{DestStyle})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.copyto!(dest::DestType, bc::Broadcasted{Nothing})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083619Z" creationid="hsugawa8651" creationdate="20181113T083619Z">
        <seg>Base.copyto!(dest::DestType, bc::Broadcasted{Nothing})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.count
Base.any(::Any, ::Any)
Base.all(::Any, ::Any)
Base.foreach
Base.map
Base.map!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041642Z" creationid="hsugawa8651" creationdate="20181112T041642Z">
        <seg>Base.count
Base.any(::Any, ::Any)
Base.all(::Any, ::Any)
Base.foreach
Base.map
Base.map!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.count_ones
Base.count_zeros
Base.leading_zeros
Base.leading_ones
Base.trailing_zeros
Base.trailing_ones
Base.isodd
Base.iseven
Base.@int128_str
Base.@uint128_str</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044718Z" creationid="hsugawa8651" creationdate="20181112T044718Z">
        <seg>Base.count_ones
Base.count_zeros
Base.leading_zeros
Base.leading_ones
Base.trailing_zeros
Base.trailing_ones
Base.isodd
Base.iseven
Base.@int128_str
Base.@uint128_str</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.cumprod
Base.cumprod!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041615Z" creationid="hsugawa8651" creationdate="20181110T041615Z">
        <seg>Base.cumprod
Base.cumprod!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.cumsum
Base.cumsum!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041619Z" creationid="hsugawa8651" creationdate="20181110T041619Z">
        <seg>Base.cumsum
Base.cumsum!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.deleteat!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041920Z" creationid="hsugawa8651" creationdate="20181112T041920Z">
        <seg>Base.deleteat!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.diff
Base.repeat
Base.rot180
Base.rotl90
Base.rotr90
Base.mapslices</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041623Z" creationid="hsugawa8651" creationdate="20181110T041623Z">
        <seg>Base.diff
Base.repeat
Base.rot180
Base.rotl90
Base.rotr90
Base.mapslices</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.digits
Base.digits!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044713Z" creationid="hsugawa8651" creationdate="20181112T044713Z">
        <seg>Base.digits
Base.digits!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.error
Core.throw
Base.rethrow
Base.backtrace
Base.catch_backtrace
Base.catch_stack
Base.@assert
Base.ArgumentError
Base.AssertionError
Core.BoundsError
Base.CompositeException
Base.DimensionMismatch
Core.DivideError
Core.DomainError
Base.EOFError
Core.ErrorException
Core.InexactError
Core.InterruptException
Base.KeyError
Base.LoadError
Base.MethodError
Base.MissingException
Core.OutOfMemoryError
Core.ReadOnlyMemoryError
Core.OverflowError
Core.StackOverflowError
Base.SystemError
Core.TypeError
Core.UndefKeywordError
Core.UndefRefError
Core.UndefVarError
Base.StringIndexError
Base.InitError
Base.retry
Base.ExponentialBackOff</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042002Z" creationid="hsugawa8651" creationdate="20181110T042002Z">
        <seg>Base.error
Core.throw
Base.rethrow
Base.backtrace
Base.catch_backtrace
Base.catch_stack
Base.@assert
Base.ArgumentError
Base.AssertionError
Core.BoundsError
Base.CompositeException
Base.DimensionMismatch
Core.DivideError
Core.DomainError
Base.EOFError
Core.ErrorException
Core.InexactError
Core.InterruptException
Base.KeyError
Base.LoadError
Base.MethodError
Base.MissingException
Core.OutOfMemoryError
Core.ReadOnlyMemoryError
Core.OverflowError
Core.StackOverflowError
Base.SystemError
Core.TypeError
Core.UndefKeywordError
Core.UndefRefError
Core.UndefVarError
Base.StringIndexError
Base.InitError
Base.retry
Base.ExponentialBackOff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.exit
Base.atexit
Base.isinteractive
Base.summarysize
Base.require
Base.compilecache
Base.__precompile__
Base.include
Base.MainInclude.include
Base.include_string
Base.include_dependency
Base.which(::Any, ::Any)
Base.methods
Base.@show
ans</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041730Z" creationid="hsugawa8651" creationdate="20181110T041730Z">
        <seg>Base.exit
Base.atexit
Base.isinteractive
Base.summarysize
Base.require
Base.compilecache
Base.__precompile__
Base.include
Base.MainInclude.include
Base.include_string
Base.include_dependency
Base.which(::Any, ::Any)
Base.methods
Base.@show
ans</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.extrema
Base.argmax
Base.argmin
Base.findmax
Base.findmin
Base.findmax!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041635Z" creationid="hsugawa8651" creationdate="20181112T041635Z">
        <seg>Base.extrema
Base.argmax
Base.argmin
Base.findmax
Base.findmin
Base.findmax!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.findall(::Any)
Base.findall(::Function, ::Any)
Base.findfirst(::Any)
Base.findfirst(::Function, ::Any)
Base.findlast(::Any)
Base.findlast(::Function, ::Any)
Base.findnext(::Any, ::Integer)
Base.findnext(::Function, ::Any, ::Integer)
Base.findprev(::Any, ::Integer)
Base.findprev(::Function, ::Any, ::Integer)
Base.permutedims
Base.permutedims!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020240Z" creationid="hsugawa8651" creationdate="20181116T020240Z">
        <seg>Base.findall(::Any)
Base.findall(::Function, ::Any)
Base.findfirst(::Any)
Base.findfirst(::Function, ::Any)
Base.findlast(::Any)
Base.findlast(::Function, ::Any)
Base.findnext(::Any, ::Integer)
Base.findnext(::Function, ::Any, ::Integer)
Base.findprev(::Any, ::Integer)
Base.findprev(::Function, ::Any, ::Integer)
Base.permutedims
Base.permutedims!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.findmin!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041636Z" creationid="hsugawa8651" creationdate="20181112T041636Z">
        <seg>Base.findmin!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.firstindex
Base.lastindex</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041648Z" creationid="hsugawa8651" creationdate="20181112T041648Z">
        <seg>Base.firstindex
Base.lastindex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.getindex
Base.setindex!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041647Z" creationid="hsugawa8651" creationdate="20181112T041647Z">
        <seg>Base.getindex
Base.setindex!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.getindex(::AbstractArray, ::Any...)
Base.setindex!(::AbstractArray, ::Any, ::Any...)
Base.copyto!(::AbstractArray, ::CartesianIndices, ::AbstractArray, ::CartesianIndices)
Base.isassigned
Base.Colon
Base.CartesianIndex
Base.CartesianIndices
Base.Dims
Base.LinearIndices
Base.to_indices
Base.checkbounds
Base.checkindex</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020233Z" creationid="hsugawa8651" creationdate="20181116T020233Z">
        <seg>Base.getindex(::AbstractArray, ::Any...)
Base.setindex!(::AbstractArray, ::Any, ::Any...)
Base.copyto!(::AbstractArray, ::CartesianIndices, ::AbstractArray, ::CartesianIndices)
Base.isassigned
Base.Colon
Base.CartesianIndex
Base.CartesianIndices
Base.Dims
Base.LinearIndices
Base.to_indices
Base.checkbounds
Base.checkindex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.in
Base.:∉
Base.eltype
Base.indexin
Base.unique
Base.unique!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041632Z" creationid="hsugawa8651" creationdate="20181112T041632Z">
        <seg>Base.in
Base.:∉
Base.eltype
Base.indexin
Base.unique
Base.unique!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.insert!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041919Z" creationid="hsugawa8651" creationdate="20181112T041919Z">
        <seg>Base.insert!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.intersect
Base.setdiff
Base.setdiff!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041822Z" creationid="hsugawa8651" creationdate="20181112T041822Z">
        <seg>Base.intersect
Base.setdiff
Base.setdiff!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.intersect!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041825Z" creationid="hsugawa8651" creationdate="20181112T041825Z">
        <seg>Base.intersect!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.invperm
Base.isperm
Base.permute!(::Any, ::AbstractVector)
Base.invpermute!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041628Z" creationid="hsugawa8651" creationdate="20181110T041628Z">
        <seg>Base.invperm
Base.isperm
Base.permute!(::Any, ::AbstractVector)
Base.invpermute!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.isapprox
Base.sin(::Number)
Base.cos(::Number)
Base.sincos(::Float64)
Base.tan(::Number)
Base.Math.sind
Base.Math.cosd
Base.Math.tand
Base.Math.sinpi
Base.Math.cospi
Base.sinh(::Number)
Base.cosh(::Number)
Base.tanh(::Number)
Base.asin(::Number)
Base.acos(::Number)
Base.atan(::Number)
Base.Math.asind
Base.Math.acosd
Base.Math.atand
Base.Math.sec(::Number)
Base.Math.csc(::Number)
Base.Math.cot(::Number)
Base.Math.secd
Base.Math.cscd
Base.Math.cotd
Base.Math.asec(::Number)
Base.Math.acsc(::Number)
Base.Math.acot(::Number)
Base.Math.asecd
Base.Math.acscd
Base.Math.acotd
Base.Math.sech(::Number)
Base.Math.csch(::Number)
Base.Math.coth(::Number)
Base.asinh(::Number)
Base.acosh(::Number)
Base.atanh(::Number)
Base.Math.asech(::Number)
Base.Math.acsch(::Number)
Base.Math.acoth(::Number)
Base.Math.sinc
Base.Math.cosc
Base.Math.deg2rad
Base.Math.rad2deg
Base.Math.hypot
Base.log(::Number)
Base.log(::Number, ::Number)
Base.log2
Base.log10
Base.log1p
Base.Math.frexp
Base.exp(::Float64)
Base.exp2
Base.exp10
Base.Math.ldexp
Base.Math.modf
Base.expm1
Base.round(::Type, ::Any)
Base.Rounding.RoundingMode
Base.Rounding.RoundNearest
Base.Rounding.RoundNearestTiesAway
Base.Rounding.RoundNearestTiesUp
Base.Rounding.RoundToZero
Base.Rounding.RoundFromZero
Base.Rounding.RoundUp
Base.Rounding.RoundDown
Base.round(::Complex{&lt;: AbstractFloat}, ::RoundingMode, ::RoundingMode)
Base.ceil
Base.floor
Base.trunc
Base.unsafe_trunc
Base.min
Base.max
Base.minmax
Base.Math.clamp
Base.Math.clamp!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043425Z" creationid="hsugawa8651" creationdate="20181112T043425Z">
        <seg>Base.isapprox
Base.sin(::Number)
Base.cos(::Number)
Base.sincos(::Float64)
Base.tan(::Number)
Base.Math.sind
Base.Math.cosd
Base.Math.tand
Base.Math.sinpi
Base.Math.cospi
Base.sinh(::Number)
Base.cosh(::Number)
Base.tanh(::Number)
Base.asin(::Number)
Base.acos(::Number)
Base.atan(::Number)
Base.Math.asind
Base.Math.acosd
Base.Math.atand
Base.Math.sec(::Number)
Base.Math.csc(::Number)
Base.Math.cot(::Number)
Base.Math.secd
Base.Math.cscd
Base.Math.cotd
Base.Math.asec(::Number)
Base.Math.acsc(::Number)
Base.Math.acot(::Number)
Base.Math.asecd
Base.Math.acscd
Base.Math.acotd
Base.Math.sech(::Number)
Base.Math.csch(::Number)
Base.Math.coth(::Number)
Base.asinh(::Number)
Base.acosh(::Number)
Base.atanh(::Number)
Base.Math.asech(::Number)
Base.Math.acsch(::Number)
Base.Math.acoth(::Number)
Base.Math.sinc
Base.Math.cosc
Base.Math.deg2rad
Base.Math.rad2deg
Base.Math.hypot
Base.log(::Number)
Base.log(::Number, ::Number)
Base.log2
Base.log10
Base.log1p
Base.Math.frexp
Base.exp(::Float64)
Base.exp2
Base.exp10
Base.Math.ldexp
Base.Math.modf
Base.expm1
Base.round(::Type, ::Any)
Base.Rounding.RoundingMode
Base.Rounding.RoundNearest
Base.Rounding.RoundNearestTiesAway
Base.Rounding.RoundNearestTiesUp
Base.Rounding.RoundToZero
Base.Rounding.RoundFromZero
Base.Rounding.RoundUp
Base.Rounding.RoundDown
Base.round(::Complex{&lt;: AbstractFloat}, ::RoundingMode, ::RoundingMode)
Base.ceil
Base.floor
Base.trunc
Base.unsafe_trunc
Base.min
Base.max
Base.minmax
Base.Math.clamp
Base.Math.clamp!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.isempty
Base.empty!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041622Z" creationid="hsugawa8651" creationdate="20181112T041622Z">
        <seg>Base.isempty
Base.empty!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.isimmutable
Base.isabstracttype
Base.isprimitivetype
Base.isstructtype
Base.nameof(::DataType)
Base.fieldnames
Base.fieldname</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041848Z" creationid="hsugawa8651" creationdate="20181110T041848Z">
        <seg>Base.isimmutable
Base.isabstracttype
Base.isprimitivetype
Base.isstructtype
Base.nameof(::DataType)
Base.fieldnames
Base.fieldname</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.issorted
Base.Sort.searchsorted
Base.Sort.searchsortedfirst
Base.Sort.searchsortedlast
Base.Sort.partialsort!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063955Z" creationid="hsugawa8651" creationdate="20181114T063955Z">
        <seg>Base.issorted
Base.Sort.searchsorted
Base.Sort.searchsortedfirst
Base.Sort.searchsortedlast
Base.Sort.partialsort!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.issubset
Base.:⊈
Base.:⊊
Base.issetequal</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041826Z" creationid="hsugawa8651" creationdate="20181112T041826Z">
        <seg>Base.issubset
Base.:⊈
Base.:⊊
Base.issetequal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.iterate
Base.IteratorSize
Base.IteratorEltype</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041553Z" creationid="hsugawa8651" creationdate="20181112T041553Z">
        <seg>Base.iterate
Base.IteratorSize
Base.IteratorEltype</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.keytype
Base.valtype</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041804Z" creationid="hsugawa8651" creationdate="20181112T041804Z">
        <seg>Base.keytype
Base.valtype</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.length</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041623Z" creationid="hsugawa8651" creationdate="20181112T041623Z">
        <seg>Base.length</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.mapreduce(::Any, ::Any, ::Any)
Base.mapfoldl(::Any, ::Any, ::Any)
Base.mapfoldr(::Any, ::Any, ::Any)
Base.first
Base.last
Base.step
Base.collect(::Any)
Base.collect(::Type, ::Any)
Base.filter
Base.filter!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041643Z" creationid="hsugawa8651" creationdate="20181112T041643Z">
        <seg>Base.mapreduce(::Any, ::Any, ::Any)
Base.mapfoldl(::Any, ::Any, ::Any)
Base.mapfoldr(::Any, ::Any, ::Any)
Base.first
Base.last
Base.step
Base.collect(::Any)
Base.collect(::Type, ::Any)
Base.filter
Base.filter!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.minimum
Base.minimum!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041634Z" creationid="hsugawa8651" creationdate="20181112T041634Z">
        <seg>Base.minimum
Base.minimum!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.nameof(::Module)
Base.parentmodule
Base.pathof(::Module)
Base.moduleroot
Base.@__MODULE__
Base.fullname
Base.names
Core.nfields
Base.isconst
Base.nameof(::Function)
Base.functionloc(::Any, ::Any)
Base.functionloc(::Method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042018Z" creationid="hsugawa8651" creationdate="20181110T042018Z">
        <seg>Base.nameof(::Module)
Base.parentmodule
Base.pathof(::Module)
Base.moduleroot
Base.@__MODULE__
Base.fullname
Base.names
Core.nfields
Base.isconst
Base.nameof(::Function)
Base.functionloc(::Any, ::Any)
Base.functionloc(::Method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.ndims
Base.size
Base.axes(::Any)
Base.axes(::AbstractArray, ::Any)
Base.length(::AbstractArray)
Base.eachindex
Base.IndexStyle
Base.IndexLinear
Base.IndexCartesian
Base.conj!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T033608Z" creationid="hsugawa8651" creationdate="20181110T033608Z">
        <seg>Base.ndims
Base.size
Base.axes(::Any)
Base.axes(::AbstractArray, ::Any)
Base.length(::AbstractArray)
Base.eachindex
Base.IndexStyle
Base.IndexLinear
Base.IndexCartesian
Base.conj!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.one
Base.oneunit
Base.zero
Base.im
Base.MathConstants.pi
Base.MathConstants.ℯ
Base.MathConstants.catalan
Base.MathConstants.eulergamma
Base.MathConstants.golden
Base.Inf
Base.Inf32
Base.Inf16
Base.NaN
Base.NaN32
Base.NaN16
Base.issubnormal
Base.isfinite
Base.isinf
Base.isnan
Base.iszero
Base.isone
Base.nextfloat
Base.prevfloat
Base.isinteger
Base.isreal
Core.Float32(::Any)
Core.Float64(::Any)
Base.Rounding.rounding
Base.Rounding.setrounding(::Type, ::Any)
Base.Rounding.setrounding(::Function, ::Type, ::RoundingMode)
Base.Rounding.get_zero_subnormals
Base.Rounding.set_zero_subnormals</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044716Z" creationid="hsugawa8651" creationdate="20181112T044716Z">
        <seg>Base.one
Base.oneunit
Base.zero
Base.im
Base.MathConstants.pi
Base.MathConstants.ℯ
Base.MathConstants.catalan
Base.MathConstants.eulergamma
Base.MathConstants.golden
Base.Inf
Base.Inf32
Base.Inf16
Base.NaN
Base.NaN32
Base.NaN16
Base.issubnormal
Base.isfinite
Base.isinf
Base.isnan
Base.iszero
Base.isone
Base.nextfloat
Base.prevfloat
Base.isinteger
Base.isreal
Core.Float32(::Any)
Core.Float64(::Any)
Base.Rounding.rounding
Base.Rounding.setrounding(::Type, ::Any)
Base.Rounding.setrounding(::Function, ::Type, ::RoundingMode)
Base.Rounding.get_zero_subnormals
Base.Rounding.set_zero_subnormals</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.pointer
Base.unsafe_wrap{T,N}(::Union{Type{Array},Type{Array{T}},Type{Array{T,N}}}, ::Ptr{T}, ::NTuple{N,Int})
Base.pointer_from_objref
Base.unsafe_pointer_to_objref
Base.disable_sigint
Base.reenable_sigint
Base.systemerror
Core.Ptr
Core.Ref
Base.Cchar
Base.Cuchar
Base.Cshort
Base.Cstring
Base.Cushort
Base.Cint
Base.Cuint
Base.Clong
Base.Culong
Base.Clonglong
Base.Culonglong
Base.Cintmax_t
Base.Cuintmax_t
Base.Csize_t
Base.Cssize_t
Base.Cptrdiff_t
Base.Cwchar_t
Base.Cwstring
Base.Cfloat
Base.Cdouble</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042028Z" creationid="hsugawa8651" creationdate="20181110T042028Z">
        <seg>Base.pointer
Base.unsafe_wrap{T,N}(::Union{Type{Array},Type{Array{T}},Type{Array{T,N}}}, ::Ptr{T}, ::NTuple{N,Int})
Base.pointer_from_objref
Base.unsafe_pointer_to_objref
Base.disable_sigint
Base.reenable_sigint
Base.systemerror
Core.Ptr
Core.Ref
Base.Cchar
Base.Cuchar
Base.Cshort
Base.Cstring
Base.Cushort
Base.Cint
Base.Cuint
Base.Clong
Base.Culong
Base.Clonglong
Base.Culonglong
Base.Cintmax_t
Base.Cuintmax_t
Base.Csize_t
Base.Cssize_t
Base.Cptrdiff_t
Base.Cwchar_t
Base.Cwstring
Base.Cfloat
Base.Cdouble</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.pop!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041834Z" creationid="hsugawa8651" creationdate="20181112T041834Z">
        <seg>Base.pop!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.pop!(::Any, ::Any, ::Any)
Base.keys
Base.values
Base.pairs
Base.merge
Base.merge!(::AbstractDict, ::AbstractDict...)
Base.merge!(::Function, ::AbstractDict, ::AbstractDict...)
Base.sizehint!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041802Z" creationid="hsugawa8651" creationdate="20181112T041802Z">
        <seg>Base.pop!(::Any, ::Any, ::Any)
Base.keys
Base.values
Base.pairs
Base.merge
Base.merge!(::AbstractDict, ::AbstractDict...)
Base.merge!(::Function, ::AbstractDict, ::AbstractDict...)
Base.sizehint!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.popfirst!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041918Z" creationid="hsugawa8651" creationdate="20181112T041918Z">
        <seg>Base.popfirst!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.prepend!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041924Z" creationid="hsugawa8651" creationdate="20181112T041924Z">
        <seg>Base.prepend!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.prod
Base.prod!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041639Z" creationid="hsugawa8651" creationdate="20181112T041639Z">
        <seg>Base.prod
Base.prod!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.propertynames
Core.getfield
Core.setfield!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041828Z" creationid="hsugawa8651" creationdate="20181110T041828Z">
        <seg>Base.propertynames
Core.getfield
Core.setfield!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.push!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041833Z" creationid="hsugawa8651" creationdate="20181112T041833Z">
        <seg>Base.push!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.pushfirst!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041917Z" creationid="hsugawa8651" creationdate="20181112T041917Z">
        <seg>Base.pushfirst!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.readbytes!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043211Z" creationid="hsugawa8651" creationdate="20181112T043211Z">
        <seg>Base.readbytes!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.replace(::Any, ::Pair...)
Base.replace(::Base.Callable, ::Any)
Base.replace!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041644Z" creationid="hsugawa8651" creationdate="20181112T041644Z">
        <seg>Base.replace(::Any, ::Pair...)
Base.replace(::Base.Callable, ::Any)
Base.replace!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.resize!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041922Z" creationid="hsugawa8651" creationdate="20181112T041922Z">
        <seg>Base.resize!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.reverse(::AbstractVector; kwargs...)
Base.reverseind
Base.reverse!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041634Z" creationid="hsugawa8651" creationdate="20181110T041634Z">
        <seg>Base.reverse(::AbstractVector;クワークス.) Base.レヴェルセイント ベース.リバース!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.run
Base.devnull
Base.success
Base.process_running
Base.process_exited
Base.kill(::Base.Process, ::Integer)
Base.Sys.set_process_title
Base.Sys.get_process_title
Base.ignorestatus
Base.detach
Base.Cmd
Base.setenv
Base.withenv
Base.pipeline(::Any, ::Any, ::Any, ::Any...)
Base.pipeline(::Base.AbstractCmd)
Base.Libc.gethostname
Base.Libc.getpid
Base.Libc.time()
Base.time_ns
Base.@time
Base.@timev
Base.@timed
Base.@elapsed
Base.@allocated
Base.EnvDict
Base.ENV
Base.Sys.isunix
Base.Sys.isapple
Base.Sys.islinux
Base.Sys.isbsd
Base.Sys.iswindows
Base.Sys.windows_version
Base.@static</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041940Z" creationid="hsugawa8651" creationdate="20181110T041940Z">
        <seg>Base.run
Base.devnull
Base.success
Base.process_running
Base.process_exited
Base.kill(::Base.Process, ::Integer)
Base.Sys.set_process_title
Base.Sys.get_process_title
Base.ignorestatus
Base.detach
Base.Cmd
Base.setenv
Base.withenv
Base.pipeline(::Any, ::Any, ::Any, ::Any...)
Base.pipeline(::Base.AbstractCmd)
Base.Libc.gethostname
Base.Libc.getpid
Base.Libc.time()
Base.time_ns
Base.@time
Base.@timev
Base.@timed
Base.@elapsed
Base.@allocated
Base.EnvDict
Base.ENV
Base.Sys.isunix
Base.Sys.isapple
Base.Sys.islinux
Base.Sys.isbsd
Base.Sys.iswindows
Base.Sys.windows_version
Base.@static</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.show(::Any)
Base.summary
Base.print
Base.println
Base.printstyled
Base.sprint
Base.showerror
Base.dump
Meta.@dump
Base.readline
Base.readuntil
Base.readlines
Base.eachline
Base.displaysize</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043214Z" creationid="hsugawa8651" creationdate="20181112T043214Z">
        <seg>Base.show(::Any)
Base.summary
Base.print
Base.println
Base.printstyled
Base.sprint
Base.showerror
Base.dump
Meta.@dump
Base.readline
Base.readuntil
Base.readlines
Base.eachline
Base.displaysize</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.similar</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022603Z" creationid="hsugawa8651" creationdate="20181116T022603Z">
        <seg>Base.similar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131307Z" creationid="hsugawa8651" creationdate="20181113T131307Z">
        <seg>Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083529Z" creationid="hsugawa8651" creationdate="20181113T083529Z">
        <seg>Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.sizeof(::Type)
Base.isconcretetype
Base.isbits
Base.isbitstype
Core.fieldtype
Base.fieldtypes
Base.fieldcount
Base.fieldoffset
Base.datatype_alignment
Base.datatype_haspadding
Base.datatype_pointerfree</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041856Z" creationid="hsugawa8651" creationdate="20181110T041856Z">
        <seg>Base.sizeof(::Type)
Base.isconcretetype
Base.isbits
Base.isbitstype
Core.fieldtype
Base.fieldtypes
Base.fieldcount
Base.fieldoffset
Base.datatype_alignment
Base.datatype_haspadding
Base.datatype_pointerfree</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.sort
Base.sortperm
Base.InsertionSort
Base.MergeSort
Base.QuickSort
Base.PartialQuickSort
Base.Sort.sortperm!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044931Z" creationid="hsugawa8651" creationdate="20181112T044931Z">
        <seg>Base.sort
Base.sortperm
Base.InsertionSort
Base.MergeSort
Base.QuickSort
Base.PartialQuickSort
Base.Sort.sortperm!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.sort!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150321Z" creationid="hsugawa8651" creationdate="20181117T150321Z">
        <seg>Base.sort!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.splice!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041921Z" creationid="hsugawa8651" creationdate="20181112T041921Z">
        <seg>Base.splice!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.stdout
Base.stderr
Base.stdin
Base.open
Base.IOBuffer
Base.take!(::Base.GenericIOBuffer)
Base.fdio
Base.flush
Base.close
Base.write
Base.read
Base.read!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043210Z" creationid="hsugawa8651" creationdate="20181112T043210Z">
        <seg>Base.stdout
Base.stderr
Base.stdin
Base.open
Base.IOBuffer
Base.take!(::Base.GenericIOBuffer)
Base.fdio
Base.flush
Base.close
Base.write
Base.read
Base.read!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.stride
Base.strides</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T033616Z" creationid="hsugawa8651" creationdate="20181110T033616Z">
        <seg>Base.stride
Base.strides</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.sum
Base.sum!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041638Z" creationid="hsugawa8651" creationdate="20181112T041638Z">
        <seg>Base.sum
Base.sum!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.supertype
Core.:(&lt;:)
Base.:(&gt;:)
Base.typejoin
Base.typeintersect
Base.promote_type
Base.promote_rule
Base.isdispatchtuple</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041843Z" creationid="hsugawa8651" creationdate="20181110T041843Z">
        <seg>Base.supertype
Core.:(&lt;:)
Base.:(&gt;:)
Base.typejoin
Base.typeintersect
Base.promote_type
Base.promote_rule
Base.isdispatchtuple</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.symdiff
Base.symdiff!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041824Z" creationid="hsugawa8651" creationdate="20181112T041824Z">
        <seg>Base.symdiff
Base.symdiff!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.typemin
Base.typemax
Base.floatmin
Base.floatmax
Base.maxintfloat
Base.eps(::Type{&lt;:AbstractFloat})
Base.eps(::AbstractFloat)
Base.instances</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041908Z" creationid="hsugawa8651" creationdate="20181110T041908Z">
        <seg>Base.typemin
Base.typemax
Base.floatmin
Base.floatmax
Base.maxintfloat
Base.eps(::Type{&lt;:AbstractFloat})
Base.eps(::AbstractFloat)
Base.instances</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.unsafe_convert(::Type{Ptr{T}}, A)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083438Z" creationid="hsugawa8651" creationdate="20181113T083438Z">
        <seg>Base.unsafe_convert(::Type{Ptr{T}}, A)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.unsafe_copyto!{T}(::Ptr{T}, ::Ptr{T}, ::Any)
Base.unsafe_copyto!{T}(::Array{T}, ::Any, ::Array{T}, ::Any, ::Any)
Base.copyto!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042026Z" creationid="hsugawa8651" creationdate="20181110T042026Z">
        <seg>Base.unsafe_copyto!{T}(::Ptr{T}, ::Ptr{T}, ::Any)
Base.unsafe_copyto!{T}(::Array{T}, ::Any, ::Array{T}, ::Any, ::Any)
Base.copyto!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.unsafe_read
Base.unsafe_write
Base.position
Base.seek
Base.seekstart
Base.seekend
Base.skip
Base.mark
Base.unmark
Base.reset
Base.ismarked
Base.eof
Base.isreadonly
Base.iswritable
Base.isreadable
Base.isopen
Base.Grisu.print_shortest
Base.fd
Base.redirect_stdout
Base.redirect_stdout(::Function, ::Any)
Base.redirect_stderr
Base.redirect_stderr(::Function, ::Any)
Base.redirect_stdin
Base.redirect_stdin(::Function, ::Any)
Base.readchomp
Base.truncate
Base.skipchars
Base.countlines
Base.PipeBuffer
Base.readavailable
Base.IOContext
Base.IOContext(::IO, ::Pair)
Base.IOContext(::IO, ::IOContext)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043212Z" creationid="hsugawa8651" creationdate="20181112T043212Z">
        <seg>Base.unsafe_read
Base.unsafe_write
Base.position
Base.seek
Base.seekstart
Base.seekend
Base.skip
Base.mark
Base.unmark
Base.reset
Base.ismarked
Base.eof
Base.isreadonly
Base.iswritable
Base.isreadable
Base.isopen
Base.Grisu.print_shortest
Base.fd
Base.redirect_stdout
Base.redirect_stdout(::Function, ::Any)
Base.redirect_stderr
Base.redirect_stderr(::Function, ::Any)
Base.redirect_stdin
Base.redirect_stdin(::Function, ::Any)
Base.readchomp
Base.truncate
Base.skipchars
Base.countlines
Base.PipeBuffer
Base.readavailable
Base.IOContext
Base.IOContext(::IO, ::Pair)
Base.IOContext(::IO, ::IOContext)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base.view
Base.@view
Base.@views
Base.parent
Base.parentindices
Base.selectdim
Base.reinterpret
Base.reshape
Base.dropdims
Base.vec</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020235Z" creationid="hsugawa8651" creationdate="20181116T020235Z">
        <seg>Base.view
Base.@view
Base.@views
Base.parent
Base.parentindices
Base.selectdim
Base.reinterpret
Base.reshape
Base.dropdims
Base.vec</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Functions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150346Z" creationid="hsugawa8651" creationdate="20181117T150346Z">
        <seg>基本関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C doesn't support multiple return values, often C functions will take pointers to data
that the function will modify.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151825Z" creationid="hsugawa8651" creationdate="20181117T151825Z">
        <seg>Cは複数の戻り値をサポートしていないため、しばしばC関数はデータのポインタを取得します。 関数が変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Julia’s compiler is different from the interpreters used
for languages like Python or R, you may find that Julia’s performance
is unintuitive at first.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081506Z" creationid="hsugawa8651" creationdate="20181118T081506Z">
        <seg>JuliaのコンパイラはPythonやRで使われるようなインタプリタとは異なるので、もしかしたら最初はその性能に気づかないかもしれません。 遅いと感じたら、何かを試す前に Performance Tips を参照することをお勧めします。 Juliaがどのように動作するかを理解すれば、C言語と同等の速さで動くコードを簡単に書くことができるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the lack of a central naming authority, a single project can quite possibly end up depending on different packages that have the same name.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152837Z" creationid="hsugawa8651" creationdate="20181117T152837Z">
        <seg>中央の名前付け権限がないため、同じ名前を持つパッケージによっては、単一のプロジェクトが終了する可能性が非常に高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the function generator is
run during inference, it must respect all of the limitations of that code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032221Z" creationid="hsugawa8651" creationdate="20181116T032221Z">
        <seg>関数ジェネレータは は、そのコードのすべての制限を尊重する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we worry about
calling &lt;x23/&gt;qsort&lt;x24/&gt; and passing arguments, we need to write a comparison function that works for some
arbitrary objects (which define &lt;x25/&gt;&lt;&lt;x26/&gt;):</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150530Z" creationid="hsugawa8651" creationdate="20181117T150530Z">
        <seg>心配する前に &lt;x23/&gt;qsort&lt;x24/&gt;を呼び出して引数を渡す必要があります。 任意のオブジェクト(&lt;x25/&gt;&lt;&lt;x26/&gt;を定義します):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behaves like a &lt;x1/&gt;Ptr{T}&lt;x2/&gt; that can manage its memory via the Julia GC.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134453Z" creationid="hsugawa8651" creationdate="20181117T134453Z">
        <seg>Julia GCを介してメモリを管理することができる&lt;x1/&gt;Ptr{T}&lt;x2/&gt;のように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BigFloats and BigInts</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044719Z" creationid="hsugawa8651" creationdate="20181112T044719Z">
        <seg>BigFloats and BigInts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary (or unary) operators like &lt;x1/&gt;.+&lt;x2/&gt; are handled with the same mechanism:
they are equivalent to &lt;x3/&gt;broadcast&lt;x4/&gt; calls and are fused with other nested "dot" calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T105913Z" creationid="hsugawa8651" creationdate="20181112T105913Z">
        <seg>&lt;x1/&gt;.+&lt;x2/&gt;のようなバイナリ演算子(または単項演算子)は、同じメカニズムで処理されます。 これらは、&lt;x3/&gt;ブロードキャスト&lt;x4/&gt;コールと同等であり、他のネストされた"ドット"コールと融合されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary and octal literals are also supported:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225352Z" creationid="hsugawa8651" creationdate="20181109T225352Z">
        <seg>バイナリリテラルと8進数リテラルもサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary arithmetic -- &lt;x1/&gt;-&lt;x2/&gt;, &lt;x3/&gt;+&lt;x4/&gt;, &lt;x5/&gt;*&lt;x6/&gt;, &lt;x7/&gt;/&lt;x8/&gt;, &lt;x9/&gt;\&lt;x10/&gt;, &lt;x11/&gt;^&lt;x12/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161215Z" creationid="hsugawa8651" creationdate="20181114T161215Z">
        <seg>バイナリ算術-&lt;x1/&gt;-&lt;x2/&gt;,&lt;x3/&gt;+&lt;x4/&gt;,&lt;x5/&gt;*&lt;x6/&gt;,&lt;x7/&gt;/&lt;x8/&gt;,&lt;x9/&gt;&lt;x12/&gt;,&lt;x11/&gt;^&lt;x12/&gt;&lt;x12/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary, octal, and hexadecimal literals may be signed by a &lt;x1/&gt;-&lt;x2/&gt; immediately preceding the
unsigned literal.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225514Z" creationid="hsugawa8651" creationdate="20181109T225514Z">
        <seg>バイナリ、8進数、および16進数のリテラルは 署名されていないリテラル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BitSet&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134320Z" creationid="hsugawa8651" creationdate="20181117T134320Z">
        <seg>BitSet&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BitVector&lt;x1/&gt; (a.k.a.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043132Z" creationid="hsugawa8651" creationdate="20181112T043132Z">
        <seg>BitVector&lt;x1/&gt; (a.k.a.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitshifts</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030823Z" creationid="hsugawa8651" creationdate="20181114T030823Z">
        <seg>Bitshifts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean operations &lt;x1/&gt;without&lt;x2/&gt; short-circuit evaluation can be done with the bitwise boolean operators
introduced in &lt;x3/&gt;Mathematical Operations and Elementary Functions&lt;x4/&gt;: &lt;x5/&gt;&amp;&lt;x6/&gt; and &lt;x7/&gt;|&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230550Z" creationid="hsugawa8651" creationdate="20181109T230550Z">
        <seg>&lt;x2/&gt;短絡評価なしのブール演算&lt;x1/&gt;は、ビット単位のブール演算子で実行できます。 &lt;x3/&gt;演算と基本関数&lt;x4/&gt;:&lt;x5/&gt;&amp;&lt;x6/&gt;&lt;x6/&gt;&lt;x8/&gt;と&lt;x6/&gt;&lt;x8/&gt;で導入されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both &lt;x19/&gt;&amp;&amp;&lt;x20/&gt; and &lt;x21/&gt;||&lt;x22/&gt; associate to the right, but &lt;x23/&gt;&amp;&amp;&lt;x24/&gt; has higher precedence than &lt;x25/&gt;||&lt;x26/&gt; does.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230244Z" creationid="hsugawa8651" creationdate="20181109T230244Z">
        <seg>&lt;x19/&gt;&amp;&amp;&lt;x20/&gt;と&lt;X21/&gt;&lt;x22/&gt;の両方が右側に関連付けられますが、&lt;x23/&gt;&amp;&amp;&lt;x24/&gt;は&lt;x25/&gt;&lt;x26/&gt;よりも優先順位が高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both expressions are interpreted as function application: any expression that is not a numeric
literal, when immediately followed by a parenthetical, is interpreted as a function applied to
the values in parentheses (see &lt;x1/&gt;Functions&lt;x2/&gt; for more about functions).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111859Z" creationid="hsugawa8651" creationdate="20181112T111859Z">
        <seg>両方の式は、関数アプリケーションとして解釈されます。数値ではない任意の式です。 リテラルは、直後に括弧で囲まれた後に、関数として解釈されます。 括弧内の値(関数の関数については&lt;x1/&gt;関数を参照&lt;x2/&gt;を参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these cases throw a &lt;x5/&gt;`DivideError`&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110529Z" creationid="hsugawa8651" creationdate="20181112T110529Z">
        <seg>これらの場合は両方とも、&lt;x6/&gt;「DivideError」&lt;x6/&gt;をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both these implementations, although different, do essentially the same thing: a runtime loop
over the dimensions of the array, collecting the offset in each dimension into the final index.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032309Z" creationid="hsugawa8651" creationdate="20181116T032252Z">
        <seg>これらの実装は両方とも異なるが、基本的には、ランタイム・ループと同じものです。 配列の寸法を超えて、各次元のオフセットを最終インデックスに収集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Brief description</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094355Z" creationid="hsugawa8651" creationdate="20181118T094355Z">
        <seg>簡単な説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Brief description&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094059Z" creationid="hsugawa8651" creationdate="20181118T094059Z">
        <seg>簡単な説明&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast Styles</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094634Z" creationid="hsugawa8651" creationdate="20181118T094634Z">
        <seg>ブロードキャストスタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast and vectorization</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020223Z" creationid="hsugawa8651" creationdate="20181116T020223Z">
        <seg>Broadcast and vectorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast calls this single answer a "style." Every broadcastable object
each has its own preferred style, and a promotion-like system is used to combine these
styles into a single answer — the "destination style".</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094639Z" creationid="hsugawa8651" creationdate="20181118T094639Z">
        <seg>ブロードキャストコールは、この単一の応答を「スタイル」と呼びます。すべてのブロードキャスト可能なオブジェクト それぞれが独自の優先スタイルを持ち、システムのようなプロモーションを使ってこれらを結合します。 スタイルは1つの応答-「destination style」になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast must take all the varied
types of its arguments and collapse them down to just one output array and one
implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131110Z" creationid="hsugawa8651" creationdate="20181113T131110Z">
        <seg>ブロードキャストは様々な変化をもたらす 引数の種類と集約を1つの出力配列と1つの出力配列に集約します。 実装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast.flatten&lt;x1/&gt; recomputes the potentially nested operation into a single
function and flat list of arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131722Z" creationid="hsugawa8651" creationdate="20181113T131722Z">
        <seg>broadcast.flatflating&lt;x1/&gt;は、ネストされたオペレーションを1つのファイルに再計算します。 引数の関数とフラット・リスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a
BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a
BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =
    typeof(a)(_max(Val(M),Val(N)))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131814Z" creationid="hsugawa8651" creationdate="20181113T131814Z">
        <seg>BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a
BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a
BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =
    typeof(a)(_max(Val(M),Val(N)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcasting</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150447Z" creationid="hsugawa8651" creationdate="20181117T150447Z">
        <seg>放送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcasting&lt;x1/&gt; is triggered by an explicit call to &lt;x2/&gt;broadcast&lt;x3/&gt; or &lt;x4/&gt;broadcast!&lt;x5/&gt;, or implicitly by
"dot" operations like &lt;x6/&gt;A .+ b&lt;x7/&gt; or &lt;x8/&gt;f.(x, y)&lt;x9/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131014Z" creationid="hsugawa8651" creationdate="20181113T131014Z">
        <seg>ブロードキャスト&lt;x1/&gt;は、&lt;x2/&gt;ブロードキャスト&lt;x3/&gt;ブロードキャスト!&lt;x4/&gt;ブロードキャスト!&lt;x5/&gt;への明示的な呼び出しによってトリガされます。 &lt;x6/&gt;A.+b&lt;x7/&gt;または&lt;x8/&gt;f.(x, y)&lt;x9/&gt;のような「ドット」操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in representations of such values are called numeric primitives, while representations of
integers and floating-point numbers as immediate values in code are known as numeric literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225037Z" creationid="hsugawa8651" creationdate="20181109T225037Z">
        <seg>このような値の組み込み表現は、数値プリミティブと呼ばれますが、表現は次のようになります。 整数と浮動小数点数は、コードの即時値として知られており、数値リテラルと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But here is a thing you should pay attention to: suppose &lt;x1/&gt;x&lt;x2/&gt; is bound to an object of type &lt;x3/&gt;Array&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025034Z" creationid="hsugawa8651" creationdate="20181110T025034Z">
        <seg>しかし、ここで注意すべき点は、&lt;x1/&gt;x&lt;x2/&gt;が&lt;x3/&gt;配列&lt;x4/&gt;型のオブジェクトにバインドされていると仮定することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But how does one construct the first instance when no instance exists to provide as a valid value
for its &lt;x1/&gt;obj&lt;x2/&gt; field?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155851Z" creationid="hsugawa8651" creationdate="20181117T155851Z">
        <seg>しかし、有効な値として提供するインスタンスが存在しない場合は、最初のインスタンスを構築する方法はどうすればよいのですか。 &lt;x1/&gt;obj&lt;x2/&gt;フィールドに対して。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But, &lt;x2/&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151243Z" creationid="hsugawa8651" creationdate="20181117T151243Z">
        <seg>しかし、&lt;T2/&gt;g(x::T)は、{T}=ccall(:ノヴァリド、T、(T,)、x)&lt;x3/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By
default, this is the identity function for all &lt;x7/&gt;AbstractArray&lt;x8/&gt;s and &lt;x9/&gt;Number&lt;x10/&gt;s — they already
support &lt;x11/&gt;axes&lt;x12/&gt; and indexing.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131041Z" creationid="hsugawa8651" creationdate="20181113T131041Z">
        <seg>by デフォルトでは、すべての&lt;x7/&gt;AbstractArray&lt;x8/&gt;と&lt;x9/&gt;の番号&lt;x10/&gt;の識別関数です。 &lt;x11/&gt;軸のサポート&lt;x12/&gt;とインデックス作成をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, function names ending with an exclamation point (&lt;x1/&gt;!&lt;x2/&gt;) modify their arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041720Z" creationid="hsugawa8651" creationdate="20181110T041720Z">
        <seg>慣例によっては、感嘆符(&lt;x1/&gt;!&lt;x2/&gt;)で終わる関数名は、引数を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default this includes:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155509Z" creationid="hsugawa8651" creationdate="20181109T155509Z">
        <seg>デフォルトでは、次の内容が含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Fortran compilers &lt;x1/&gt;generate mangled
names&lt;x2/&gt; (for example,
converting function names to lowercase or uppercase, often appending an
underscore), and so to call a Fortran function via &lt;x3/&gt;`ccall`&lt;x4/&gt; you must pass
the mangled identifier corresponding to the rule followed by your Fortran
compiler.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223808Z" creationid="hsugawa8651" creationdate="20181109T223808Z">
        <seg>デフォルトでは、Fortranコンパイラ&lt;x1/&gt;はmangledを生成します。 名前&lt;x2/&gt;(例: 関数名を小文字または大文字に変換し、通常は アンダースコア)は、Fortran関数を&lt;x3/&gt;`ccall`&lt;x4/&gt;経由で呼び出す必要があります。 ルールに従うルールに従って、ルールに対応するマクロ識別子を指定します。 コンパイラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Fortran compilers &lt;x1/&gt;generate mangled
names&lt;x2/&gt; (for example,
converting function names to lowercase or uppercase, often appending an
underscore), and so to call a Fortran function via &lt;x3/&gt;`ccall`&lt;x4/&gt; you must pass
the mangled identifier corresponding to the rule followed by your Fortran
compiler.  Also, when calling a Fortran function, all inputs must be passed as
pointers to allocated values on the heap or stack. This applies not only to
arrays and other mutable objects which are normally heap-allocated, but also to
scalar values such as integers and floats which are normally stack-allocated and
commonly passed in registers when using C or Julia calling conventions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133755Z" creationid="hsugawa8651" creationdate="20181117T133755Z">
        <seg>デフォルトでは、Fortranコンパイラ&lt;x1/&gt;はmangledを生成します。 名前&lt;x2/&gt;(例: 関数名を小文字または大文字に変換し、通常は アンダースコア)は、Fortran関数を&lt;x3/&gt;`ccall`&lt;x4/&gt;経由で呼び出す必要があります。 ルールに従うルールに従って、ルールに対応するマクロ識別子を指定します。 コンパイラー。また、Fortran関数を呼び出す場合は、すべての入力が必要です。 ヒープまたはスタック上の割り当てられた値へのポインタです。これは 通常はヒープ割り当てされた配列やその他のmutableオブジェクトですが 通常スタック割り当てされた整数や浮動小数点のようなスカラー値 一般的には、CまたはJuliaの呼び出し規約を使用するときにレジスタで渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Julia picks reasonable algorithms and sorts in standard ascending order:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063711Z" creationid="hsugawa8651" creationdate="20181114T063711Z">
        <seg>デフォルトでは、Juliaは標準的な昇順で妥当なアルゴリズムとソートを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By definition, &lt;x1/&gt;eps(1.0)&lt;x2/&gt; is the same as &lt;x3/&gt;eps(Float64)&lt;x4/&gt; since &lt;x5/&gt;1.0&lt;x6/&gt; is
a 64-bit floating-point value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111220Z" creationid="hsugawa8651" creationdate="20181112T111220Z">
        <seg>定義では&lt;x1/&gt;eps(1.0)&lt;x2/&gt;は&lt;x3/&gt;(Float64)&lt;x4/&gt;と同じであり、&lt;x5/&gt;は&lt;x5/&gt;1.0&lt;x6/&gt;である。 64ビットの浮動小数点値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By extending
the &lt;x5/&gt;`eltype`&lt;x6/&gt; method, we can give that information to Julia and help it make more specialized
code in the more complicated methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094302Z" creationid="hsugawa8651" creationdate="20181118T094302Z">
        <seg>&lt;x5/&gt;`eltype`&lt;x6/&gt; の方法を拡張することにより、Julia に情報を提供し、より専門的なものにする手助けをすることができます。 より複雑なメソッドのコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By extending a few specific methods to work for a custom type, objects of that type not only
receive those functionalities, but they are also able to be used in other methods that are written
to generically build upon those behaviors.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112041Z" creationid="hsugawa8651" creationdate="20181112T112041Z">
        <seg>カスタムタイプで作業するためのいくつかの特定の方法を拡張することによって、そのタイプのオブジェクトは、以下のように表示されます。 これらの機能を受け取りますが、他の方法で書かれることもあります。 一般的に構築されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By putting the &lt;x12/&gt;`@views`&lt;x13/&gt; macro in front of an expression or
block of code, any &lt;x14/&gt;array[...]&lt;x15/&gt; slice in that expression will be converted to
create a &lt;x16/&gt;SubArray&lt;x17/&gt; view instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160443Z" creationid="hsugawa8651" creationdate="20181109T160443Z">
        <seg>&lt;x12/&gt;`@views'&lt;x13/&gt;マクロを式の前に置くか コードのブロック、任意の&lt;x14/&gt;配列[.]&lt;x15/&gt;スライスは、その式の中に変換されます。 代わりに&lt;x16/&gt;サブアレイを作成&lt;x17/&gt;ビューを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By the &lt;x3/&gt;IEEE 754 standard&lt;x4/&gt;,
these floating-point values are the results of certain arithmetic operations:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110847Z" creationid="hsugawa8651" creationdate="20181112T110847Z">
        <seg>&lt;x3/&gt;IEEE754規格の&lt;x4/&gt;では これらの浮動小数点値は、特定の算術演算の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bypassing default machinery&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083554Z" creationid="hsugawa8651" creationdate="20181113T083554Z">
        <seg>デフォルトのマシンをバイパスする&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C &lt;x1/&gt;MUST NOT&lt;x2/&gt; modify the memory returned via &lt;x3/&gt;Ref{T}&lt;x4/&gt; if &lt;x5/&gt;T&lt;x6/&gt; is an &lt;x7/&gt;isbits&lt;x8/&gt; type</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151816Z" creationid="hsugawa8651" creationdate="20181117T151816Z">
        <seg>&lt;x1/&gt;は、&lt;x5/&gt;T&lt;x6/&gt;が&lt;x7/&gt;イスビトス&lt;x×&gt;&lt;x8/&gt;で返されるメモリを変更してはならない。&lt;x4/&gt;&lt;x6/&gt;は、&lt;x7/&gt;の場合である。&lt;x8/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C Interface</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042024Z" creationid="hsugawa8651" creationdate="20181110T042024Z">
        <seg>C Interface</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C Standard Library</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043418Z" creationid="hsugawa8651" creationdate="20181112T043418Z">
        <seg>C Standard Library</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C name</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150848Z" creationid="hsugawa8651" creationdate="20181117T150848Z">
        <seg>C名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call C functions directly (no wrappers or special APIs needed)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082910Z" creationid="hsugawa8651" creationdate="20181118T082910Z">
        <seg>ラッパーや特別なAPIを必要としない、Cの関数の直接の呼び出し
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Callees must make explicit copies to ensure that they don't modify inputs that
they don't intend to change.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154219Z" creationid="hsugawa8651" creationdate="20181109T154219Z">
        <seg>呼び出し側は、入力を変更しないことを確実にするために、明示的なコピーを作成する必要があります。 変化するつもりはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling C and Fortran Code</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133658Z" creationid="hsugawa8651" creationdate="20181117T133658Z">
        <seg>CとFortranのコードを呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling Convention</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152415Z" creationid="hsugawa8651" creationdate="20181117T152415Z">
        <seg>通話条約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling any function that is defined after the body of the generated function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032235Z" creationid="hsugawa8651" creationdate="20181116T032235Z">
        <seg>生成された関数のボディの後に定義された関数を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134559Z" creationid="hsugawa8651" creationdate="20181117T134559Z">
        <seg>Calls</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Can I use &lt;x1/&gt;using&lt;x2/&gt; or &lt;x3/&gt;import&lt;x4/&gt; inside a function?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025127Z" creationid="hsugawa8651" creationdate="20181110T025127Z">
        <seg>関数の中で&lt;x2/&gt;または&lt;x3/&gt;インポート&lt;x4/&gt;を使用して、&lt;x1/&gt;を使用することはできますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Candidates:
  g(x, y::Float64) in Main at none:1
  g(x::Float64, y) in Main at none:1
Possible fix, define
  g(::Float64, ::Float64)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054004Z" creationid="hsugawa8651" creationdate="20181116T054004Z">
        <seg>Candidates:
  g(x, y::Float64) in Main at none:1
  g(x::Float64, y) in Main at none:1
Possible fix, define
  g(::Float64, ::Float64)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Captured variables can present performance challenges; see
&lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref man-performance-tips).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160702Z" creationid="hsugawa8651" creationdate="20181114T160702Z">
        <seg>キャプチャされた変数はパフォーマンス上の問題を提示することがあります。 &lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref manのパフォーマンス・ヒント)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cartesian indices</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135012Z" creationid="hsugawa8651" creationdate="20181117T135012Z">
        <seg>デカルト指数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chained comparisons use the
&lt;x1/&gt;&amp;&amp;&lt;x2/&gt; operator for scalar comparisons, and the &lt;x3/&gt;`&amp;`&lt;x4/&gt; operator for elementwise comparisons,
which allows them to work on arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030720Z" creationid="hsugawa8651" creationdate="20181114T030720Z">
        <seg>チェーン化された比較は スカラー比較のための&lt;x1/&gt;&amp;&amp;&lt;x2/&gt;演算子と、エレメント比較のための&lt;x3/&gt;&amp;"&lt;x4/&gt;演算子 これにより、アレイ上での作業が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining comparisons is often quite convenient in numerical code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030717Z" creationid="hsugawa8651" creationdate="20181114T030717Z">
        <seg>連鎖比較は、数値コードにおいて非常に便利であることが多い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change something in "mynewcode.jl"
include("mynewcode.jl")              &lt;x3/&gt; reload the module
obj1 = MyModule.ObjConstructor(a, b) &lt;x4/&gt; old objects are no longer valid, must reconstruct
obj2 = MyModule.somefunction(obj1)   &lt;x5/&gt; this time it worked!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024757Z" creationid="hsugawa8651" creationdate="20181110T024757Z">
        <seg>Change something in "mynewcode.jl"
include("mynewcode.jl")              &lt;x3/&gt; reload the module
obj1 = MyModule.ObjConstructor(a, b) &lt;x4/&gt; old objects are no longer valid, must reconstruct
obj2 = MyModule.somefunction(obj1)   &lt;x5/&gt; this time it worked!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia&gt; newfun()
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054054Z" creationid="hsugawa8651" creationdate="20181116T054054Z">
        <seg>Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia&gt; newfun()
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code Loading</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152653Z" creationid="hsugawa8651" creationdate="20181117T152653Z">
        <seg>コードの読み込み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code inclusion is quite straightforward: it simply parses and evaluates a source file in the context of the caller.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152747Z" creationid="hsugawa8651" creationdate="20181117T152747Z">
        <seg>コードインクルージョンは非常に単純です。呼び出し元のコンテキストでソースファイルを解析し、評価するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code inclusion:&lt;x1/&gt; e.g. &lt;x2/&gt;include("source.jl")&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152657Z" creationid="hsugawa8651" creationdate="20181117T152657Z">
        <seg>コードインクルージョン:&lt;x1/&gt;例えば&lt;x2/&gt;は("source.jl")&lt;x3/&gt;を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections and Data Structures</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150130Z" creationid="hsugawa8651" creationdate="20181117T150130Z">
        <seg>コレクションとデータ構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining dot operators with numeric literals can be ambiguous.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132640Z" creationid="hsugawa8651" creationdate="20181113T132640Z">
        <seg>ドット演算子と数値リテラルを組み合わせることは、あいまいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparison -- &lt;x1/&gt;==&lt;x2/&gt;, &lt;x3/&gt;!=&lt;x4/&gt;, &lt;x5/&gt;≈&lt;x6/&gt; (&lt;x7/&gt;`isapprox`&lt;x8/&gt;), &lt;x9/&gt;≉&lt;x10/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161218Z" creationid="hsugawa8651" creationdate="20181114T161218Z">
        <seg>比較-&lt;x1/&gt;==&lt;x2/&gt;,&lt;x3/&gt;!=&lt;x4/&gt;,&lt;x5/&gt;≒&lt;x6/&gt;(&lt;x7/&gt;'&lt;x6/&gt;(&lt;x7/&gt;'イサッポロス&lt;x8/&gt;)&lt;x9/&gt;≉&lt;x10/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ComplexF32&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134419Z" creationid="hsugawa8651" creationdate="20181117T134419Z">
        <seg>ComplexF32&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ComplexF64&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134428Z" creationid="hsugawa8651" creationdate="20181117T134428Z">
        <seg>ComplexF64&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ComplexF64&lt;x1/&gt; (&lt;x2/&gt;isbits&lt;x3/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150720Z" creationid="hsugawa8651" creationdate="20181117T150720Z">
        <seg>ComplexF64&lt;x1/&gt; (&lt;x2/&gt;isbits&lt;x3/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex{Float64}(x)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021149Z" creationid="hsugawa8651" creationdate="20181116T021149Z">
        <seg>Complex{Float64}(x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composite types, aka &lt;x1/&gt;struct&lt;x2/&gt; in C or &lt;x3/&gt;TYPE&lt;x4/&gt; in Fortran90 (or &lt;x5/&gt;STRUCTURE&lt;x6/&gt; / &lt;x7/&gt;RECORD&lt;x8/&gt; in some variants
of F77), can be mirrored in Julia by creating a &lt;x9/&gt;struct&lt;x10/&gt; definition with the same
field layout.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151135Z" creationid="hsugawa8651" creationdate="20181117T151135Z">
        <seg>Fortran90(或いは、いくつかの変形例においては、&lt;x1/&gt;構造体&lt;x2/&gt;in Cまたは&lt;x3/&gt;TYPE&lt;x6/&gt;&lt;x6/&gt;/&lt;x6/&gt;RECORD&lt;x8/&gt;(ある種の変数ではRECORD&lt;x8/&gt;) は、同じ名前で&lt;x9/&gt;構造体&lt;x10/&gt;定義を作成することによって、ジュリアにミラーリングすることができます。 フィールドのレイアウトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehension syntax is
similar to set construction notation in mathematics:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154804Z" creationid="hsugawa8651" creationdate="20181109T154804Z">
        <seg>理解の構文は次のとおりです。 数学で設定された建設表記法に似ています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150416Z" creationid="hsugawa8651" creationdate="20181117T150416Z">
        <seg>包含</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensions can also be written without the enclosing square brackets, producing an object
known as a generator.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154923Z" creationid="hsugawa8651" creationdate="20181109T154923Z">
        <seg>包含は、囲まれた角括弧なしで書くこともでき、オブジェクトを生成することができます。 ジェネレータと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensions can also be written without the enclosing square brackets, producing an object
known as a generator. This object can be iterated to produce values on demand, instead of allocating
an array and storing them in advance (see &lt;x1/&gt;Iteration&lt;x2/&gt;). For example, the following expression
sums a series without allocating memory:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134812Z" creationid="hsugawa8651" creationdate="20181117T134812Z">
        <seg>包含は、囲まれた角括弧なしで書くこともでき、オブジェクトを生成することができます。 ジェネレータと呼ばれます。このオブジェクトは、必要に応じて反復処理を行うことができます。必要に応じて値を割り当てることはできません。 配列とそれを事前に格納します(&lt;x1/&gt;Iteration&lt;x2/&gt;を参照)。たとえば、次の式を指定します。 は、メモリを割り当てずに連続した値を加算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensions provide a general and powerful way to construct arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150418Z" creationid="hsugawa8651" creationdate="20181117T150418Z">
        <seg>内包は、配列を構築するための一般的で強力な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is
similar to set construction notation in mathematics:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134740Z" creationid="hsugawa8651" creationdate="20181117T134740Z">
        <seg>インクルージョンは、配列を構築するための一般的で強力な方法です。理解の構文は次のとおりです。 数学で設定された建設表記法に似ています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concatenation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134534Z" creationid="hsugawa8651" creationdate="20181117T134534Z">
        <seg>連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concatenation syntax can similarly be prefixed with a type to specify the element type of the
result.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154707Z" creationid="hsugawa8651" creationdate="20181109T154707Z">
        <seg>連結構文には、同じように 結果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concrete number types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044710Z" creationid="hsugawa8651" creationdate="20181112T044710Z">
        <seg>Concrete number types</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concrete types should also typically provide a &lt;x16/&gt;`similar(A,T=eltype(A),dims=size(A))`&lt;x17/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160350Z" creationid="hsugawa8651" creationdate="20181109T160350Z">
        <seg>具体的には、典型的には、&lt;x16/&gt;'類似の(A,T=エルテープ(A),dims=size(A))`&lt;x17/&gt;を提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the
value of a boolean expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225833Z" creationid="hsugawa8651" creationdate="20181109T225833Z">
        <seg>条件付き評価は、コードの一部を評価することができます。 ブール式の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, specializing on &lt;x5/&gt;DestType&lt;x6/&gt; has lower precedence than
methods that specialize on &lt;x7/&gt;DestStyle&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131705Z" creationid="hsugawa8651" creationdate="20181113T131705Z">
        <seg>したがって、&lt;x5/&gt;DestType&lt;x6/&gt;に特化することは、以下の優先順位よりも優先順位が低くなります。 &lt;x7/&gt;DestStyle&lt;x8/&gt;に特化した方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following example manifest file for &lt;x4/&gt;App&lt;x5/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015906Z" creationid="hsugawa8651" creationdate="20181116T015906Z">
        <seg>Consider the following example manifest file for &lt;x4/&gt;App&lt;x5/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following recursive type declaration:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155842Z" creationid="hsugawa8651" creationdate="20181117T155842Z">
        <seg>次の再帰タイプ宣言を考慮してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider these examples of this syntax:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154648Z" creationid="hsugawa8651" creationdate="20181109T154648Z">
        <seg>この構文の例を次に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considered alone, this may seem relatively trivial; &lt;x1/&gt;CartesianIndex&lt;x2/&gt; simply
gathers multiple integers together into one object that represents a single
multidimensional index.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155644Z" creationid="hsugawa8651" creationdate="20181109T155644Z">
        <seg>単独で考慮すると、これは比較的簡単であるように思えるかもしれません。&lt;x1/&gt;CartesianIndex&lt;x2/&gt;は単純です。 複数の整数を1つのオブジェクトに集約して1つのオブジェクトを作成します。 多次元インデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considered alone, this may seem relatively trivial; &lt;x1/&gt;CartesianIndex&lt;x2/&gt; simply
gathers multiple integers together into one object that represents a single
multidimensional index. When combined with other indexing forms and iterators
that yield &lt;x3/&gt;CartesianIndex&lt;x4/&gt;es, however, this can produce very elegant
and efficient code. See &lt;x5/&gt;Iteration&lt;x6/&gt; below, and for some more advanced
examples, see &lt;x7/&gt;this blog post on multidimensional algorithms and
iteration&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135021Z" creationid="hsugawa8651" creationdate="20181117T135021Z">
        <seg>単独で考慮すると、これは比較的簡単であるように思えるかもしれません。&lt;x1/&gt;CartesianIndex&lt;x2/&gt;は単純です。 複数の整数を1つのオブジェクトに集約して1つのオブジェクトを作成します。 多次元インデックス。他のインデックス作成フォームおよびイテレータと組み合わせて使用します。 しかし、それは&lt;x3/&gt;CartesianIndex&lt;x4/&gt;の収量をもたらすが、これは非常にエレガントなものである。 そして、効率的なコードがあります。&lt;x5/&gt;Iteration&lt;x6/&gt;&lt;x6/&gt;を参照してください。 例を参照してください。このブログ記事は、多次元アルゴリズムに関するこのブログ記事を参照してください。 繰り返し&lt;x8/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Construction and Initialization</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150402Z" creationid="hsugawa8651" creationdate="20181117T150402Z">
        <seg>建設と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructors and Types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150137Z" creationid="hsugawa8651" creationdate="20181117T150137Z">
        <seg>コンストラクタとタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructors exist to create these types from primitive numerical types, and &lt;x1/&gt;`parse`&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111546Z" creationid="hsugawa8651" creationdate="20181112T111546Z">
        <seg>コンストラクタはプリミティブな数値型からこれらのタイプを作成するために存在します。&lt;x1/&gt;`parse'&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control whether inlining is permitted, including overriding &lt;x1/&gt;@inline&lt;x2/&gt; declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224750Z" creationid="hsugawa8651" creationdate="20181109T224750Z">
        <seg>&lt;x1/&gt;@inline&lt;x2/&gt;宣言の上書きを含め、インライン化が許可されているかどうかを制御する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convert &lt;x1/&gt;x&lt;x2/&gt; to an object that has &lt;x3/&gt;axes&lt;x4/&gt; and supports indexing</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083558Z" creationid="hsugawa8651" creationdate="20181113T083558Z">
        <seg>&lt;x1/&gt;x&lt;x2/&gt;を&lt;x3/&gt;軸を持つオブジェクトに変換して、インデックスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting
to a &lt;x2/&gt;Cstring&lt;x3/&gt; as part of the &lt;x4/&gt;`ccall`&lt;x5/&gt; checks for contained NUL bytes and could therefore
throw a conversion error.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150522Z" creationid="hsugawa8651" creationdate="20181117T150522Z">
        <seg>変換する &lt;x4/&gt;Cstring&lt;x3/&gt;は、含まれるNULバイトを&lt;x4/&gt;'ccall&lt;x5/&gt;チェックの一部として&lt;x2/&gt;にします。したがって 変換エラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting a linear index to multiple indexing subscripts is typically very expensive, so this
provides a traits-based mechanism to enable efficient generic code for all array types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022812Z" creationid="hsugawa8651" creationdate="20181113T022812Z">
        <seg>リニアインデックスを複数のインデックス添字に変換することは、一般的に非常に高価です。したがって、次のようになります。 は、すべての配列タイプに対して効率的な汎用コードを有効にするための属性ベースのメカニズムを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.:(===)
Core.isa
Base.isequal
Base.isless
Base.ifelse
Core.typeassert
Core.typeof
Core.tuple
Base.ntuple
Base.objectid
Base.hash
Base.finalizer
Base.finalize
Base.copy
Base.deepcopy
Base.getproperty
Base.setproperty!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041822Z" creationid="hsugawa8651" creationdate="20181110T041822Z">
        <seg>Core.:(===)
Core.isa
Base.isequal
Base.isless
Base.ifelse
Core.typeassert
Core.typeof
Core.tuple
Base.ntuple
Base.objectid
Base.hash
Base.finalizer
Base.finalize
Base.copy
Base.deepcopy
Base.getproperty
Base.setproperty!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.AbstractArray
Base.AbstractVector
Base.AbstractMatrix
Base.AbstractVecOrMat
Core.Array
Core.Array(::UndefInitializer, ::Any)
Core.Array(::Nothing, ::Any)
Core.Array(::Missing, ::Any)
Core.UndefInitializer
Core.undef
Base.Vector
Base.Vector(::UndefInitializer, ::Any)
Base.Vector(::Nothing, ::Any)
Base.Vector(::Missing, ::Any)
Base.Matrix
Base.Matrix(::UndefInitializer, ::Any, ::Any)
Base.Matrix(::Nothing, ::Any, ::Any)
Base.Matrix(::Missing, ::Any, ::Any)
Base.VecOrMat
Core.DenseArray
Base.DenseVector
Base.DenseMatrix
Base.DenseVecOrMat
Base.StridedArray
Base.StridedVector
Base.StridedMatrix
Base.StridedVecOrMat
Base.getindex(::Type, ::Any...)
Base.zeros
Base.ones
Base.BitArray
Base.BitArray(::UndefInitializer, ::Integer...)
Base.BitArray(::Any)
Base.trues
Base.falses
Base.fill
Base.fill!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020217Z" creationid="hsugawa8651" creationdate="20181116T020217Z">
        <seg>Core.AbstractArray
Base.AbstractVector
Base.AbstractMatrix
Base.AbstractVecOrMat
Core.Array
Core.Array(::UndefInitializer, ::Any)
Core.Array(::Nothing, ::Any)
Core.Array(::Missing, ::Any)
Core.UndefInitializer
Core.undef
Base.Vector
Base.Vector(::UndefInitializer, ::Any)
Base.Vector(::Nothing, ::Any)
Base.Vector(::Missing, ::Any)
Base.Matrix
Base.Matrix(::UndefInitializer, ::Any, ::Any)
Base.Matrix(::Nothing, ::Any, ::Any)
Base.Matrix(::Missing, ::Any, ::Any)
Base.VecOrMat
Core.DenseArray
Base.DenseVector
Base.DenseMatrix
Base.DenseVecOrMat
Base.StridedArray
Base.StridedVector
Base.StridedMatrix
Base.StridedVecOrMat
Base.getindex(::Type, ::Any...)
Base.zeros
Base.ones
Base.BitArray
Base.BitArray(::UndefInitializer, ::Integer...)
Base.BitArray(::Any)
Base.trues
Base.falses
Base.fill
Base.fill!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.AbstractChar
Core.Char
Base.codepoint
Base.length(::AbstractString)
Base.sizeof(::AbstractString)
Base.:*(::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...)
Base.:^(::AbstractString, ::Integer)
Base.string
Base.repeat(::AbstractString, ::Integer)
Base.repeat(::AbstractChar, ::Integer)
Base.repr(::Any)
Core.String(::AbstractString)
Base.SubString
Base.transcode
Base.unsafe_string
Base.ncodeunits(::AbstractString)
Base.codeunit
Base.codeunits
Base.ascii
Base.@r_str
Base.SubstitutionString
Base.@s_str
Base.@raw_str
Base.Docs.@html_str
Base.Docs.@text_str
Base.isvalid(::Any)
Base.isvalid(::Any, ::Any)
Base.isvalid(::AbstractString, ::Integer)
Base.match
Base.eachmatch
Base.isless(::AbstractString, ::AbstractString)
Base.:(==)(::AbstractString, ::AbstractString)
Base.cmp(::AbstractString, ::AbstractString)
Base.lpad
Base.rpad
Base.findfirst(::AbstractString, ::AbstractString)
Base.findnext(::AbstractString, ::AbstractString, ::Integer)
Base.findlast(::AbstractString, ::AbstractString)
Base.findprev(::AbstractString, ::AbstractString, ::Integer)
Base.occursin
Base.reverse(::Union{String,SubString{String}})
Base.replace(s::AbstractString, ::Pair)
Base.split
Base.rsplit
Base.strip
Base.lstrip
Base.rstrip
Base.startswith
Base.endswith
Base.first(::AbstractString, ::Integer)
Base.last(::AbstractString, ::Integer)
Base.uppercase
Base.lowercase
Base.titlecase
Base.uppercasefirst
Base.lowercasefirst
Base.join
Base.chop
Base.chomp
Base.thisind
Base.nextind
Base.prevind
Base.textwidth
Base.isascii
Base.iscntrl
Base.isdigit
Base.isletter
Base.islowercase
Base.isnumeric
Base.isprint
Base.ispunct
Base.isspace
Base.isuppercase
Base.isxdigit
Core.Symbol
Base.escape_string
Base.unescape_string</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064309Z" creationid="hsugawa8651" creationdate="20181114T064309Z">
        <seg>Core.AbstractChar
Core.Char
Base.codepoint
Base.length(::AbstractString)
Base.sizeof(::AbstractString)
Base.:*(::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...)
Base.:^(::AbstractString, ::Integer)
Base.string
Base.repeat(::AbstractString, ::Integer)
Base.repeat(::AbstractChar, ::Integer)
Base.repr(::Any)
Core.String(::AbstractString)
Base.SubString
Base.transcode
Base.unsafe_string
Base.ncodeunits(::AbstractString)
Base.codeunit
Base.codeunits
Base.ascii
Base.@r_str
Base.SubstitutionString
Base.@s_str
Base.@raw_str
Base.Docs.@html_str
Base.Docs.@text_str
Base.isvalid(::Any)
Base.isvalid(::Any, ::Any)
Base.isvalid(::AbstractString, ::Integer)
Base.match
Base.eachmatch
Base.isless(::AbstractString, ::AbstractString)
Base.:(==)(::AbstractString, ::AbstractString)
Base.cmp(::AbstractString, ::AbstractString)
Base.lpad
Base.rpad
Base.findfirst(::AbstractString, ::AbstractString)
Base.findnext(::AbstractString, ::AbstractString, ::Integer)
Base.findlast(::AbstractString, ::AbstractString)
Base.findprev(::AbstractString, ::AbstractString, ::Integer)
Base.occursin
Base.reverse(::Union{String,SubString{String}})
Base.replace(s::AbstractString, ::Pair)
Base.split
Base.rsplit
Base.strip
Base.lstrip
Base.rstrip
Base.startswith
Base.endswith
Base.first(::AbstractString, ::Integer)
Base.last(::AbstractString, ::Integer)
Base.uppercase
Base.lowercase
Base.titlecase
Base.uppercasefirst
Base.lowercasefirst
Base.join
Base.chop
Base.chomp
Base.thisind
Base.nextind
Base.prevind
Base.textwidth
Base.isascii
Base.iscntrl
Base.isdigit
Base.isletter
Base.islowercase
Base.isnumeric
Base.isprint
Base.ispunct
Base.isspace
Base.isuppercase
Base.isxdigit
Core.Symbol
Base.escape_string
Base.unescape_string</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.Any
Core.Union
Union{}
Core.UnionAll
Core.Tuple
Core.NamedTuple
Base.Val
Core.Vararg
Core.Nothing
Base.isnothing
Base.Some
Base.something
Base.Enums.@enum</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041916Z" creationid="hsugawa8651" creationdate="20181110T041916Z">
        <seg>Core.Any
Core.Union
Union{}
Core.UnionAll
Core.Tuple
Core.NamedTuple
Base.Val
Core.Vararg
Core.Nothing
Base.isnothing
Base.Some
Base.something
Base.Enums.@enum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.Float16
Core.Float32
Core.Float64
Base.BigFloat
Core.Bool
Core.Int8
Core.UInt8
Core.Int16
Core.UInt16
Core.Int32
Core.UInt32
Core.Int64
Core.UInt64
Core.Int128
Core.UInt128
Base.BigInt
Base.Complex
Base.Rational
Base.Irrational</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044711Z" creationid="hsugawa8651" creationdate="20181112T044711Z">
        <seg>Core.Float16
Core.Float32
Core.Float64
Base.BigFloat
Core.Bool
Core.Int8
Core.UInt8
Core.Int16
Core.UInt16
Core.Int32
Core.UInt32
Core.Int64
Core.UInt64
Core.Int128
Core.UInt128
Base.BigInt
Base.Complex
Base.Rational
Base.Irrational</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.Function
Base.hasmethod
Core.applicable
Core.invoke
Base.invokelatest
new
Base.:(|&gt;)
Base.:(∘)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041920Z" creationid="hsugawa8651" creationdate="20181110T041920Z">
        <seg>Core.Function
Base.hasmethod
Core.applicable
Core.invoke
Base.invokelatest
new
Base.:(|&gt;)
Base.:(∘)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.Intrinsics.llvmcall</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042030Z" creationid="hsugawa8651" creationdate="20181110T042030Z">
        <seg>Core.Intrinsics.llvmcall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.Number
Core.Real
Core.AbstractFloat
Core.Integer
Core.Signed
Core.Unsigned
Base.AbstractIrrational</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044709Z" creationid="hsugawa8651" creationdate="20181112T044709Z">
        <seg>Core.Number
Core.Real
Core.AbstractFloat
Core.Integer
Core.Signed
Core.Unsigned
Base.AbstractIrrational</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.Task
Base.current_task
Base.istaskdone
Base.istaskstarted
Base.yield
Base.yieldto
Base.task_local_storage(::Any)
Base.task_local_storage(::Any, ::Any)
Base.task_local_storage(::Function, ::Any, ::Any)
Base.Condition
Base.notify
Base.schedule
Base.@task
Base.sleep
Base.Channel
Base.put!(::Channel, ::Any)
Base.take!(::Channel)
Base.isready(::Channel)
Base.fetch(::Channel)
Base.close(::Channel)
Base.bind(c::Channel, task::Task)
Base.asyncmap
Base.asyncmap!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044739Z" creationid="hsugawa8651" creationdate="20181112T044739Z">
        <seg>Core.Task
Base.current_task
Base.istaskdone
Base.istaskstarted
Base.yield
Base.yieldto
Base.task_local_storage(::Any)
Base.task_local_storage(::Any, ::Any)
Base.task_local_storage(::Function, ::Any, ::Any)
Base.Condition
Base.notify
Base.schedule
Base.@task
Base.sleep
Base.Channel
Base.put!(::Channel, ::Any)
Base.take!(::Channel)
Base.isready(::Channel)
Base.fetch(::Channel)
Base.close(::Channel)
Base.bind(c::Channel, task::Task)
Base.asyncmap
Base.asyncmap!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.eval
Base.MainInclude.eval
Base.@eval
Base.evalfile
Base.esc
Base.@inbounds
Base.@boundscheck
Base.@inline
Base.@noinline
Base.@nospecialize
Base.@specialize
Base.gensym
Base.@gensym
Base.@goto
Base.@label
Base.@simd
Base.@polly
Base.@generated
Base.@pure</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041926Z" creationid="hsugawa8651" creationdate="20181110T041926Z">
        <seg>Core.eval
Base.MainInclude.eval
Base.@eval
Base.evalfile
Base.esc
Base.@inbounds
Base.@boundscheck
Base.@inline
Base.@noinline
Base.@nospecialize
Base.@specialize
Base.gensym
Base.@gensym
Base.@goto
Base.@label
Base.@simd
Base.@polly
Base.@generated
Base.@pure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.isdefined
Base.@isdefined
Base.convert
Base.promote
Base.oftype
Base.widen
Base.identity</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041832Z" creationid="hsugawa8651" creationdate="20181110T041832Z">
        <seg>Core.isdefined
Base.@isdefined
Base.convert
Base.promote
Base.oftype
Base.widen
Base.identity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core.nothing
Base.PROGRAM_FILE
Base.ARGS
Base.C_NULL
Base.VERSION
Base.LOAD_PATH
Base.Sys.BINDIR
Base.Sys.CPU_THREADS
Base.Sys.WORD_SIZE
Base.Sys.KERNEL
Base.Sys.ARCH
Base.Sys.MACHINE</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043137Z" creationid="hsugawa8651" creationdate="20181112T043137Z">
        <seg>Core.nothing
Base.PROGRAM_FILE
Base.ARGS
Base.C_NULL
Base.VERSION
Base.LOAD_PATH
Base.Sys.BINDIR
Base.Sys.CPU_THREADS
Base.Sys.WORD_SIZE
Base.Sys.KERNEL
Base.Sys.ARCH
Base.Sys.MACHINE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count bytes allocated by each source line</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224805Z" creationid="hsugawa8651" creationdate="20181109T224805Z">
        <seg>各ソース行によって割り当てられたカウントバイト数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count executions of source lines</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224758Z" creationid="hsugawa8651" creationdate="20181109T224758Z">
        <seg>ソース行の実行数のカウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating C-Compatible Julia Function Pointers</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133847Z" creationid="hsugawa8651" creationdate="20181117T133847Z">
        <seg>C互換性のあるJulia関数ポインタの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creation of a variable named &lt;x7/&gt;where&lt;x8/&gt;, &lt;x9/&gt;in&lt;x10/&gt; or &lt;x11/&gt;isa&lt;x12/&gt; is allowed though.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041808Z" creationid="hsugawa8651" creationdate="20181110T041808Z">
        <seg>&lt;x8/&gt;は&lt;x8/&gt;、&lt;x10/&gt;は&lt;x10/&gt;isa&lt;x12/&gt;では&lt;x12/&gt;であるが、&lt;x12/&gt;は&lt;x12/&gt;&lt;x12/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cshort&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150910Z" creationid="hsugawa8651" creationdate="20181117T150910Z">
        <seg>Cshort&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cstring&lt;x1/&gt; type here: as the array is uninitialized, it could contain NUL bytes.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150520Z" creationid="hsugawa8651" creationdate="20181117T150520Z">
        <seg>ここではCstring&lt;x1/&gt;タイプです:配列は初期化されていないので、NULバイトを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cstring&lt;x1/&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting
to a &lt;x2/&gt;Cstring&lt;x3/&gt; as part of the &lt;x4/&gt;`ccall`&lt;x5/&gt; checks for contained NUL bytes and could therefore
throw a conversion error.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133845Z" creationid="hsugawa8651" creationdate="20181117T133845Z">
        <seg>Cstring&lt;x1/&gt;タイプ:配列は初期化されていないため、NULバイトを含むことができます。変換 &lt;x4/&gt;Cstring&lt;x3/&gt;は、含まれるNULバイトを&lt;x4/&gt;'ccall&lt;x5/&gt;チェックの一部として&lt;x2/&gt;にします。したがって 変換エラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cuchar&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150900Z" creationid="hsugawa8651" creationdate="20181117T150900Z">
        <seg>Cuchar&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, only the platform-default C calling convention is supported.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153954Z" creationid="hsugawa8651" creationdate="20181109T153954Z">
        <seg>現在、プラットフォームのデフォルトのC呼び出し規約のみがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, only the platform-default C calling convention is supported. This means that
&lt;x1/&gt;@cfunction&lt;x2/&gt;-generated pointers cannot be used in calls where WINAPI expects &lt;x3/&gt;stdcall&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133912Z" creationid="hsugawa8651" creationdate="20181117T133912Z">
        <seg>現在、プラットフォームのデフォルトのC呼び出し規則のみがサポートされています。これは、次のことを意味します。 &lt;x1/&gt;@cfunction&lt;x2/&gt;-生成されたポインタは、WINAPIが&lt;x3/&gt;stdcall&lt;x4/&gt;を想定している呼び出しでは使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, this is only supported for primitive types or other pointer-free (&lt;x5/&gt;isbits&lt;x6/&gt;) immutable struct types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152601Z" creationid="hsugawa8651" creationdate="20181117T152601Z">
        <seg>現在では、これはプリミティブ型または他のポインタフリー(&lt;x5/&gt;イスビトス&lt;x6/&gt;)の不変構造型タイプでのみサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom implementation of &lt;x1/&gt;broadcast!&lt;x2/&gt;, specializing on &lt;x3/&gt;DestStyle&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083617Z" creationid="hsugawa8651" creationdate="20181113T083617Z">
        <seg>&lt;x1/&gt;ブロードキャストのカスタム実装!&lt;x2/&gt;DestStyle&lt;x4/&gt;を専門にしています。&lt;x/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom implementation of &lt;x1/&gt;broadcast!&lt;x2/&gt;, specializing on &lt;x3/&gt;DestType&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083625Z" creationid="hsugawa8651" creationdate="20181113T083625Z">
        <seg>&lt;x1/&gt;ブロードキャストのカスタム実装!&lt;x2/&gt;DestType&lt;x4/&gt;を専門にしています。&lt;x3/&gt;&lt;x/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom implementation of &lt;x1/&gt;broadcast&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083607Z" creationid="hsugawa8651" creationdate="20181113T083607Z">
        <seg>&lt;x1/&gt;ブロードキャストのカスタム実装&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom types can similarly specialize
&lt;x21/&gt;Base.broadcastable&lt;x22/&gt; to define their shape, but they should follow the convention that
&lt;x23/&gt;collect(Base.broadcastable(x)) == collect(x)&lt;x24/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131100Z" creationid="hsugawa8651" creationdate="20181113T131100Z">
        <seg>カスタム・タイプも同様に特殊化できます。 &lt;X21/&gt;Base.broadcastable&lt;x22/&gt;のシェイプを定義するには、次の規則に従う必要があります。 &lt;x23/&gt;collect(Base.broadcastable(x))==collect(x)&lt;x24/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cvoid&lt;x1/&gt; (this will return the singleton instance &lt;x2/&gt;nothing::Cvoid&lt;x3/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151800Z" creationid="hsugawa8651" creationdate="20181117T151800Z">
        <seg>Cvoid&lt;x1/&gt;(これはシングルトンインスタンス&lt;x2/&gt;なし:Cvoid&lt;x3/&gt;を返します)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Formats</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044712Z" creationid="hsugawa8651" creationdate="20181112T044712Z">
        <seg>Data Formats</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration of the indices of &lt;x1/&gt;x&lt;x2/&gt;, as per &lt;x3/&gt;`axes(x)`&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083541Z" creationid="hsugawa8651" creationdate="20181113T083541Z">
        <seg>&lt;x3/&gt;x&lt;x2/&gt;の指数を&lt;x3/&gt;の軸(x)&lt;x4/&gt;に従って宣言する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default definition&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094057Z" creationid="hsugawa8651" creationdate="20181118T094057Z">
        <seg>デフォルト定義&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DefaultArrayStyle&lt;x1/&gt; "loses" to any other
&lt;x2/&gt;AbstractArrayStyle&lt;x3/&gt; that has been defined because of the following methods:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131811Z" creationid="hsugawa8651" creationdate="20181113T131811Z">
        <seg>DefaultArrayStyle&lt;x1/&gt;"は他のすべてに"失われます" &lt;x2/&gt;AbstractArrayStyle&lt;x3/&gt;は、以下の方法により定義されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DefaultArrayStyle&lt;x1/&gt; types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131826Z" creationid="hsugawa8651" creationdate="20181113T131826Z">
        <seg>DefaultArrayStyle&lt;x1/&gt; types.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define these
two functions for custom types to override how they are stored in a hash table.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041724Z" creationid="hsugawa8651" creationdate="20181112T041724Z">
        <seg>これらを定義する ハッシュテーブルに格納される方法を上書きするカスタムタイプ用の2つの関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining &lt;x6/&gt;similar&lt;x7/&gt;, &lt;x8/&gt;getindex&lt;x9/&gt; and
&lt;x10/&gt;setindex!&lt;x11/&gt; for &lt;x12/&gt;SparseArray&lt;x13/&gt; also makes it possible to &lt;x14/&gt;`copy`&lt;x15/&gt; the array:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083320Z" creationid="hsugawa8651" creationdate="20181113T083320Z">
        <seg>&lt;x6/&gt;類似の&lt;x7/&gt;を定義し、&lt;x8/&gt;getindex&lt;x9/&gt;を定義します。 &lt;x12/&gt;setindex!&lt;x12/&gt;&lt;x12/&gt;SparseArray&lt;x13/&gt;は、&lt;x14/&gt;'コピー&lt;x15/&gt;を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DenseArray&lt;x1/&gt; is an abstract subtype of &lt;x2/&gt;AbstractArray&lt;x3/&gt; intended to include all arrays where
elements are stored contiguously in column-major order (see additional notes in
&lt;x4/&gt;&lt;x5/&gt;&lt;x6/&gt;(@ref man-performance-tips)).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160418Z" creationid="hsugawa8651" creationdate="20181109T160418Z">
        <seg>DenseArray&lt;x1/&gt;は、すべての配列を含むことを意図した&lt;x2/&gt;AbstractArray&lt;x3/&gt;の抽象サブタイプである。 要素は列主順序で連続的に格納されます(追加の注記を参照してください)。 &lt;x4/&gt;&lt;x5/&gt;&lt;x6/&gt;(@ref manのパフォーマンス・ヒント))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DenseArray&lt;x1/&gt; is an abstract subtype of &lt;x2/&gt;AbstractArray&lt;x3/&gt; intended to include all arrays where
elements are stored contiguously in column-major order (see additional notes in
&lt;x4/&gt;&lt;x5/&gt;&lt;x6/&gt;(@ref man-performance-tips)). The &lt;x7/&gt;`Array`&lt;x8/&gt; type is a specific instance
of &lt;x9/&gt;DenseArray&lt;x10/&gt;;  &lt;x11/&gt;`Vector`&lt;x12/&gt; and &lt;x13/&gt;`Matrix`&lt;x14/&gt; are aliases for the 1-d and 2-d cases.
Very few operations are implemented specifically for &lt;x15/&gt;Array&lt;x16/&gt; beyond those that are required
for all &lt;x17/&gt;AbstractArray&lt;x18/&gt;s; much of the array library is implemented in a generic
manner that allows all custom arrays to behave similarly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135326Z" creationid="hsugawa8651" creationdate="20181117T135326Z">
        <seg>DenseArray&lt;x1/&gt;は、すべての配列を含むことを意図した&lt;x2/&gt;AbstractArray&lt;x3/&gt;の抽象サブタイプである。 要素は列主順序で連続的に格納されます(追加の注記を参照してください)。 &lt;x4/&gt;&lt;x5/&gt;&lt;x6/&gt;(@ref man performance tips).&lt;x7/&gt;'Array`&lt;x8/&gt;typeは特定のインスタンスです。 &lt;x9/&gt;DenseArray&lt;x10/&gt;;&lt;x11/&gt;'Vector'&lt;x12/&gt;および&lt;x13/&gt;'Matrix'&lt;x14/&gt;は、1-dおよび2-dケースのエイリアスです。 &lt;x15/&gt;アレイ&lt;x16/&gt;に対しては、必要な動作を超えて実装されているオペレーションはほとんどありません。 すべての&lt;x17/&gt;AbstractArray&lt;x18/&gt;;アレイライブラリの多くは一般的に実装されています。 すべてのカスタム・アレイが同じように動作するようにする方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dequeues</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041832Z" creationid="hsugawa8651" creationdate="20181112T041832Z">
        <seg>Dequeues</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Description</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110803Z" creationid="hsugawa8651" creationdate="20181112T110803Z">
        <seg>Description</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designed for parallelism and distributed computation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082802Z" creationid="hsugawa8651" creationdate="20181118T082653Z">
        <seg>並列コンピューティング・分散コンピューティングを意図した設計
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dict("A"=&gt;1, "B"=&gt;2)&lt;x1/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041733Z" creationid="hsugawa8651" creationdate="20181112T041733Z">
        <seg>Dict("A"=&gt;1, "B"=&gt;2)&lt;x1/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041713Z" creationid="hsugawa8651" creationdate="20181112T041713Z">
        <seg>Dictionaries</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries may also be created with generators.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041748Z" creationid="hsugawa8651" creationdate="20181112T041748Z">
        <seg>辞書はジェネレータで作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224756Z" creationid="hsugawa8651" creationdate="20181109T224756Z">
        <seg>安全でない浮動小数点の最適化を許可または有効にします(@ファストマト宣言を無効にします)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Display version information</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224555Z" creationid="hsugawa8651" creationdate="20181109T224555Z">
        <seg>バージョン情報を表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not try to free an
object received from a C library with &lt;x1/&gt;`Libc.free`&lt;x2/&gt; in Julia, as this may result in the &lt;x3/&gt;free&lt;x4/&gt; function
being called via the wrong &lt;x5/&gt;libc&lt;x6/&gt; library and cause Julia to crash.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151431Z" creationid="hsugawa8651" creationdate="20181117T151431Z">
        <seg>次の操作を実行しないでください。 は、&lt;x/&gt;Libc.free&lt;x2/&gt;&lt;x2/&gt;を含むCライブラリから受信されたオブジェクトで、&lt;x3/&gt;フリー&lt;x4/&gt;関数を生成する可能性がある 間違った&lt;x5/&gt;libc&lt;x6/&gt;ライブラリを介して呼び出され、ジュリアがクラッシュすることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use `end`&lt;x4/&gt;&lt;x5/&gt;in indexing expressions that may contain either `CartesianIndex` or arrays thereof.&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155720Z" creationid="hsugawa8651" creationdate="20181109T155720Z">
        <seg>「CartesianIndex」またはその配列が含まれる可能性のある表現のインデックス作成には「end」&lt;x4/&gt;&lt;x5/&gt;を使用しないでください。&lt;x6/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use this for functions that return no value
(&lt;x11/&gt;void&lt;x12/&gt;) but do return, use &lt;x13/&gt;Cvoid&lt;x14/&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151026Z" creationid="hsugawa8651" creationdate="20181117T151026Z">
        <seg>値を返さない関数にはこれを使用しない (&lt;x11/&gt;void&lt;x12/&gt;)しかし、リターンする場合は、&lt;x13/&gt;Cvoid&lt;x14/&gt;を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download and install Julia by
following the instructions at
&lt;a0&gt;http://julialang.org/downloads/&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083732Z" creationid="hsugawa8651" creationdate="20181118T083732Z">
        <seg>&lt;a0&gt;http://julialang.org/downloads/&lt;/a0&gt; にある手順に従い、Juliaをダウンロードしてインストールしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download and install Julia by following the instructions at &lt;x1/&gt;https://julialang.org/downloads/&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224249Z" creationid="hsugawa8651" creationdate="20181109T224249Z">
        <seg>&lt;x1/&gt;https://julialang.org/downloads/&lt;x2/&gt;の指示に従って、Juliaをダウンロードしてインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each machine definition
takes the form &lt;x10/&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;x11/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092436Z" creationid="hsugawa8651" creationdate="20181109T224423Z">
        <seg>各マシンの定義は &lt;x10/&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;x11/&gt;という形式で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each machine definition takes the form
&lt;c18&gt;&lt;s19&gt;[count*][user@]host[:port]&lt;/s19&gt; &lt;s20&gt;[bind_addr[:port]]&lt;/s20&gt;&lt;/c18&gt; .</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085311Z" creationid="hsugawa8651" creationdate="20181118T084939Z">
        <seg>各マシンの定義は &lt;c18&gt;&lt;s19&gt;[count*][user@]host[:port]&lt;/s19&gt; &lt;s20&gt;[bind_addr[:port]]&lt;/s20&gt;&lt;/c18&gt; という形式で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each method of a generated function has its own view of defined functions:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015729Z" creationid="hsugawa8651" creationdate="20181116T015729Z">
        <seg>Each method of a generated function has its own view of defined functions:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EachLine&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041611Z" creationid="hsugawa8651" creationdate="20181112T041611Z">
        <seg>EachLine&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Efficient support for
&lt;a0&gt;Unicode&lt;/a0&gt;, including but not
limited to &lt;a1&gt;UTF-8&lt;/a1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083006Z" creationid="hsugawa8651" creationdate="20181118T082900Z">
        <seg>&lt;a0&gt;Unicode&lt;/a0&gt; の効率的なサポート。 &lt;a1&gt;UTF-8&lt;/a1&gt; も含みますが、これに限定しません
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either &lt;x1/&gt;EltypeUnknown()&lt;x2/&gt; or &lt;x3/&gt;HasEltype()&lt;x4/&gt; as appropriate</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112153Z" creationid="hsugawa8651" creationdate="20181112T112153Z">
        <seg>&lt;x1/&gt;EltypeUnknown()&lt;x2/&gt;または&lt;x3/&gt;HasEltype()&lt;x4/&gt;のいずれか適切な場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elegant and extensible conversions and promotions for numeric and
other types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082846Z" creationid="hsugawa8651" creationdate="20181118T082846Z">
        <seg>数値型他の型の、エレガントで拡張性のある変換やプロモーション [2]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EltypeUnknown()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112342Z" creationid="hsugawa8651" creationdate="20181112T112342Z">
        <seg>EltypeUnknown()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emit bounds checks always or never (ignoring declarations)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224752Z" creationid="hsugawa8651" creationdate="20181109T224752Z">
        <seg>放出の境界チェックは常に行われる(宣言を無視する)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty arrays like &lt;x1/&gt;[]&lt;x2/&gt;, which select no elements</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155524Z" creationid="hsugawa8651" creationdate="20181109T155524Z">
        <seg>&lt;x1/&gt;[]&lt;x2/&gt;のような空の配列で、要素は選択されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty ranges of the form &lt;x1/&gt;n:n-1&lt;x2/&gt; are sometimes used to indicate the inter-index location between
&lt;x3/&gt;n-1&lt;x4/&gt; and &lt;x5/&gt;n&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155316Z" creationid="hsugawa8651" creationdate="20181109T155316Z">
        <seg>&lt;x1/&gt;n:n-1&lt;x2/&gt;という形式の空の範囲は、場合によっては、インデックス間の位置を示すために使用される。 &lt;x3/&gt;n-1&lt;x4/&gt;および&lt;x5/&gt;n&lt;x6/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty ranges of the form &lt;x1/&gt;n:n-1&lt;x2/&gt; are sometimes used to indicate the inter-index location between
&lt;x3/&gt;n-1&lt;x4/&gt; and &lt;x5/&gt;n&lt;x6/&gt;. For example, the &lt;x7/&gt;`searchsorted`&lt;x8/&gt; function uses this convention to indicate
the insertion point of a value not found in a sorted array:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134844Z" creationid="hsugawa8651" creationdate="20181117T134844Z">
        <seg>&lt;x1/&gt;n:n-1&lt;x2/&gt;という形式の空の範囲は、場合によっては、インデックス間の位置を示すために使用される。 &lt;x3/&gt;n-1&lt;x4/&gt;と&lt;x5/&gt;n&lt;x6/&gt;。たとえば、&lt;x7/&gt;'セアルチゾルタド'&lt;x8/&gt;はこの表記法を使用します。 ソートされた配列に存在しない値の挿入点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224747Z" creationid="hsugawa8651" creationdate="20181109T224747Z">
        <seg>デバッグ情報の生成レベルを有効/設定します(デフォルトレベルは、指定されていない場合は1、レベルなしでは2を指定します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enable or disable Julia's default signal handlers</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224649Z" creationid="hsugawa8651" creationdate="20181109T224649Z">
        <seg>ジュリアのデフォルトシグナルハンドラを有効または無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enable or disable color text</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224727Z" creationid="hsugawa8651" creationdate="20181109T224727Z">
        <seg>カラーテキストを有効または無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enable or disable incremental precompilation of modules</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224655Z" creationid="hsugawa8651" creationdate="20181109T224655Z">
        <seg>モジュールのインクリメンタル事前コンパイルを有効または無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enable or disable method overwrite warnings</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224735Z" creationid="hsugawa8651" creationdate="20181109T224735Z">
        <seg>メソッドの上書き警告を有効または無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enable or disable startup banner</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224725Z" creationid="hsugawa8651" creationdate="20181109T224725Z">
        <seg>起動バナーを有効または無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enable or disable syntax and method deprecation warnings (&lt;x1/&gt;error&lt;x2/&gt; turns warnings into errors)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224733Z" creationid="hsugawa8651" creationdate="20181109T224733Z">
        <seg>構文およびメソッドの非推奨警告を有効または無効にします(&lt;x1/&gt;エラー&lt;x2/&gt;は警告をエラーに変換します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring that all arguments support broadcast</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131024Z" creationid="hsugawa8651" creationdate="20181113T131024Z">
        <seg>すべての引数がブロードキャストをサポートすることを確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Environments</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152911Z" creationid="hsugawa8651" creationdate="20181117T152911Z">
        <seg>環境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Errors</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150120Z" creationid="hsugawa8651" creationdate="20181117T150120Z">
        <seg>Errors</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentials</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041641Z" creationid="hsugawa8651" creationdate="20181110T041641Z">
        <seg>Essentials</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluate &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224659Z" creationid="hsugawa8651" creationdate="20181109T224659Z">
        <seg>&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;を評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluate &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt; and display the result</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031719Z" creationid="hsugawa8651" creationdate="20181109T224702Z">
        <seg>Evaluate &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt; and display the result</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042013Z" creationid="hsugawa8651" creationdate="20181110T042013Z">
        <seg>Events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every C type also has a corresponding Julia type with the same name, prefixed by C.
This can help for writing portable code (and remembering that an &lt;x1/&gt;int&lt;x2/&gt; in C is not the same as
an &lt;x3/&gt;Int&lt;x4/&gt; in Julia).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150838Z" creationid="hsugawa8651" creationdate="20181117T150838Z">
        <seg>すべてのC型は同じ名前を冠した同じ名前を持つ、対応するジュリア型を持っています。 これは、移植可能なコードを書くのに役立ちます(そして、Cでは&lt;x1/&gt;int&lt;x2/&gt;が同じではないことを思い出してください)。 &lt;x3/&gt;のInt&lt;x4/&gt;Int&lt;x4/&gt;int&lt;x4/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every binary arithmetic and bitwise operator also has an updating version that assigns the result
of the operation back into its left operand.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132351Z" creationid="hsugawa8651" creationdate="20181113T132351Z">
        <seg>すべてのバイナリ算術演算子とビット演算子には、結果を指定する更新バージョンもあります。 は左オペランドに戻る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everyday programming requires no
direct usage of tasks, but certain problems can be solved much more easily by using tasks.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225751Z" creationid="hsugawa8651" creationdate="20181109T225751Z">
        <seg>日常的なプログラミングでは タスクを直接使用することはできますが、タスクを使用することによって、特定の問題をより容易に解決することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly corresponds to the &lt;x1/&gt;complex double&lt;x2/&gt; type in C (or &lt;x3/&gt;COMPLEX*16&lt;x4/&gt; in Fortran).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134434Z" creationid="hsugawa8651" creationdate="20181117T134434Z">
        <seg>厳密には、Cの&lt;x1/&gt;複合体二重&lt;x2/&gt;型(Fortranの場合は&lt;x3/&gt;COMPLEX*16&lt;x4/&gt;)に対応する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly corresponds to the &lt;x1/&gt;complex float&lt;x2/&gt; type in C (or &lt;x3/&gt;COMPLEX*8&lt;x4/&gt; in Fortran).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134426Z" creationid="hsugawa8651" creationdate="20181117T134426Z">
        <seg>厳密には、Cの&lt;x1/&gt;複合float&lt;x2/&gt;タイプ(Fortranの場合は&lt;x3/&gt;COMPLEX*8&lt;x4/&gt;)に対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly corresponds to the &lt;x1/&gt;double&lt;x2/&gt; type in C (or &lt;x3/&gt;REAL*8&lt;x4/&gt; in Fortran).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134416Z" creationid="hsugawa8651" creationdate="20181117T134416Z">
        <seg>厳密には、Cの&lt;x1/&gt;double&lt;x2/&gt;型(Fortranの場合は&lt;x3/&gt;REAL*8&lt;x4/&gt;)に対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly corresponds to the &lt;x1/&gt;float&lt;x2/&gt; type in C (or &lt;x3/&gt;REAL*4&lt;x4/&gt; in Fortran).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134412Z" creationid="hsugawa8651" creationdate="20181117T134412Z">
        <seg>厳密には、Cの&lt;x1/&gt;float&lt;x2/&gt;タイプ(Fortranの場合は&lt;x3/&gt;REAL*4&lt;x4/&gt;)に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly corresponds to the &lt;x1/&gt;signed&lt;x2/&gt; type annotation in C (or any &lt;x3/&gt;INTEGER&lt;x4/&gt; type in Fortran).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150815Z" creationid="hsugawa8651" creationdate="20181117T150815Z">
        <seg>厳密には、C(またはFortranでは任意の&lt;x3/&gt;INTEGER&lt;x4/&gt;タイプ)の&lt;x1/&gt;署名された&lt;x2/&gt;型の注釈に対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly corresponds to the &lt;x1/&gt;signed&lt;x2/&gt; type annotation in C (or any &lt;x3/&gt;INTEGER&lt;x4/&gt; type in Fortran).
Any Julia type that is not a subtype of &lt;x5/&gt;`Signed`&lt;x6/&gt; is assumed to be unsigned.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134446Z" creationid="hsugawa8651" creationdate="20181117T134446Z">
        <seg>厳密には、C(またはFortranでは任意の&lt;x3/&gt;INTEGER&lt;x4/&gt;タイプ)の&lt;x1/&gt;署名された&lt;x2/&gt;型の注釈に対応しています。 &lt;x5/&gt;'署名された&lt;x6/&gt;のサブタイプではないジュリア型は、符号なしであると仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150617Z" creationid="hsugawa8651" creationdate="20181117T150617Z">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134832Z" creationid="hsugawa8651" creationdate="20181117T134832Z">
        <seg>例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception Handling&lt;x1/&gt;: &lt;x2/&gt;try&lt;x3/&gt;-&lt;x4/&gt;catch&lt;x5/&gt;, &lt;x6/&gt;`error`&lt;x7/&gt; and &lt;x8/&gt;`throw`&lt;x9/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225735Z" creationid="hsugawa8651" creationdate="20181109T225735Z">
        <seg>例外処理&lt;x1/&gt;:&lt;x2/&gt;try&lt;x3/&gt;-&lt;x4/&gt;catch&lt;x5/&gt;&lt;x6/&gt;'エラー'&lt;x7/&gt;'&lt;x7/&gt;'&lt;x9/&gt;"&lt;x9/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Existing code then seamlessly applies to the new data
types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082518Z" creationid="hsugawa8651" creationdate="20181118T082441Z">
        <seg>こうすることで、既存のコードをシームレスに新たなデータ型対応させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly,
this means that:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230231Z" creationid="hsugawa8651" creationdate="20181109T230231Z">
        <seg>明示的に つまり、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expression</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134547Z" creationid="hsugawa8651" creationdate="20181117T134547Z">
        <seg>式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions starting with &lt;x1/&gt;0x&lt;x2/&gt; are always hexadecimal literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111941Z" creationid="hsugawa8651" creationdate="20181112T111941Z">
        <seg>&lt;x1/&gt;0x&lt;x2/&gt;で始まる式は常に16進数のリテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions starting with a numeric literal followed by &lt;x1/&gt;e&lt;x2/&gt; or &lt;x3/&gt;E&lt;x4/&gt; are always floating-point literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111944Z" creationid="hsugawa8651" creationdate="20181112T111944Z">
        <seg>数字リテラル後に&lt;x1/&gt;e&lt;x2/&gt;または&lt;x3/&gt;E&lt;x4/&gt;が続く式は常に浮動小数点リテラルである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions starting with a numeric literal followed by &lt;x1/&gt;f&lt;x2/&gt; are always 32-bit floating-point literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111947Z" creationid="hsugawa8651" creationdate="20181112T111947Z">
        <seg>数値リテラルで始まり、&lt;x x/&gt;f&lt;x2/&gt;が続く式は常に32ビット浮動小数点リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended documentation for mathematical symbols &amp; functions is &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref math-ops).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063434Z" creationid="hsugawa8651" creationdate="20181114T063434Z">
        <seg>数学的シンボルと関数の拡張ドキュメントは&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref math ops)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Federation of packages</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152820Z" creationid="hsugawa8651" creationdate="20181117T152820Z">
        <seg>パッケージの連合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043206Z" creationid="hsugawa8651" creationdate="20181112T043206Z">
        <seg>Filesystem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, one should define a function
&lt;x25/&gt;display(d::D, x)&lt;x26/&gt; that queries &lt;x27/&gt;`showable(mime, x)`&lt;x28/&gt; for the &lt;x29/&gt;mime&lt;x30/&gt; types supported by &lt;x31/&gt;D&lt;x32/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063325Z" creationid="hsugawa8651" creationdate="20181114T063325Z">
        <seg>最後に、関数を定義する必要があります。 &lt;x25/&gt;display(d::D, x)&lt;x26/&gt;'&lt;x31/&gt;'showable(mime、x)`&lt;x31/&gt;D&lt;x32/&gt;D&lt;x32/&gt;でサポートされている&lt;x29/&gt;mime&lt;x30/&gt;の種類については、&lt;x27/&gt;を参照してください。x28</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you can use &lt;x1/&gt;`ccall`&lt;x2/&gt; to actually generate a call to the library function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223825Z" creationid="hsugawa8651" creationdate="20181109T223825Z">
        <seg>最後に、&lt;x1/&gt;`ccall'&lt;x2/&gt;を使ってライブラリ関数への呼び出しを実際に生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you can use &lt;x1/&gt;`ccall`&lt;x2/&gt; to actually generate a call to the library function. Arguments
to &lt;x3/&gt;`ccall`&lt;x4/&gt; are as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133759Z" creationid="hsugawa8651" creationdate="20181117T133759Z">
        <seg>最後に、&lt;x1/&gt;`ccall'&lt;x2/&gt;を使ってライブラリ関数への呼び出しを実際に生成することができます。引数は引数を指定します。 &lt;x3/&gt;'ccall'&lt;x4/&gt;は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally,&lt;x1/&gt;where&lt;x2/&gt; is parsed as an infix operator for writing parametric method
and type definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041802Z" creationid="hsugawa8651" creationdate="20181110T041802Z">
        <seg>最後に&lt;x1/&gt;は、&lt;x2/&gt;がパラメトリックメソッドを記述するためのインフィックス演算子として構文解析される。 定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finite numbers are ordered in the usual manner.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030459Z" creationid="hsugawa8651" creationdate="20181114T030459Z">
        <seg>有限数は通常の方法で順序付けされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First"
 "2.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161329Z" creationid="hsugawa8651" creationdate="20181114T161329Z">
        <seg>First"
 "2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, a review of some relevant Julia type terminology:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134309Z" creationid="hsugawa8651" creationdate="20181117T134309Z">
        <seg>まず、いくつかの関連するJulia型用語のレビューを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Float16&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110758Z" creationid="hsugawa8651" creationdate="20181112T110758Z">
        <seg>Float16&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Float32&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110800Z" creationid="hsugawa8651" creationdate="20181112T110800Z">
        <seg>Float32&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154902Z" creationid="hsugawa8651" creationdate="20181109T154902Z">
        <seg>Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Float64&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110801Z" creationid="hsugawa8651" creationdate="20181112T110801Z">
        <seg>Float64&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar
with the low-level implementation details.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111346Z" creationid="hsugawa8651" creationdate="20181112T111346Z">
        <seg>浮動小数点演算は、慣れ親しみのあるユーザに驚くほどの繊細さを必要とします。 低レベルの実装の詳細です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point numbers
are compared according to the &lt;x1/&gt;IEEE 754 standard&lt;x2/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030457Z" creationid="hsugawa8651" creationdate="20181114T030457Z">
        <seg>浮動小数点数 は、&lt;x1/&gt;IEEE754規格&lt;x2/&gt;に従って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point numbers have &lt;x1/&gt;two zeros&lt;x2/&gt;, positive zero
and negative zero.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110744Z" creationid="hsugawa8651" creationdate="20181112T110744Z">
        <seg>浮動小数点数は&lt;x1/&gt;2 0x2/&gt;、正0は正の値です。 マイナス0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
&lt;x5/&gt;`BigFloat`&lt;x6/&gt; the &lt;x7/&gt;GNU MPFR library&lt;x8/&gt; is used,
and for &lt;x9/&gt;`BigInt`&lt;x10/&gt; the &lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032207Z" creationid="hsugawa8651" creationdate="20181114T032207Z">
        <seg>その他 &lt;x5/&gt;'BigFloat'&lt;x6/&gt;&lt;x7/&gt;GNU MPFRライブラリ&lt;x8/&gt;は使用されます。 そして&lt;x9/&gt;'BigInt'&lt;x10/&gt;&lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For &lt;x1/&gt;AbstractArray&lt;x2/&gt; types, defining a &lt;x3/&gt;BroadcastStyle&lt;x4/&gt; supersedes the fallback choice,
&lt;x5/&gt;`Broadcast.DefaultArrayStyle`&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131802Z" creationid="hsugawa8651" creationdate="20181113T131802Z">
        <seg>&lt;x1/&gt;AbstractArray&lt;x2/&gt;タイプでは、&lt;x3/&gt;BroadcastStyleを定義することによって、フォールバック選択が優先されます。 &lt;x5/&gt;`ブロードキャスト.DefaultArrayStyle'&lt;x6/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For &lt;x1/&gt;AbstractArrays&lt;x2/&gt; that only support a certain dimensionality, create a subtype of &lt;x3/&gt;Broadcast.AbstractArrayStyle{N}&lt;x4/&gt; (see below).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131244Z" creationid="hsugawa8651" creationdate="20181113T131244Z">
        <seg>特定の次元のみをサポートする&lt;x1/&gt;AbstractArrays&lt;x2/&gt;では、&lt;x3/&gt;ブロードキャストのサブタイプを作成します。AbstractArrayStyle{N}&lt;x4/&gt;(以下を参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For &lt;x1/&gt;every&lt;x2/&gt; binary operation like &lt;x3/&gt;^&lt;x4/&gt;, there is a corresponding
"dot" operation &lt;x5/&gt;.^&lt;x6/&gt; that is &lt;x7/&gt;automatically&lt;x8/&gt; defined
to perform &lt;x9/&gt;^&lt;x10/&gt; element-by-element on arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132457Z" creationid="hsugawa8651" creationdate="20181113T132457Z">
        <seg>&lt;x3/&gt;^&lt;x4/&gt;のように&lt;x1/&gt;のバイナリ演算に対しては、対応するものが存在する。 「ドット」操作&lt;x5/&gt;.^&lt;x6/&gt;は自動的に&lt;x8/&gt;定義され、&lt;x8/&gt;は自動的に&lt;x8/&gt;定義されます 配列上で&lt;x9/&gt;^&lt;x10/&gt;エレメント単位で実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C code accepting
pointers, &lt;x5/&gt;`Ref{T}`&lt;x6/&gt; should generally be used for the types of input arguments, allowing the use
of pointers to memory managed by either Julia or C through the implicit call to &lt;x7/&gt;`Base.cconvert`&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151443Z" creationid="hsugawa8651" creationdate="20181117T151443Z">
        <seg>Cコードを受け入れるには ポインタ、&lt;x5/&gt;'Ref{T}は、一般的に入力引数のタイプに使用されるべきであり、使用されることができる。 は、&lt;x7/&gt;'Base.チコンベルト'&lt;x8/&gt;への暗黙的な呼び出しを介して、JuliaまたはCによって管理されるメモリへのポインタを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a brief but lucid presentation of how floating-point numbers are represented, see John D.
Cook's &lt;x1/&gt;article&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111455Z" creationid="hsugawa8651" creationdate="20181112T111455Z">
        <seg>浮動小数点数がどのように表されるかについての簡潔な説明は、John Dを参照してください。 クックの&lt;x1/&gt;成形品&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a complete example, let's say you have created a type, &lt;x1/&gt;ArrayAndChar&lt;x2/&gt;, that stores an
array and a single character:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131352Z" creationid="hsugawa8651" creationdate="20181113T131352Z">
        <seg>完全な例では、&lt;x1/&gt;ArrayAndChar&lt;x2/&gt;というタイプを作成し、それを保存するとします。 配列と単一文字:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a complete list of &lt;x1/&gt;every&lt;x2/&gt; Julia operator's precedence, see the top of this file:
&lt;x3/&gt;`src/julia-parser.scm`&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030950Z" creationid="hsugawa8651" creationdate="20181114T030950Z">
        <seg>&lt;x2/&gt;ジュリア演算子の優先順位の&lt;x1/&gt;の完全なリストについては、このファイルの一番上を参照してください。 &lt;x3/&gt;`src/julia parser.scm'&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a handful of other types (including but not limited to
types themselves, functions, special singletons like &lt;x13/&gt;`missing`&lt;x14/&gt; and &lt;x15/&gt;`nothing`&lt;x16/&gt;, and dates),
&lt;x17/&gt;Base.broadcastable&lt;x18/&gt; returns the argument wrapped in a &lt;x19/&gt;Ref&lt;x20/&gt; to act as a 0-dimensional
"scalar" for the purposes of broadcasting.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131053Z" creationid="hsugawa8651" creationdate="20181113T131053Z">
        <seg>その他の種類(これに限定されるものではないが タイプ自身、関数、&lt;x13/&gt;'missing"&lt;x14/&gt;、&lt;x15/&gt;`nothing"&lt;x15/&gt;のような特別な単一トン、そして日付)などです。 &lt;x17/&gt;Base.broadcastable&lt;x18/&gt;は、&lt;x19/&gt;Ref&lt;x20/&gt;でラップされた引数を返し、0次元として動作します。 ブロードキャストのための「スカラー」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy
encountered when computing with them, see David Goldberg's paper &lt;x1/&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111503Z" creationid="hsugawa8651" creationdate="20181112T111503Z">
        <seg>浮動小数点数と数値精度の問題について、優れた詳細な議論を行うには、次のようにします。 これらを使って計算する際に遭遇するのは、David Goldbergの論文&lt;x1/&gt;What Every計算機科学者Should知っておくべき浮動小数点演算&lt;x2/&gt;を参照することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For direct C++ interfacing, see the &lt;x1/&gt;Cxx&lt;x2/&gt; package.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152645Z" creationid="hsugawa8651" creationdate="20181117T152645Z">
        <seg>直接的なC++インターフェイスの場合は、&lt;x1/&gt;Cxx&lt;x2/&gt;パッケージを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For even more extensive documentation of the history of, rationale for, and issues with floating-point
numbers, as well as discussion of many other topics in numerical computing, see the &lt;x1/&gt;collected writings&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111506Z" creationid="hsugawa8651" creationdate="20181112T111506Z">
        <seg>浮動小数点の履歴、理論的根拠、問題についてさらに広範な文書を作成するには、次の手順を実行します。 数値計算は、数値計算では他の多くのトピックについて議論するだけでなく、&lt;x1/&gt;収集された文書を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example (from
&lt;x11/&gt;base/libc.jl&lt;x12/&gt;) we see the same &lt;x13/&gt;gethostname&lt;x14/&gt;&lt;x15/&gt;`ccall`&lt;x16/&gt; as above, but with the correct
signature for Windows:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152434Z" creationid="hsugawa8651" creationdate="20181117T152434Z">
        <seg>たとえば &lt;x11/&gt;ベース/libc.jl&lt;x12/&gt;は上記と同じように&lt;x13/&gt;gethostname&lt;x15/&gt;`ccall'&lt;x16/&gt;のように見えますが、正しいものは正しいものです。 Windowsのシグニチャ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example &lt;x9/&gt;2^3x&lt;x10/&gt; is parsed as &lt;x11/&gt;2^(3x)&lt;x12/&gt;, and &lt;x13/&gt;2x^3&lt;x14/&gt; is parsed as &lt;x15/&gt;2*(x^3)&lt;x16/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093824Z" creationid="hsugawa8651" creationdate="20181118T093824Z">
        <seg>例えば&lt;x9/&gt;2^3x&lt;x10/&gt;は&lt;x11/&gt;2^(3x)&lt;x12/&gt;と解析され、&lt;x13/&gt;2x^3&lt;x14/&gt;は&lt;x15/&gt;2*(x^3)&lt;x16/&gt;と構文解析される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154603Z" creationid="hsugawa8651" creationdate="20181109T154603Z">
        <seg>たとえば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
&lt;x11/&gt;[1,2,3] ^ 3&lt;x12/&gt; is not defined, since there is no standard
mathematical meaning to "cubing" a (non-square) array, but
&lt;x13/&gt;[1,2,3] .^ 3&lt;x14/&gt; is defined as computing the elementwise
(or "vectorized") result &lt;x15/&gt;[1^3, 2^3, 3^3]&lt;x16/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132451Z" creationid="hsugawa8651" creationdate="20181113T132451Z">
        <seg>たとえば &lt;x11/&gt;[1,2,3]^3&lt;x12/&gt;は定義されていません。これは、標準がないためです。 (非正方形の)配列を"cubing"するための数学的意味はあるが &lt;x13/&gt;[1,2,3].^3&lt;x14/&gt;は、要素を計算するために定義されています。 (または"ベクトル化された")結果&lt;x15/&gt;[1^3 2^3 3^3]&lt;x16/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
the following program, when compiled with &lt;x5/&gt;julia -O3&lt;x6/&gt; generates two SIMD addition instructions
(&lt;x7/&gt;addps&lt;x8/&gt;) on x86 systems:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063653Z" creationid="hsugawa8651" creationdate="20181114T063653Z">
        <seg>たとえば &lt;x5/&gt;julia-O3&lt;x6/&gt;でコンパイルされると、次のプログラムは2つのSIMD付加命令を生成します。 x86システム上での(&lt;x7/&gt;アデプス&lt;x8/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x1/&gt;1&lt;x2/&gt; is an integer literal, while &lt;x3/&gt;1.0&lt;x4/&gt; is a floating-point literal; their binary
in-memory representations as objects are numeric primitives.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225041Z" creationid="hsugawa8651" creationdate="20181109T225041Z">
        <seg>たとえば、&lt;x1/&gt;1&lt;x2/&gt;は整数リテラルであり、&lt;x3/&gt;1.0&lt;x4/&gt;は浮動小数点リテラルであり、それらのバイナリは2進数リテラルです。 メモリー内表現は、数値プリミティブです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x1/&gt;Dict(i =&gt; f(i) for i = 1:10)&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041750Z" creationid="hsugawa8651" creationdate="20181112T041750Z">
        <seg>例えば、&lt;x1/&gt;Dict(i=&gt;f(i=&gt;f(i)for i=1:10)&lt;x2/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x1/&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151238Z" creationid="hsugawa8651" creationdate="20181117T151238Z">
        <seg>例えば、&lt;x1/&gt;f(x::T)は、{T}=ccall(:valid,Ptr{T},(Ptr{T},),x)&lt;x2/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x1/&gt;sum(p[i] - q[i] for i=1:n)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160647Z" creationid="hsugawa8651" creationdate="20181114T160647Z">
        <seg>For example, &lt;x1/&gt;sum(p[i] - q[i] for i=1:n)&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x11/&gt;Any[x, y, z]&lt;x12/&gt; constructs a heterogeneous array that can contain any values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154704Z" creationid="hsugawa8651" creationdate="20181109T154704Z">
        <seg>たとえば、&lt;x11/&gt;任意の[x,y,z]&lt;x12/&gt;は、任意の値を含むことができる異機種間配列を構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x2/&gt;`SparseMatrixCSC`&lt;x3/&gt; from the &lt;x4/&gt;SparseArrays&lt;x5/&gt; standard
library module, only supports two dimensions, so it just defines
&lt;x6/&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083154Z" creationid="hsugawa8651" creationdate="20181113T083154Z">
        <seg>例えば、&lt;x4/&gt;SparseArrays&lt;x5/&gt;の&lt;x4/&gt;は、&lt;x4/&gt;の&lt;x/&gt;から&lt;x/&gt;の範囲である。SparseMatrixCSC ライブラリモジュールは、2つの次元のみをサポートしているため &lt;x6/&gt;getindex(A::SparseMatrixCSC,i::Int,j::Int)&lt;x7/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x5/&gt;0 .&lt; A .&lt; 1&lt;x6/&gt; gives a boolean array whose entries
are true where the corresponding elements of &lt;x7/&gt;A&lt;x8/&gt; are between 0 and 1.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030724Z" creationid="hsugawa8651" creationdate="20181114T030724Z">
        <seg>たとえば、&lt;x5/&gt;0.&lt;A.&lt;1&lt;x6/&gt;は、エントリを入力するブール型配列を示します。 は、&lt;x7/&gt;A&lt;x8/&gt;の対応する要素が0から1の間であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x5/&gt;round(Int,x)&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031052Z" creationid="hsugawa8651" creationdate="20181114T031052Z">
        <seg>たとえば、&lt;x5/&gt;round(Int,x)&lt;x6/&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;x6/&gt;Dict{String,Int32}("A"=&gt;1, "B"=&gt;2)&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041747Z" creationid="hsugawa8651" creationdate="20181112T041747Z">
        <seg>たとえば、&lt;x6/&gt;Dict{String,Int32}("A"=&gt;1, "B"=&gt;2)&lt;x7/&gt;を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Fortran subroutines of the form</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151053Z" creationid="hsugawa8651" creationdate="20181117T151053Z">
        <seg>たとえば、Fortranのサブルーチンは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a module that can display
PNG images in a window can register this capability with Julia, so that calling &lt;x1/&gt;`display(x)`&lt;x2/&gt; on
types with PNG representations will automatically display the image using the module's window.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043307Z" creationid="hsugawa8651" creationdate="20181112T043307Z">
        <seg>たとえば、次のようなモジュールを表示することができます。 ウィンドウ内のPNGイメージは、この機能をJuliaに登録することができます。したがって、&lt;x1/&gt;`display(x)`&lt;x2/&gt;を呼び出すことができます。 PNG表示を持つタイプは、モジュールのウィンドウを使用してイメージを自動的に表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a recursive factorial routine could be defined like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230444Z" creationid="hsugawa8651" creationdate="20181109T230444Z">
        <seg>例えば、再帰階乗ルーチンは、次のように定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a tuple representing an &lt;x1/&gt;__m128&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151308Z" creationid="hsugawa8651" creationdate="20181117T151308Z">
        <seg>例えば、&lt;x1/&gt;__m128&lt;x2/&gt;を表すタプルは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, elements might be computed on request
rather than stored.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160316Z" creationid="hsugawa8651" creationdate="20181109T160316Z">
        <seg>たとえば、要求に基づいて要素を計算することができます。 保存するのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, for &lt;x4/&gt;CUDA&lt;x5/&gt;, we need to be able to read the thread index:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152451Z" creationid="hsugawa8651" creationdate="20181117T152451Z">
        <seg>たとえば、&lt;x4/&gt;CUDA&lt;x5/&gt;の場合は、スレッド・インデックスを読み取る必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if &lt;x1/&gt;A&lt;x2/&gt; is a gigabyte-sized array that you no longer need, you can free the memory
with &lt;x3/&gt;A = nothing&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024646Z" creationid="hsugawa8651" creationdate="20181110T024646Z">
        <seg>たとえば、&lt;x1/&gt;A&lt;x2/&gt;が必要なくなったギガバイトサイズのアレイである場合は、メモリを解放することができます。 &lt;x3/&gt;A=何もありません&lt;x4/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a C library declared a proper string type and returned a pointer to it:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151213Z" creationid="hsugawa8651" creationdate="20181117T151213Z">
        <seg>たとえば、Cライブラリが適切な文字列型を宣言し、そのポインタへのポインタを返した場合、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you compute &lt;x13/&gt;2 .* A.^2 .+ sin.(A)&lt;x14/&gt; (or
equivalently &lt;x15/&gt;@.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132550Z" creationid="hsugawa8651" creationdate="20181113T132550Z">
        <seg>たとえば、&lt;x13/&gt;2.*A.^2.+sin.(A)&lt;x14/&gt;(または 等価的に&lt;x15/&gt;@。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you define &lt;x1/&gt;⊗(A,B) = kron(A,B)&lt;x2/&gt; to give a convenient
infix syntax &lt;x3/&gt;A ⊗ B&lt;x4/&gt; for Kronecker products (&lt;x5/&gt;`kron`&lt;x6/&gt;), then
&lt;x7/&gt;[A,B] .⊗ [C,D]&lt;x8/&gt; will compute &lt;x9/&gt;[A⊗C, B⊗D]&lt;x10/&gt; with no additional coding.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132636Z" creationid="hsugawa8651" creationdate="20181113T132636Z">
        <seg>たとえば、&lt;x1/&gt;(A,B)=kon(A,B)&lt;x2/&gt;を定義して便利な値を指定するとします。 infix syntax&lt;x3/&gt;A∩B&lt;x4/&gt;Kronecker製品の場合(&lt;x5/&gt;kon'&lt;x6/&gt;)、次に &lt;x7/&gt;[A,B].0.23[C,D]&lt;x8/&gt;は、追加符号化なしで&lt;x9/&gt;[AúC]&lt;x10/&gt;を計算する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it enables
accessing the diagonal elements from the first "page" of &lt;x5/&gt;A&lt;x6/&gt; from above:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155653Z" creationid="hsugawa8651" creationdate="20181109T155653Z">
        <seg>たとえば 上からの&lt;x5/&gt;A&lt;x6/&gt;の最初の「ページ」からの対角線要素へのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it is not clear whether &lt;x1/&gt;1.+x&lt;x2/&gt; means &lt;x3/&gt;1.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132644Z" creationid="hsugawa8651" creationdate="20181113T132644Z">
        <seg>例えば、&lt;x1/&gt;1.+x&lt;x2/&gt;が&lt;x3/&gt;1を意味するかどうかは明らかではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, let's say you want to add a constructor method for
&lt;x1/&gt;Foo&lt;x2/&gt; objects that takes only one argument and uses the given value for both the &lt;x3/&gt;bar&lt;x4/&gt; and &lt;x5/&gt;baz&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155710Z" creationid="hsugawa8651" creationdate="20181117T155710Z">
        <seg>たとえば、次のようにコンストラクタメソッドを追加するとします。 &lt;x1/&gt;Foo&lt;x2/&gt;オブジェクトは1つの引数をとり、&lt;x3/&gt;bar&lt;x4/&gt;と&lt;x5/&gt;baz&lt;x6/&gt;の両方で指定された値を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to
the constraint that the first number is not greater than the second one.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155741Z" creationid="hsugawa8651" creationdate="20181117T155741Z">
        <seg>たとえば、実数のペアを保持するタイプを宣言する場合は、次のように指定します。 最初の数値が2番目の数値より大きい制約がないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;x7/&gt;`searchsorted`&lt;x8/&gt; function uses this convention to indicate
the insertion point of a value not found in a sorted array:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155312Z" creationid="hsugawa8651" creationdate="20181109T155312Z">
        <seg>たとえば、&lt;x7/&gt;'のセアルチゾルタド&lt;x8/&gt;関数は、この規則を使用して ソートされた配列に存在しない値の挿入点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the code above will not
work on hosts without AVX support.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151336Z" creationid="hsugawa8651" creationdate="20181117T151336Z">
        <seg>たとえば、上記のコードは AVXサポートのないホストでの作業を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following call:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150602Z" creationid="hsugawa8651" creationdate="20181117T150602Z">
        <seg>たとえば、次の呼び出しを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following definition supports the negation of ranges:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131622Z" creationid="hsugawa8651" creationdate="20181113T131622Z">
        <seg>たとえば、次の定義は範囲の否定をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following expression
sums a series without allocating memory:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154929Z" creationid="hsugawa8651" creationdate="20181109T154929Z">
        <seg>たとえば、次の式を指定します。 は、メモリを割り当てずに連続した値を加算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the result of &lt;x5/&gt;A[2, I, 3]&lt;x6/&gt; is an
array with size &lt;x7/&gt;size(I)&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160817Z" creationid="hsugawa8651" creationdate="20181114T160817Z">
        <seg>たとえば、&lt;x5/&gt;A[2,I,3]&lt;x6/&gt;の結果は size&lt;x7/&gt;サイズ(I)&lt;x8/&gt;の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the sparse array code has the following definitions:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131841Z" creationid="hsugawa8651" creationdate="20181113T131841Z">
        <seg>たとえば、疎な配列コードには次の定義があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there's a formula to compute the sum of squares, so
we can override the generic iterative version with a more performant solution:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112738Z" creationid="hsugawa8651" creationdate="20181112T112738Z">
        <seg>たとえば、2乗の合計を計算するための数式があります。 汎用的な反復バージョンをより効率的なソリューションでオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this is used to convert an &lt;x4/&gt;Array&lt;x5/&gt; of objects (e.g. strings) to an array of pointers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150606Z" creationid="hsugawa8651" creationdate="20181117T150606Z">
        <seg>たとえば、これは、オブジェクトの&lt;x4/&gt;配列&lt;x5/&gt;をポインタの配列に変換するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to call the &lt;x4/&gt;getenv&lt;x5/&gt; function to get a pointer to
the value of an environment variable, one makes a call like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224039Z" creationid="hsugawa8651" creationdate="20181109T224039Z">
        <seg>たとえば、&lt;x4/&gt;getenv&lt;x5/&gt;関数を呼び出してポインタを取得するには、次のように指定します。 環境変数の値は、次のような呼び出しを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to just print the
arguments given to a script, you could do this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092013Z" creationid="hsugawa8651" creationdate="20181109T224341Z">
        <seg>例えば以下のようにすることで、スクリプトに渡された引数を単純に出力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to just print the arguments given to a
script, you could do this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084523Z" creationid="hsugawa8651" creationdate="20181118T084523Z">
        <seg>例えば以下のようにすることで、スクリプトに渡された引数を単純に出力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to match C prototypes of the form:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153924Z" creationid="hsugawa8651" creationdate="20181109T153924Z">
        <seg>たとえば、フォームのCプロトタイプに一致させるには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we could have requested
the result in single precision by writing:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154859Z" creationid="hsugawa8651" creationdate="20181109T154859Z">
        <seg>例えば 以下のように記述することによって、単精度での結果が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, writing &lt;x3/&gt;x += 3&lt;x4/&gt; is equivalent to
writing &lt;x5/&gt;x = x + 3&lt;x6/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132344Z" creationid="hsugawa8651" creationdate="20181113T132344Z">
        <seg>たとえば、&lt;x3/&gt;x+=3&lt;x4/&gt;の書き込みは、次のようになります。 書き込み&lt;x5/&gt;x=x+3&lt;x6/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you might look up the function via &lt;x1/&gt;dlsym&lt;x2/&gt;,
then cache it in a shared reference for that session.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152330Z" creationid="hsugawa8651" creationdate="20181117T152330Z">
        <seg>たとえば、&lt;x1/&gt;dlsym&lt;x2/&gt;を使用して関数を検索することができます。 そのセッションの共有参照にキャッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025044Z" creationid="hsugawa8651" creationdate="20181110T025044Z">
        <seg>次に例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For fun, try inserting a &lt;x9/&gt;println("mycompare($a, $b)")&lt;x10/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150543Z" creationid="hsugawa8651" creationdate="20181117T150543Z">
        <seg>楽しみには、&lt;x9/&gt;println("ミコンパレ($a, $b)")&lt;x10/&gt;を挿入してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For further discussion of how these non-finite floating-point values are ordered with respect
to each other and other floats, see &lt;x1/&gt;Numeric Comparisons&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110845Z" creationid="hsugawa8651" creationdate="20181112T110845Z">
        <seg>これらの非有限浮動小数点値がどのように並べられるかについてのさらなる議論については、次の通りである。 お互いや他のフロートについては、&lt;x1/&gt;数値比較&lt;x2/&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, consider this C routine that uses AVX intrinsics:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151313Z" creationid="hsugawa8651" creationdate="20181117T151313Z">
        <seg>たとえば、AVX組み込み関数を使用するCルーチンは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, we would generally write &lt;x1/&gt;-x + 2&lt;x2/&gt; to reflect that first &lt;x3/&gt;x&lt;x4/&gt; gets negated,
and then &lt;x5/&gt;2&lt;x6/&gt; is added to that result.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132223Z" creationid="hsugawa8651" creationdate="20181113T132223Z">
        <seg>例えば、一般的に&lt;x/&gt;x+2&lt;x2/&gt;を書くと、最初の&lt;x3/&gt;x4/&gt;が否定されることを反映することができます。 その結果、&lt;x5/&gt;2&lt;x6/&gt;が追加されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, when developing C code for use with Julia, one may need to compile,
call the C code from Julia, then close the library, make an edit, recompile,
and load in the new changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152355Z" creationid="hsugawa8651" creationdate="20181117T152355Z">
        <seg>たとえば、Juliaと共に使用するCコードを作成する場合は、コンパイルする必要があります。 Cコードをジュリアから呼び出して、ライブラリを閉じ、編集を行い、再コンパイルします。 新しい変更にロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For large scale numerical problems, speed
always has been, continues to be, and probably always will be crucial:
the amount of data being processed has easily kept pace with Moore’s Law
over the past decades.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082547Z" creationid="hsugawa8651" creationdate="20181118T082547Z">
        <seg>大規模数値計算問題では計算速度はこれまでもこれからも、常に重大な問題です。 処理されるデータ量は過去数十年にわたってムーアの法則にしたがって増え続けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For many types, forming new objects by binding their field values together is all that is ever
needed to create instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155640Z" creationid="hsugawa8651" creationdate="20181117T155640Z">
        <seg>多くのタイプでは、フィールド値を結合することで新しいオブジェクトを作成することは、すべてのタイプであり インスタンスを作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details on defining custom
&lt;x16/&gt;AbstractArray&lt;x17/&gt; implementations, see the &lt;x18/&gt;&lt;x19/&gt;&lt;x20/&gt;(@ref man-interface-array).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160400Z" creationid="hsugawa8651" creationdate="20181109T160400Z">
        <seg>カスタム定義の詳細については &lt;x16/&gt;AbstractArray&lt;x17/&gt;実装を参照してください。&lt;x18/&gt;&lt;x19/&gt;&lt;x20/&gt;(@ref man interface array)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details on how to pass callbacks to C libraries, see this &lt;x1/&gt;blog post&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152640Z" creationid="hsugawa8651" creationdate="20181117T152640Z">
        <seg>Cライブラリへのコールバックを渡す方法の詳細については、この&lt;x1/&gt;ブログ記事&lt;x2/&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details, see &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref writing-binary-broadcasting-rules).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131253Z" creationid="hsugawa8651" creationdate="20181113T131253Z">
        <seg>詳細は、&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref writing binary broadcasting rules)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, please see the &lt;x1/&gt;LLVM Language Reference&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152445Z" creationid="hsugawa8651" creationdate="20181117T152445Z">
        <seg>詳細については、「&lt;x1/&gt;LLVM言語リファレンス&lt;x2/&gt;」を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see
&lt;x8/&gt;&lt;x9/&gt;&lt;x10/&gt;(@ref man-custom-indices).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083421Z" creationid="hsugawa8651" creationdate="20181113T083421Z">
        <seg>詳細については、を参照してください。 &lt;x8/&gt;&lt;x9/&gt;&lt;x10/&gt;(@ref manカスタムインデックス)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For most computational purposes, arrays should contain
objects of a more specific type, such as &lt;x3/&gt;`Float64`&lt;x4/&gt; or &lt;x5/&gt;`Int32`&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064325Z" creationid="hsugawa8651" creationdate="20181109T154148Z">
        <seg>ほとんどの計算目的では、アレイは &lt;x3/&gt;`Float64'&lt;x4/&gt;または&lt;x5/&gt;`Int32/&gt;のようなより特定のタイプのオブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For other types, &lt;x1/&gt;isequal&lt;x2/&gt; defaults to calling &lt;x3/&gt;`==`&lt;x4/&gt;, so if you want to define
equality for your own types then you only need to add a &lt;x5/&gt;`==`&lt;x6/&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030654Z" creationid="hsugawa8651" creationdate="20181114T030654Z">
        <seg>他のタイプについては、&lt;x1/&gt;等価&lt;x2/&gt;はデフォルトで&lt;x3/&gt;==`&lt;x4/&gt;を呼び出しますので、もしあなたがそれを定義する場合には 独自のタイプに対しては、&lt;x5/&gt;'==`&lt;x6/&gt;のメソッドを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For reasons that will
become clear very shortly, additional constructor methods declared as normal methods like this
are called &lt;x1/&gt;outer&lt;x2/&gt; constructor methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155727Z" creationid="hsugawa8651" creationdate="20181117T155727Z">
        <seg>理由は 次のようなコンストラクタメソッドは、ごく短時間で明確になります。 は、&lt;x1/&gt;外部&lt;x2/&gt;コンストラクタ・メソッドと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some types, the machinery to "fuse" operations across nested levels of broadcasting
is not available or could be done more efficiently incrementally.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131558Z" creationid="hsugawa8651" creationdate="20181113T131558Z">
        <seg>ある種のタイプでは、ネストされた放送レベルでの動作を「融合」するための機械が必要です。 は使用できないか、より効率的に段階的に実行される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For specializing broadcast on custom types, see</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150018Z" creationid="hsugawa8651" creationdate="20181117T150018Z">
        <seg>カスタム・タイプでのブロードキャストの特殊化については</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the &lt;x1/&gt;Squares&lt;x2/&gt; iterable above, we can easily compute the &lt;x3/&gt;i&lt;x4/&gt;th element of the sequence by squaring
it.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113043Z" creationid="hsugawa8651" creationdate="20181112T113043Z">
        <seg>上記の&lt;x1/&gt;の2乗&lt;x2/&gt;iterable上では、シーケンスの&lt;x3/&gt;i&lt;x4/&gt;番目の要素を2乗することによって簡単に計算することができます。 そうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the sake of clarity,
let's try a two-way version first:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230122Z" creationid="hsugawa8651" creationdate="20181109T230122Z">
        <seg>わかりやすくするために まず2ウェイのバージョンを試してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For these problems, one needs &lt;x1/&gt;inner&lt;x2/&gt; constructor methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155734Z" creationid="hsugawa8651" creationdate="20181117T155734Z">
        <seg>これらの問題に対しては、&lt;x1/&gt;内部の&lt;x2/&gt;コンストラクタのメソッドが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, &lt;x4/&gt;eval&lt;x5/&gt; is typically only used to form top-level definitions, for example
when wrapping libraries that contain many similar functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152313Z" creationid="hsugawa8651" creationdate="20181117T152313Z">
        <seg>このため、&lt;x4/&gt;eval&lt;x5/&gt;は通常、最上位レベルの定義を形成するためにのみ使用されます。たとえば、次のようになります。 は、多くの類似する関数を含むライブラリをラップするときに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For tools to create C++
bindings, see the &lt;x3/&gt;CxxWrap&lt;x4/&gt; package.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152647Z" creationid="hsugawa8651" creationdate="20181117T152647Z">
        <seg>C++を作成するためのツールについて バインディングは、&lt;x3/&gt;CxxWrap&lt;x4/&gt;パッケージを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For translating a C argument list to Julia:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151502Z" creationid="hsugawa8651" creationdate="20181117T151502Z">
        <seg>C引数リストをJuliaに変換するには、次の手順に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For translating a C return type to Julia:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151754Z" creationid="hsugawa8651" creationdate="20181117T151754Z">
        <seg>Cリターン・タイプをジュリアに変換するには:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortran name</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150849Z" creationid="hsugawa8651" creationdate="20181117T150849Z">
        <seg>Fortran名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, modern language design and compiler techniques
make it possible to mostly eliminate the performance trade-off and
provide a single environment productive enough for prototyping and
efficient enough for deploying performance-intensive applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081421Z" creationid="hsugawa8651" creationdate="20181118T081421Z">
        <seg> 幸い、最近の言語設計やコンパイラの進歩によって、性能の低下を避けつつ、「生産的なプロトタイピング」と「高性能なアプリケーションの効率的なデプロイ」の両方をひとつの環境で提供することが可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fractions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030828Z" creationid="hsugawa8651" creationdate="20181114T030828Z">
        <seg>Fractions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Free and open source (&lt;a0&gt;MIT
licensed&lt;/a0&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082628Z" creationid="hsugawa8651" creationdate="20181118T082628Z">
        <seg>フリーかつオープンソース（ MITライセンス ）
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From these definitions, one obtains the following behavior:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131454Z" creationid="hsugawa8651" creationdate="20181113T131454Z">
        <seg>これらの定義から、次の動作が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From within the function, you cannot "unbind" &lt;x2/&gt;x&lt;x3/&gt; from this Array,
but you can change its content.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025041Z" creationid="hsugawa8651" creationdate="20181110T025041Z">
        <seg>この機能の中からは、この配列から&lt;x2/&gt;x&lt;x3/&gt;の"バインド解除"はできません。 コンテンツを変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fully implemented by:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041624Z" creationid="hsugawa8651" creationdate="20181112T041624Z">
        <seg>Fully implemented by:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134537Z" creationid="hsugawa8651" creationdate="20181117T134537Z">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function arguments themselves act as
new variable &lt;x1/&gt;bindings&lt;x2/&gt; (new locations that can refer to values), but the values they refer to
are identical to the passed values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025708Z" creationid="hsugawa8651" creationdate="20181110T025708Z">
        <seg>関数引数自体は 新しい変数&lt;x1/&gt;バインディング&lt;x2/&gt;(値を参照できる新しい場所)ですが、それらが参照する値は は、渡された値と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are grouped by topic below.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150046Z" creationid="hsugawa8651" creationdate="20181110T041654Z">
        <seg>関数は以下のトピックでグループ化されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, "dotted" updating operators like &lt;x1/&gt;a .+= b&lt;x2/&gt; (or &lt;x3/&gt;@.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132626Z" creationid="hsugawa8651" creationdate="20181113T132626Z">
        <seg>さらに、「ドット」の更新演算子は、&lt;x1/&gt;a.+=b&lt;x2/&gt;(または&lt;x3/&gt;@)のようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Garbage Collection Safety</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152223Z" creationid="hsugawa8651" creationdate="20181117T152223Z">
        <seg>ゴミ回収の安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General Collections</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041620Z" creationid="hsugawa8651" creationdate="20181112T041620Z">
        <seg>General Collections</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General I/O</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043209Z" creationid="hsugawa8651" creationdate="20181112T043209Z">
        <seg>General I/O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General Number Functions and Constants</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044715Z" creationid="hsugawa8651" creationdate="20181112T044715Z">
        <seg>General Number Functions and Constants</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generated functions can achieve high efficiency at run time, but come with a compile time cost:
a new function body must be generated for every combination of concrete argument types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032341Z" creationid="hsugawa8651" creationdate="20181116T032341Z">
        <seg>生成された関数は、実行時に高い効率を実現できますが、コンパイル時にはコストがかかります。 具体的な引数型の組合せごとに、新しい関数本体を生成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generated values can be filtered using the &lt;x1/&gt;if&lt;x2/&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155050Z" creationid="hsugawa8651" creationdate="20181109T155050Z">
        <seg>生成された値は、&lt;x2/&gt;キーワードの場合は&lt;x1/&gt;を使用してフィルタできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generator Expressions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150431Z" creationid="hsugawa8651" creationdate="20181117T150431Z">
        <seg>ジェネレータの式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generators are implemented via inner functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150438Z" creationid="hsugawa8651" creationdate="20181117T150438Z">
        <seg>ジェネレータは内部関数によって実装されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generators are implemented via inner functions. Just like
inner functions used elsewhere in the language, variables from the enclosing scope can be
"captured" in the inner function.  For example, &lt;x1/&gt;sum(p[i] - q[i] for i=1:n)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134820Z" creationid="hsugawa8651" creationdate="20181117T134820Z">
        <seg>ジェネレータは内部機能によって実装されています。 言語で他の場所で使用される内部関数、囲みスコープからの変数は、次のようになります。 "捕獲された"内部関数では、例えば&lt;x1/&gt;sum(p[i]-q[i]for i=1:n)&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a &lt;x1/&gt;Ptr{T}&lt;x2/&gt;, the contents of type &lt;x3/&gt;T&lt;x4/&gt; can generally be copied from the referenced memory
into a Julia object using &lt;x5/&gt;unsafe_load(ptr, [index])&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152527Z" creationid="hsugawa8651" creationdate="20181117T152527Z">
        <seg>&lt;x1/&gt;Ptr{T}&lt;x2/&gt;を与えられると、タイプ&lt;x3/&gt;T&lt;x4/&gt;の内容は、一般的に参照されたメモリからコピーされる。 &lt;x5/&gt;unsafe_load(ptr,[index])&lt;x6/&gt;を使用してジュリアオブジェクトに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a dictionary &lt;x1/&gt;D&lt;x2/&gt;, the syntax &lt;x3/&gt;D[x]&lt;x4/&gt; returns the value of key &lt;x5/&gt;x&lt;x6/&gt; (if it exists) or throws
an error, and &lt;x7/&gt;D[x] = y&lt;x8/&gt; stores the key-value pair &lt;x9/&gt;x =&gt; y&lt;x10/&gt; in &lt;x11/&gt;D&lt;x12/&gt; (replacing any existing value
for the key &lt;x13/&gt;x&lt;x14/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041754Z" creationid="hsugawa8651" creationdate="20181112T041754Z">
        <seg>辞書&lt;x1/&gt;D&lt;x2/&gt;を与えられると、構文&lt;x3/&gt;D[x]&lt;x4/&gt;は、キー&lt;x5/&gt;x&lt;x6/&gt;(存在する場合)の値を返すか、あるいはスローします。 エラーと&lt;x7/&gt;D[x]=y&lt;x8/&gt;は、&lt;x11/&gt;D&lt;x12/&gt;(既存の値を置き換える)の&lt;x9/&gt;x=&gt;y&lt;x10/&gt;のキー値ペアを格納します。 &lt;x13/&gt;x&lt;x14/&gt;x14/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global variables exported by native libraries can be accessed by name using the &lt;x1/&gt;`cglobal`&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152508Z" creationid="hsugawa8651" creationdate="20181117T152508Z">
        <seg>ネイティブライブラリによってエクスポートされたグローバル変数は、&lt;x1/&gt;`cglobal`&lt;x2/&gt;を使用して名前によってアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good performance, approaching that of statically-compiled languages
like C</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082137Z" creationid="hsugawa8651" creationdate="20181118T082137Z">
        <seg>Cのような静的コンパイル言語に迫る性能を実現します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-precision floating-point numbers are also supported (&lt;x1/&gt;`Float16`&lt;x2/&gt;), but they are
implemented in software and use &lt;x3/&gt;`Float32`&lt;x4/&gt; for calculations.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093705Z" creationid="hsugawa8651" creationdate="20181118T093705Z">
        <seg>半精度浮動小数点数もサポートされている(&lt;x1/&gt;`Float16'&lt;x2/&gt;)が、これらの浮動小数点数は次のようになります。 ソフトウェアで実装され、&lt;x3/&gt;"Float32"&lt;x4/&gt;を使用して計算に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HasEltype()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112145Z" creationid="hsugawa8651" creationdate="20181112T112145Z">
        <seg>HasEltype()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HasLength()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112122Z" creationid="hsugawa8651" creationdate="20181112T112122Z">
        <seg>HasLength()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, expressions starting with a numeric literal
followed by &lt;x9/&gt;F&lt;x10/&gt; are interpreted as the numerical literal multiplied by a variable, which means that, for
example, &lt;x11/&gt;1.5F22&lt;x12/&gt; is equal to &lt;x13/&gt;1.5 * F22&lt;x14/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111954Z" creationid="hsugawa8651" creationdate="20181112T111954Z">
        <seg>したがって、数値リテラルで始まる式 続いて&lt;x9/&gt;F&lt;x10/&gt;は、数値的リテラル乗算された数値を変数で乗算したものと解釈されます。これは 例:&lt;x11/&gt;1F22&lt;x12/&gt;は、&lt;x13/&gt;1.5*F22&lt;x14/&gt;と等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples to demonstrate which type of arrays are strided and which are not:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083514Z" creationid="hsugawa8651" creationdate="20181113T083514Z">
        <seg>ここでは、どのタイプのアレイがストローブされていて、どのタイプがストライドされていないかを示す例をいくつか示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples with bitwise operators:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132327Z" creationid="hsugawa8651" creationdate="20181113T132327Z">
        <seg>ビット演算子の例を次に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some simple examples using arithmetic operators:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132210Z" creationid="hsugawa8651" creationdate="20181113T132210Z">
        <seg>次に、算術演算子を使用する簡単な例をいくつか示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some simple examples:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030450Z" creationid="hsugawa8651" creationdate="20181114T030450Z">
        <seg>簡単な例を次に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some situations
where syntactic conflicts arise:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111920Z" creationid="hsugawa8651" creationdate="20181112T111920Z">
        <seg>次に状況を示します。 構文的な競合が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a second example wrapping the corresponding destructor:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152058Z" creationid="hsugawa8651" creationdate="20181117T152058Z">
        <seg>次に、対応するデストラクタをラップする2番目の例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a simple example of a C wrapper that returns a &lt;x1/&gt;Ptr&lt;x2/&gt; type:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151909Z" creationid="hsugawa8651" creationdate="20181117T151909Z">
        <seg>ここでは、&lt;x1/&gt;Ptr&lt;x2/&gt;型を返すCラッパーの簡単な例を次に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a slightly more complex example that discovers the local machine's hostname:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133838Z" creationid="hsugawa8651" creationdate="20181117T133838Z">
        <seg>ここでは、ローカルマシンのホスト名を検出するもう少し複雑な例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a third example passing Julia arrays:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152146Z" creationid="hsugawa8651" creationdate="20181117T152146Z">
        <seg>次に、Julia配列を渡す3番目の例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the anatomy of the &lt;x1/&gt;if&lt;x2/&gt;-&lt;x3/&gt;elseif&lt;x4/&gt;-&lt;x5/&gt;else&lt;x6/&gt; conditional syntax:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225837Z" creationid="hsugawa8651" creationdate="20181109T225837Z">
        <seg>&lt;x2/&gt;-&lt;x3/&gt;elseif&lt;x4/&gt;-&lt;x5/&gt;else&lt;x6/&gt;条件付き構文:&lt;x6/&gt;の場合の解剖学的構造は以下の通りである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here it is in action:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225850Z" creationid="hsugawa8651" creationdate="20181109T225850Z">
        <seg>ここでは次の操作を実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the zero-argument constructor method calls the single-argument constructor method, which
in turn calls the automatically provided two-argument constructor method.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155724Z" creationid="hsugawa8651" creationdate="20181117T155724Z">
        <seg>ここでは、0つの引数コンストラクタメソッドは、単一引数コンストラクタメソッドを呼び出します。 は自動的に提供された2引数コンストラクタメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we created a function &lt;x1/&gt;change_array!&lt;x2/&gt;, that assigns &lt;x3/&gt;5&lt;x4/&gt; to the first element of the passed
array (bound to &lt;x5/&gt;x&lt;x6/&gt; at the call site, and bound to &lt;x7/&gt;A&lt;x8/&gt; within the function).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025123Z" creationid="hsugawa8651" creationdate="20181110T025123Z">
        <seg>ここでは、渡された第1の要素に&lt;x3/&gt;5&lt;x4/&gt;を割り当てる関数&lt;x1/&gt;change_array!&lt;x2/&gt;を作成しました。 array(&lt;x5/&gt;x&lt;x6/&gt;at the call site,and bound to the function in the function内で&lt;x7/&gt;A&lt;x8/&gt;にバインドされます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of a &lt;x5/&gt;begin&lt;x6/&gt; block:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225802Z" creationid="hsugawa8651" creationdate="20181109T225802Z">
        <seg>&lt;x5/&gt;begin&lt;x6/&gt;ブロックの例を次に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, &lt;x1/&gt;(2, 3)&lt;x2/&gt; is a &lt;x3/&gt;`Tuple`&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154539Z" creationid="hsugawa8651" creationdate="20181109T154539Z">
        <seg>ここで、&lt;x1/&gt;(2, 3)&lt;x2/&gt;は、&lt;x3/&gt;「タプル」&lt;x4/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, for example, is another attempt
at defining the &lt;x3/&gt;SelfReferential&lt;x4/&gt; type, this time using a zero-argument inner constructor returning instances
having &lt;x5/&gt;obj&lt;x6/&gt; fields pointing to themselves:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155902Z" creationid="hsugawa8651" creationdate="20181117T155902Z">
        <seg>ここでは、別の試みを行います。 &lt;x3/&gt;SelfReferential&lt;x4/&gt;タイプを定義する際には、0つの引数内部コンストラクタを使用してインスタンスを返します。 &lt;x5/&gt;obj&lt;x6/&gt;フィールドが自分自身を指していることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the input &lt;x1/&gt;p&lt;x2/&gt; is declared to be of type &lt;x3/&gt;Ref{gsl_permutation}&lt;x4/&gt;, meaning that the memory
that &lt;x5/&gt;p&lt;x6/&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should
be of type &lt;x7/&gt;Ptr{gsl_permutation}&lt;x8/&gt;, but it is convertible using &lt;x9/&gt;`Base.cconvert`&lt;x10/&gt; and therefore
can be used in the same (covariant) context of the input argument to a &lt;x11/&gt;`ccall`&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152108Z" creationid="hsugawa8651" creationdate="20181117T152108Z">
        <seg>ここで、入力&lt;x1/&gt;p&lt;x2/&gt;は、タイプ&lt;x3/&gt;Ref{gsl_mutation}&lt;x4/&gt;であることを宣言され、メモリは、メモリを意味する。 &lt;x5/&gt;p&lt;x6/&gt;は、ジュリアまたはC.Aポインタによって割り当てられたメモリへのC.Aポインタによって管理されることがあります。 &lt;x7/&gt;Ptr{gsl mutation}&lt;x8/&gt;であるが、&lt;x9/&gt;'Base.チコンベルト'&lt;x10/&gt;を用いて変換することができ、したがって は、&lt;x11/&gt;`ccall'&lt;x12/&gt;への入力引数の同じ(共変)コンテキストで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hexadecimal floating-point literals are also valid, but only as &lt;x1/&gt;`Float64`&lt;x2/&gt; values,
with &lt;x3/&gt;p&lt;x4/&gt; preceding the base-2 exponent:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110630Z" creationid="hsugawa8651" creationdate="20181112T110630Z">
        <seg>16進数浮動小数点リテラルは有効であるが、&lt;x1/&gt;'Float64&lt;x2/&gt;の値としてのみ有効である。 &lt;x3/&gt;p&lt;x4/&gt;は、ベース2指数の前にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How can I modify the declaration of a type in my session?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024709Z" creationid="hsugawa8651" creationdate="20181110T024709Z">
        <seg>セッション内のタイプの宣言を変更するにはどうすればよいですか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How do I catch CTRL-C in a script?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024903Z" creationid="hsugawa8651" creationdate="20181110T024903Z">
        <seg>スクリプトでCTRL-Cを取得するにはどうすればよいですか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How do I check if the current file is being run as the main script?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024829Z" creationid="hsugawa8651" creationdate="20181110T024829Z">
        <seg>メインスクリプトとして現在のファイルが実行されているかどうかを確認するにはどうすればよいですか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How do I pass options to &lt;x1/&gt;julia&lt;x2/&gt; using &lt;x3/&gt;&lt;x4/&gt;!/usr/bin/env&lt;x5/&gt;?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024917Z" creationid="hsugawa8651" creationdate="20181110T024917Z">
        <seg>&lt;x3/&gt;&lt;x4/&gt;!/usr/bin/env&lt;x5/&gt;?を使用して、&lt;x1/&gt;ジュリア&lt;x2/&gt;にオプションを渡す方法を教えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How this distinction works is determined by environments, as explained in the following sections.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152910Z" creationid="hsugawa8651" creationdate="20181117T152910Z">
        <seg>この区別の仕組みは、次のセクションで説明するように、環境によって決まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However,
even for immutable structs it will not cause any harm for called functions to attempt such modifications
(that is, writing through the passed pointers).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151856Z" creationid="hsugawa8651" creationdate="20181117T151856Z">
        <seg>しかし 不変構造体でさえ、呼び出された関数がこのような修正を試みることを妨げることはないでしょう。 (つまり、渡されたポインタを通して書くこと)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, all the information we need for the loop is embedded in the type information of the arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032307Z" creationid="hsugawa8651" creationdate="20181116T032307Z">
        <seg>しかし、ループに必要なすべての情報は、引数の型情報に埋め込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, any concrete &lt;x3/&gt;AbstractArray{T,N}&lt;x4/&gt; type should generally implement
at least &lt;x5/&gt;`size(A)`&lt;x6/&gt; (returning an &lt;x7/&gt;Int&lt;x8/&gt; tuple), &lt;x9/&gt;`getindex(A,i)`&lt;x10/&gt; and &lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;(@ref getindex);
mutable arrays should also implement &lt;x14/&gt;`setindex!`&lt;x15/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160320Z" creationid="hsugawa8651" creationdate="20181109T160320Z">
        <seg>しかし、具体的な&lt;x3/&gt;AbstractArray{T,N}&lt;x4/&gt;型は、一般的には実装されるべきである。 &lt;x5/&gt;'size(A)'&lt;x6/&gt;(return an&lt;x7/&gt;Int&lt;x8/&gt;タプルを返す)&lt;x9/&gt;`getindex(A,i)`&lt;x10/&gt;&lt;x13/&gt;&lt;x13/&gt;&lt;x13/&gt;&lt;x13/&gt;(@ref getindex); mutable配列は、&lt;x14/&gt;`setindex!`&lt;x15/&gt;を実装する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152317Z" creationid="hsugawa8651" creationdate="20181117T152317Z">
        <seg>しかし、これは非常に低速でリークメモリもあるので、通常はこれを避けてから、読み続けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if needed you can specialize on any or all of these arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131338Z" creationid="hsugawa8651" creationdate="20181113T131338Z">
        <seg>ただし、必要に応じて、これらの引数のいずれかまたはすべてを専門にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in some cases more functionality is required when
creating composite objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155642Z" creationid="hsugawa8651" creationdate="20181117T155642Z">
        <seg>ただし、場合によっては、次のような機能が必要になります。 合成オブジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is possible
to use computed values as function names by staging through &lt;x3/&gt;`eval`&lt;x4/&gt; as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152302Z" creationid="hsugawa8651" creationdate="20181117T152302Z">
        <seg>しかし、それは可能である。 次のように&lt;x3/&gt;'eval'&lt;x4/&gt;を通してステージングすることによって関数名として計算された値を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, numeric literal coefficients parse similarly to unary operators when
combined with exponentiation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111803Z" creationid="hsugawa8651" creationdate="20181112T111803Z">
        <seg>しかし、数値リテラル係数は、次のように単項演算子と同じように解析されます。 指数関数と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since the automatic vectorization cannot be relied upon, future use will mostly be via
libraries that use &lt;x1/&gt;llvmcall&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063702Z" creationid="hsugawa8651" creationdate="20181114T063702Z">
        <seg>However, since the automatic vectorization cannot be relied upon, future use will mostly be via
libraries that use &lt;x1/&gt;llvmcall&lt;x2/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the fallback methods for &lt;x26/&gt;+(a, b, c, d...)&lt;x27/&gt; and &lt;x28/&gt;*(a, b, c, d...)&lt;x29/&gt; both default to left-associative evaluation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030947Z" creationid="hsugawa8651" creationdate="20181114T030947Z">
        <seg>ただし、&lt;x26/&gt;+(a, b, c, d...)&lt;x27/&gt;および&lt;x28/&gt;*(a, b, c, d...)&lt;x29/&gt;両方のフォールバック方法は、デフォルトでは左連想評価に使用されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the manner in which this rounding is done can be
changed if required according to the rounding modes presented in the &lt;x1/&gt;IEEE 754
standard&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093746Z" creationid="hsugawa8651" creationdate="20181118T093746Z">
        <seg>しかし、この丸めが行われる方法は &lt;x1/&gt;IEEE754で提示された丸めモードに従って必要に応じて変更された 標準的な&lt;x2/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the order of evaluations in a chained
comparison is undefined.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030738Z" creationid="hsugawa8651" creationdate="20181114T030738Z">
        <seg>しかし、連鎖的な評価の順序は 比較は未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these subtleties are described in detail in
most books on scientific computation, and also in the following references:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111444Z" creationid="hsugawa8651" creationdate="20181112T111444Z">
        <seg>しかし、これらの微妙な点については、以下で詳細に説明します。 科学的計算に関する本や、以下の参考文献にもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when depending
on this behavior, make sure all possible code paths define a value for the variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225955Z" creationid="hsugawa8651" creationdate="20181109T225955Z">
        <seg>ただし この動作では、可能なすべてのコード・パスが変数の値を定義していることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, which implementation is used depends on compiler implementation details, so it
is essential for the two implementations to behave identically.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032421Z" creationid="hsugawa8651" creationdate="20181116T032421Z">
        <seg>しかし、どの実装が使用されるのかは、コンパイラの実装の詳細に依存します。 2つの実装が同じように動作するためには必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, while the type layout must be known statically to compute the intended C ABI,
the static parameters of the function are considered to be part of this static environment.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151232Z" creationid="hsugawa8651" creationdate="20181117T151232Z">
        <seg>しかし、意図されたC ABIを計算するためには、タイプレイアウトは静的に認識される必要があります。 関数の静的パラメータは、この静的環境の一部であると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can create variables with names:
&lt;x7/&gt;abstract&lt;x8/&gt;, &lt;x9/&gt;mutable&lt;x10/&gt;, &lt;x11/&gt;primitive&lt;x12/&gt; and &lt;x13/&gt;type&lt;x14/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041759Z" creationid="hsugawa8651" creationdate="20181110T041759Z">
        <seg>ただし、名前を使用して変数を作成することはできます。 &lt;x7/&gt;抽象&lt;x8/&gt;,&lt;x9/&gt;mutable&lt;x10/&gt;,&lt;x11/&gt;プリミティブ&lt;x12/&gt;,&lt;x13/&gt;&lt;x14/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I passed an argument &lt;x1/&gt;x&lt;x2/&gt; to a function, modified it inside that function, but on the outside, the variable &lt;x3/&gt;x&lt;x4/&gt; is still unchanged.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024952Z" creationid="hsugawa8651" creationdate="20181110T024952Z">
        <seg>関数に対して引数&lt;x1/&gt;x2/&gt;を渡したが、その関数内で修正されたが、外側では変数&lt;x3/&gt;x&lt;x4/&gt;は変更されないままであった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I/O and Network</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043208Z" creationid="hsugawa8651" creationdate="20181112T043208Z">
        <seg>I/O and Network</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INTEGER*2&lt;x1/&gt;, &lt;x2/&gt;LOGICAL*2&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150909Z" creationid="hsugawa8651" creationdate="20181117T150909Z">
        <seg>INTEGER*2&lt;x1/&gt;, &lt;x2/&gt;LOGICAL*2&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;A&lt;x2/&gt; is an &lt;x3/&gt;AbstractArray{T,0}&lt;x4/&gt;, this should return an empty tuple.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094601Z" creationid="hsugawa8651" creationdate="20181118T094601Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;が&lt;x3/&gt;AbstractArray{T,0}&lt;x4/&gt;である場合、この値は空のタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;I_1&lt;x2/&gt; is changed to a two-dimensional matrix, then &lt;x3/&gt;X&lt;x4/&gt; becomes an &lt;x5/&gt;n+1&lt;x6/&gt;-dimensional array of
shape &lt;x7/&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160908Z" creationid="hsugawa8651" creationdate="20181114T160908Z">
        <seg>&lt;x1/&gt;I_1&lt;x2/&gt;が2次元マトリクスに変化すると、&lt;x3/&gt;X&lt;x4/&gt;は&lt;x5/&gt;n+1&lt;x6/&gt;次元配列となる。 形状&lt;x7/&gt;(サイズ(I_1 1)、サイズ(I_1 2)、長さ(I_2)、.…、長さ(I_n))&lt;x8/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;I_1&lt;x2/&gt; is changed to a two-dimensional matrix, then &lt;x3/&gt;X&lt;x4/&gt; becomes an &lt;x5/&gt;n+1&lt;x6/&gt;-dimensional array of
shape &lt;x7/&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;x8/&gt;. The matrix adds a dimension.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134835Z" creationid="hsugawa8651" creationdate="20181117T134835Z">
        <seg>&lt;x1/&gt;I_1&lt;x2/&gt;が2次元マトリクスに変化すると、&lt;x3/&gt;X&lt;x4/&gt;は&lt;x5/&gt;n+1&lt;x6/&gt;次元配列となる。 形状&lt;x7/&gt;(サイズ(I_1 1)、サイズ(I_1 2)、長さ(I_2)、…、長さ(I_n))&lt;x8/&gt;。マトリックスは次元を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;T&lt;x2/&gt; is &lt;x3/&gt;Any&lt;x4/&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;x5/&gt;jl_value_t*&lt;x6/&gt;),
the result will be a reference to this object, and the object will not be copied.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152538Z" creationid="hsugawa8651" creationdate="20181117T152538Z">
        <seg>&lt;x1/&gt;T&lt;x2/&gt;が&lt;x3/&gt;であれば、メモリはジュリアオブジェクトへの参照を含むものと仮定します(&lt;x5/&gt;jl_value_t*&lt;x6/&gt;)。 結果はこのオブジェクトへの参照になり、オブジェクトはコピーされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;T&lt;x2/&gt; is a floating-point type, the result is the nearest representable value, which could be
positive or negative infinity.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031034Z" creationid="hsugawa8651" creationdate="20181114T031034Z">
        <seg>&lt;x1/&gt;T&lt;x2/&gt;が浮動小数点型である場合、その結果は最も近い表現可能な値となり 正または負の無限大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;T&lt;x2/&gt; is an integer type, an &lt;x3/&gt;InexactError&lt;x4/&gt; is raised if &lt;x5/&gt;x&lt;x6/&gt; is not representable by &lt;x7/&gt;T&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031036Z" creationid="hsugawa8651" creationdate="20181114T031036Z">
        <seg>&lt;x1/&gt;T&lt;x2/&gt;が整数の場合、&lt;x5/&gt;x&lt;x6/&gt;が&lt;x7/&gt;T&lt;x8/&gt;で表されない場合、&lt;x3/&gt;InexactError&lt;x4/&gt;が生成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;X&lt;x2/&gt; is an array, it must have the same number of elements as the product of the lengths of
the indices: &lt;x3/&gt;prod(length(I_1), length(I_2), ..., length(I_n))&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155408Z" creationid="hsugawa8651" creationdate="20181109T155408Z">
        <seg>&lt;x1/&gt;X&lt;x2/&gt;が配列である場合、それは長さの積と同じ数の要素を持つ必要があります。 インデックス:&lt;x3/&gt;prod(長さ(I_1),長さ(I_2),…,長さ(I_n))&lt;x4/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;X&lt;x2/&gt; is an array, it must have the same number of elements as the product of the lengths of
the indices: &lt;x3/&gt;prod(length(I_1), length(I_2), ..., length(I_n))&lt;x4/&gt;. The value in location &lt;x5/&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134924Z" creationid="hsugawa8651" creationdate="20181117T134924Z">
        <seg>&lt;x1/&gt;X&lt;x2/&gt;が配列である場合、それは長さの積と同じ数の要素を持つ必要があります。 インデックス:&lt;x3/&gt;prod(長さI_1)、長さ(I_2)、…、長さ(I_n)&lt;x4/&gt;。位置&lt;x5/&gt;I_1[i_1]の値、I_2[i_2]、.…、I_n[i_n]&lt;x6/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x1/&gt;a&lt;x2/&gt; is an instance of &lt;x3/&gt;SelfReferential&lt;x4/&gt;, then a second instance can be created by the call:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155847Z" creationid="hsugawa8651" creationdate="20181117T155847Z">
        <seg>&lt;x1/&gt;a&lt;x2/&gt;が&lt;x3/&gt;SelfReferential&lt;x4/&gt;のインスタンスである場合は、次のように呼び出しによって2番目のインスタンスを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x10/&gt;include("source.jl")&lt;x11/&gt; is called multiple times, &lt;x12/&gt;source.jl&lt;x13/&gt; is evaluated multiple times.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152704Z" creationid="hsugawa8651" creationdate="20181117T152704Z">
        <seg>&lt;x10/&gt;が("source.jl")を含む場合、&lt;x11/&gt;は複数回呼び出されます。&lt;x12/&gt;source.jl&lt;x13/&gt;は複数回評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x2/&gt;X&lt;x3/&gt; is a subdirectory of a package directory and &lt;x4/&gt;X/src/X.jl&lt;x5/&gt; exists, then the package &lt;x6/&gt;X&lt;x7/&gt; is available in the package directory environment and &lt;x8/&gt;X/src/X.jl&lt;x9/&gt; is the source file by which it is loaded.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152928Z" creationid="hsugawa8651" creationdate="20181117T152928Z">
        <seg>&lt;x2/&gt;X&lt;x3/&gt;がパッケージディレクトリのサブディレクトリであり、&lt;x4/&gt;X/src/X.jl&lt;x5/&gt;が存在する場合、パッケージ&lt;x6/&gt;X&lt;x7/&gt;は、パッケージディレクトリ環境で使用可能であり、&lt;x8/&gt;X/src/X.jl&lt;x9/&gt;は、それがロードされるソースファイルである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x4/&gt;X&lt;x5/&gt; is not an array, its value
is written to all referenced locations of &lt;x6/&gt;A&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155420Z" creationid="hsugawa8651" creationdate="20181109T155420Z">
        <seg>&lt;x4/&gt;X&lt;x5/&gt;が配列でない場合は、その値は は、&lt;x6/&gt;A&lt;x7/&gt;の参照されたすべての場所に書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;x8/&gt;Ptr{Cdouble}&lt;x9/&gt; were used instead, the &lt;x10/&gt;`ccall`&lt;x11/&gt; may still work, but Julia's garbage
collector would not be aware that the memory declared for &lt;x12/&gt;result_array&lt;x13/&gt; is being used by the
external C function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152217Z" creationid="hsugawa8651" creationdate="20181117T152217Z">
        <seg>もし&lt;x8/&gt;Ptr{Cdouble}&lt;x9/&gt;が代わりに使われたとしたら、&lt;x10/&gt;`ccall'&lt;x11/&gt;は依然として動作しますが、ジュリアのゴミはまだ動作していません。 コレクタは、&lt;x12/&gt;result_array&lt;x13/&gt;のために宣言されたメモリが使用されていないことを認識しません。 外部C関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding
Julia type is a homogeneous tuple of &lt;x1/&gt;VecElement&lt;x2/&gt; that naturally maps to the SIMD type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151252Z" creationid="hsugawa8651" creationdate="20181117T151252Z">
        <seg>C/C++ルーチンに、ネイティブSIMD型の引数または戻り値がある場合は、対応する Julia型は、自然にSIMD型にマッピングされる&lt;x1/&gt;VecElement&lt;x2/&gt;の同種のタプルである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a function argument name is written as a tuple (e.g. &lt;x1/&gt;(x, y)&lt;x2/&gt;) instead of just
a symbol, then an assignment &lt;x3/&gt;(x, y) = argument&lt;x4/&gt; will be inserted for you:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101540Z" creationid="hsugawa8651" creationdate="20181112T101540Z">
        <seg>関数引数の名前がタプル(例えば&lt;x1/&gt;(x, y)&lt;x2/&gt;)ではなく、タプルとして記述されている場合 次に、割り当て&lt;x3/&gt;(x, y)=引数&lt;x4/&gt;が挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a number doesn't have an exact floating-point representation, it must be rounded to an
appropriate representable value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093739Z" creationid="hsugawa8651" creationdate="20181118T093739Z">
        <seg>数値が正確な浮動小数点表現を持たない場合は、次のように丸めます。 適切な表現可能な値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a pointer conversion method &lt;x19/&gt;`Base.unsafe_convert(Ptr{T}, A)`&lt;x20/&gt; is
provided, the memory layout must correspond in the same way to these strides.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160506Z" creationid="hsugawa8651" creationdate="20181109T160506Z">
        <seg>ポインタ変換方法&lt;x19/&gt;`Base.unsafe_convert(Ptr{T},A)`&lt;x20/&gt;がある場合 この場合、メモリレイアウトは、これらの進歩と同じ方法で対応する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a type is defined as a subtype of &lt;x1/&gt;AbstractArray&lt;x2/&gt;, it inherits a very large set of rich behaviors
including iteration and multidimensional indexing built on top of single-element access.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022653Z" creationid="hsugawa8651" creationdate="20181113T022653Z">
        <seg>もしタイプが&lt;x1/&gt;AbstractArray&lt;x2/&gt;のサブタイプとして定義されるなら、それは非常に大きな一連の豊かな振る舞いを継承する。 単一要素アクセスの上に構築された反復と多次元索引付けを含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all
arguments have a common &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref conversion-and-promotion) then they get
converted to that type using &lt;x6/&gt;`convert`&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154521Z" creationid="hsugawa8651" creationdate="20181109T154521Z">
        <seg>すべて 引数には共通の&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref変換とプロモーション)があります。 &lt;x6/&gt;'convert`&lt;x7/&gt;を使用して、そのタイプに変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all indices are vectors, for example, then the shape of &lt;x1/&gt;X&lt;x2/&gt; would be &lt;x3/&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;x4/&gt;,
with location &lt;x5/&gt;(i_1, i_2, ..., i_n)&lt;x6/&gt; of &lt;x7/&gt;X&lt;x8/&gt; containing the value &lt;x9/&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;x10/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155134Z" creationid="hsugawa8651" creationdate="20181109T155134Z">
        <seg>例えば、すべてのインデックスがベクトルである場合、&lt;x1/&gt;X&lt;x2/&gt;の形状は&lt;x3/&gt;(長さI_1)、長さ(I_2)、…、長さ(I_n)&lt;x4/&gt;である。 位置&lt;x5/&gt;(i_1,i_2,.…i_n)&lt;x7/&gt;X&lt;x8/&gt;の値&lt;x9/&gt;A[I_1[i_1],I_2[i_2],.…,I_n[i_n]]&lt;x10/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all the indices are scalars, then the result &lt;x1/&gt;X&lt;x2/&gt; is a single element from the array &lt;x3/&gt;A&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155128Z" creationid="hsugawa8651" creationdate="20181109T155128Z">
        <seg>すべての指標がスカラーである場合、結果&lt;x1/&gt;X&lt;x2/&gt;は、配列&lt;x3/&gt;A&lt;x4/&gt;からの単一要素である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all the indices are scalars, then the result &lt;x1/&gt;X&lt;x2/&gt; is a single element from the array &lt;x3/&gt;A&lt;x4/&gt;. Otherwise,
&lt;x5/&gt;X&lt;x6/&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the
indices.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134829Z" creationid="hsugawa8651" creationdate="20181117T134829Z">
        <seg>すべてのインデックスがスカラーである場合、結果&lt;x1/&gt;X&lt;x2/&gt;は、配列&lt;x3/&gt;A&lt;x4/&gt;からの単一要素である。それ以外の場合は &lt;x5/&gt;x&lt;x6/&gt;は、すべての次元の次元性の合計と同じ数の次元を持つ配列です。 索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an array of eltype &lt;x1/&gt;Ptr{T}&lt;x2/&gt; is passed as a &lt;x3/&gt;Ptr{Ptr{T}}&lt;x4/&gt; argument, &lt;x5/&gt;`Base.cconvert`&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T140903Z" creationid="hsugawa8651" creationdate="20181117T140903Z">
        <seg>エルテープ&lt;x1/&gt;Ptr{T}&lt;x2/&gt;の配列が&lt;x3/&gt;Ptr{Ptr{T}}&lt;x4/&gt;引数として渡された場合、&lt;x5/&gt;'Base.チコンベルト'&lt;x6/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an expression is entered into an interactive
session with a trailing semicolon, its value is not shown.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091458Z" creationid="hsugawa8651" creationdate="20181109T224315Z">
        <seg>式の後ろにセミコロンをつけて入力すると、値は表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an expression is entered into an interactive session
with a trailing semicolon, its value is not shown.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083934Z" creationid="hsugawa8651" creationdate="20181118T083934Z">
        <seg>式の後ろにセミコロンをつけて入力すると、値は表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any inner constructor method is defined, no default constructor method is provided: it is presumed
that you have supplied yourself with all the inner constructors you need.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155806Z" creationid="hsugawa8651" creationdate="20181117T155806Z">
        <seg>内部コンストラクタメソッドが定義されている場合は、デフォルトのコンストラクタメソッドは提供されません。これは 必要なすべてのインナー・コンストラクターを自分で提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead you want to specialize on the destination type &lt;x1/&gt;DestType&lt;x2/&gt; without specializing
on &lt;x3/&gt;DestStyle&lt;x4/&gt;, then you should define a method with the following signature:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131655Z" creationid="hsugawa8651" creationdate="20181113T131655Z">
        <seg>その代わりに、宛先タイプ&lt;x1/&gt;DestType&lt;x2/&gt;に特化する必要はありません。 &lt;x3/&gt;DestStyle&lt;x4/&gt;では、次のシグニチャを使用してメソッドを定義する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If memory usage is your concern, you can always replace objects with ones that consume less memory.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024641Z" creationid="hsugawa8651" creationdate="20181110T024641Z">
        <seg>メモリ使用量が問題になる場合は、常にメモリを消費するオブジェクトを使用してオブジェクトを置き換えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If needed, the sorting algorithm can be chosen:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150316Z" creationid="hsugawa8651" creationdate="20181117T150316Z">
        <seg>必要に応じて、ソート・アルゴリズムを選択できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If proper finalization of &lt;x13/&gt;a&lt;x14/&gt; depends on &lt;x15/&gt;b&lt;x16/&gt; being valid,
it must be handled in other ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152255Z" creationid="hsugawa8651" creationdate="20181117T152255Z">
        <seg>&lt;x13/&gt;a&lt;x14/&gt;の適切なファイナライズは、&lt;x15/&gt;b&lt;x16/&gt;が有効であることによって異なります。 他の方法で処理する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If side effects are required, the short-circuit &lt;x3/&gt;&amp;&amp;&lt;x4/&gt; operator
should be used explicitly (see &lt;x5/&gt;Short-Circuit Evaluation&lt;x6/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030751Z" creationid="hsugawa8651" creationdate="20181114T030751Z">
        <seg>副作用が必要な場合は、短絡&lt;x3/&gt;&amp;&amp;&lt;x4/&gt;演算子を使用します。 明示的に使用する必要があります(&lt;x5/&gt;Short-Term Evaluation&lt;x6/&gt;を参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
&lt;x4/&gt;own&lt;x5/&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until
all access is complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152611Z" creationid="hsugawa8651" creationdate="20181117T152611Z">
        <seg>の &lt;x4/&gt;独自の&lt;x5/&gt;パラメータは省略されるか、またはfalseであるため、呼び出し側はバッファが存在しないことを確認する必要があります。 すべてのアクセスが完了しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;x7/&gt;Ptr&lt;x8/&gt; itself is actually a &lt;x9/&gt;jl_value_t*&lt;x10/&gt;, it can be converted
back to a Julia object reference by &lt;x11/&gt;`unsafe_pointer_to_objref(ptr)`&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152546Z" creationid="hsugawa8651" creationdate="20181117T152546Z">
        <seg>&lt;x7/&gt;Ptr&lt;x8/&gt;自身が実際に&lt;x9/&gt;jl_value_t*&lt;x10/&gt;である場合、それは変換されることができる。 &lt;x11/&gt;`unsafe_pointer_to_objref(ptr)`&lt;x12/&gt;でJuliaオブジェクト参照に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using
&lt;x1/&gt;p::Ptr{gsl_permutation}&lt;x2/&gt; for the method signature of the wrapper and similarly in the &lt;x3/&gt;`ccall`&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152144Z" creationid="hsugawa8651" creationdate="20181117T152144Z">
        <seg>Cラッパーが、ユーザーがジュリアによって管理されたメモリーへのポインタを渡すことを予期しない場合は &lt;x1/&gt;p::Ptr{gsl mutations}&lt;x2/&gt;ラッパーの方が、同様に&lt;x3/&gt;の"ccall"&lt;x4/&gt;においても同様である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the expression &lt;x1/&gt;x &lt; y&lt;x2/&gt; is true, the entire ternary operator expression evaluates to the string
&lt;x3/&gt;"less than"&lt;x4/&gt; and otherwise it evaluates to the string &lt;x5/&gt;"not less than"&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230135Z" creationid="hsugawa8651" creationdate="20181109T230135Z">
        <seg>式&lt;x1/&gt;x&lt;y&lt;x2/&gt;がtrueの場合、三元演算子の式全体が文字列に対して評価されます。 &lt;x3/&gt;"より小さい"&lt;x4/&gt;"であり、それ以外の場合は、文字列&lt;x5/&gt;"は&lt;x6/&gt;以上であると評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the memory is already owned by Julia, or is an &lt;x1/&gt;isbits&lt;x2/&gt; type, and is known to be non-null:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151809Z" creationid="hsugawa8651" creationdate="20181117T151809Z">
        <seg>メモリが既にJuliaによって所有されている場合、または&lt;x1/&gt;イスビトス&lt;x2/&gt;タイプであり、非NULLであることが知られている場合は、次のように指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the memory is owned by C:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151818Z" creationid="hsugawa8651" creationdate="20181117T151818Z">
        <seg>メモリがC:に所有されている場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;x1/&gt;`unsafe_wrap(Array, ptr,dims, own = false)`&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152606Z" creationid="hsugawa8651" creationdate="20181117T152606Z">
        <seg>関心のあるポインタがプレーン・データ・アレイ(プリミティブ・タイプまたは不変構造体)である場合、関数&lt;x1/&gt;'unsafe_wrap(Array,ptr,dims,own=false)`&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the same &lt;x8/&gt;X&lt;x9/&gt; package is imported multiple times in the same Julia session, it is only loaded the first time—on subsequent imports, the importing module gets a reference to the same module.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152740Z" creationid="hsugawa8651" creationdate="20181117T152740Z">
        <seg>同じ&lt;x8/&gt;x9/&gt;パッケージが同じジュリアセッションに複数回インポートされた場合は、最初にインポートされたときにのみ読み込まれます。インポートモジュールは、同じモジュールへの参照を取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type &lt;x5/&gt;T&lt;x6/&gt; is
omitted it will default to &lt;x7/&gt;`Float64`&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154346Z" creationid="hsugawa8651" creationdate="20181109T154346Z">
        <seg>&lt;x5/&gt;T&lt;x6/&gt;の場合 省略すると、デフォルトでは&lt;x7/&gt;"Float64&lt;x8/&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type were declared &lt;x1/&gt;mutable&lt;x2/&gt;, you could reach in and directly change the field values to
violate this invariant.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155755Z" creationid="hsugawa8651" creationdate="20181117T155755Z">
        <seg>タイプが宣言されている場合は、&lt;x1/&gt;mutable&lt;x2/&gt;の値を入力すると、フィールド値を入力して、フィールド値を直接変更することができます。 この不変に違反します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable &lt;x6/&gt;i&lt;x7/&gt; has not been introduced in another
scope, in the &lt;x8/&gt;for&lt;x9/&gt; loop form, it is visible only inside of the &lt;x10/&gt;for&lt;x11/&gt; loop, and not
outside/afterwards.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T231159Z" creationid="hsugawa8651" creationdate="20181109T231159Z">
        <seg>変数&lt;x6/&gt;i&lt;x7/&gt;が別の変数に導入されていない場合 &lt;x8/&gt;ループ形式の&lt;x8/&gt;では、&lt;x10/&gt;ループの場合は&lt;x10/&gt;の内部でのみ可視となります。 その後になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are defining an array type that allows non-traditional indexing (indices that start at
something other than 1), you should specialize &lt;x1/&gt;`axes`&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094526Z" creationid="hsugawa8651" creationdate="20181118T094526Z">
        <seg>非伝統的なインデックスを作成するための配列タイプを定義する場合は 1以外のものは、&lt;x1/&gt;'の軸を特殊化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call it in an interactive session without assigning the return value anywhere, you will
see the tuple returned:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101352Z" creationid="hsugawa8651" creationdate="20181112T101352Z">
        <seg>これを対話型セッションで呼び出しても、戻り値はどこにも割り当てられない場合は 戻されたタプルを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define
your own equality function, you should probably define a corresponding &lt;x7/&gt;`hash`&lt;x8/&gt; method
to ensure that &lt;x9/&gt;isequal(x,y)&lt;x10/&gt; implies &lt;x11/&gt;hash(x) == hash(y)&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030708Z" creationid="hsugawa8651" creationdate="20181114T030708Z">
        <seg>定義する場合 独自の等価性関数は、おそらく対応する&lt;x7/&gt;'ハッシュ''&lt;x8/&gt;メソッドを定義する必要があります。 &lt;x9/&gt;isequal(x,y)&lt;x10/&gt;が&lt;x11/&gt;ハッシュ(x)==hash(y)&lt;x12/&gt;を意味することを保証する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't
specify this trait, the default value &lt;x5/&gt;IndexCartesian()&lt;x6/&gt; is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155920Z" creationid="hsugawa8651" creationdate="20181109T155920Z">
        <seg>もしあなたが この特性を指定します。デフォルト値&lt;x5/&gt;IndexCartesian()&lt;x6/&gt;は使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find that something is slow, we highly
recommend reading through the &lt;a0&gt;&lt;s1&gt;Performance Tips&lt;/s1&gt;&lt;/a0&gt;
section before trying anything else.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081550Z" creationid="hsugawa8651" creationdate="20181118T081550Z">
        <seg>JuliaのコンパイラはPythonやRで使われるようなインタプリタとは異なるので、もしかしたら最初はその性能に気づかないかもしれません。 遅いと感じたら、何かを試す前に &lt;s1&gt;Performance Tips &lt;/s1&gt;を参照することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have code that you want executed whenever Julia is run, you can
put it in &lt;c0&gt;&lt;s1&gt;~/.juliarc.jl&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085054Z" creationid="hsugawa8651" creationdate="20181118T085054Z">
        <seg>Juliaの起動時に毎回実行したいコードがあれば、 &lt;c0&gt;&lt;s1&gt;~/.juliarc.jl&lt;/s1&gt;&lt;/c0&gt; に書いておくことができます。

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have code that you want executed whenever Julia is run, you can put it in
&lt;x1/&gt;&lt;x2/&gt;/.julia/config/startup.jl&lt;x3/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092649Z" creationid="hsugawa8651" creationdate="20181109T224453Z">
        <seg>Juliaの起動時に毎回実行したいコードがあれば、 &lt;x1/&gt;&lt;x2/&gt;/.julia/config/startup.jl&lt;x3/&gt; に書いておくことができます。

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you just want to install and use packages, simply use Julia's built-in package manager to add packages to your environment and write &lt;x1/&gt;import X&lt;x2/&gt; or &lt;x3/&gt;using X&lt;x4/&gt; in your code to load packages that you've added.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152754Z" creationid="hsugawa8651" creationdate="20181117T152754Z">
        <seg>パッケージをインストールして使用する場合は、Juliaの組み込みパッケージ・マネージャーを使用して、パッケージを環境に追加し、X&lt;x4/&gt;を使用してx2/&gt;を記述するか、X&lt;x4/&gt;を使用して、追加したパッケージをロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try this at
the REPL, you get the error:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024718Z" creationid="hsugawa8651" creationdate="20181110T024718Z">
        <seg>これを REPLはエラーを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want
to import a module but only use its symbols inside a specific function or set of functions, you
have two options:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025135Z" creationid="hsugawa8651" creationdate="20181110T025135Z">
        <seg>必要な場合 モジュールをインポートするために、特定の関数または関数のセット内のシンボルのみを使用するには、次のようにします。 には次の2つのオプションがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to specialize on a particular style &lt;x1/&gt;DestStyle&lt;x2/&gt;, define a method for</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131644Z" creationid="hsugawa8651" creationdate="20181113T131644Z">
        <seg>特定のスタイル&lt;x1/&gt;DestStyle&lt;x2/&gt;に特化する場合は、次の方法を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you write a custom &lt;x1/&gt;`AbstractArray`&lt;x2/&gt; type, you can specify that it has fast linear indexing using</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155906Z" creationid="hsugawa8651" creationdate="20181109T155906Z">
        <seg>カスタム&lt;x1/&gt;`AbstractArray'&lt;x2/&gt;タイプを書く場合は、次のようにして、高速な線形インデックスを作成することを指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your array type does have fixed dimensionality requirements, then you should
subtype &lt;x1/&gt;AbstractArrayStyle&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131830Z" creationid="hsugawa8651" creationdate="20181113T131830Z">
        <seg>配列タイプに固定次元要件がある場合は、次の操作を行います。 サブタイプ&lt;x1/&gt;AbstractArrayStyle&lt;x2/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150459Z" creationid="hsugawa8651" creationdate="20181117T150459Z">
        <seg>実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Important optional methods&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094055Z" creationid="hsugawa8651" creationdate="20181118T094055Z">
        <seg>重要なオプションのメソッド&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
this case the name is resolved within the current process.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223759Z" creationid="hsugawa8651" creationdate="20181109T223759Z">
        <seg>の この場合、名前は現在のプロセス内で解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared
to be of type &lt;x1/&gt;T&lt;x2/&gt; inside the &lt;x3/&gt;`ccall`&lt;x4/&gt;, as they are passed by value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151439Z" creationid="hsugawa8651" creationdate="20181117T151439Z">
        <seg>外部Cルーチンへの呼び出しをラップするJuliaコードでは、通常の(ポインタ以外の)データを宣言する必要があります。 &lt;x3/&gt;の中で&lt;x1/&gt;T&lt;x2/&gt;であり、それらは値を通過して渡される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia code wrapping calls to external Fortran routines, all input arguments
should be declared as of type &lt;x1/&gt;Ref{T}&lt;x2/&gt;, as Fortran passes all variables by
pointers to memory locations.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151452Z" creationid="hsugawa8651" creationdate="20181117T151452Z">
        <seg>外部Fortranルーチンへの呼び出しをラップするJuliaコードでは、すべての入力引数が は、Fortranがすべての変数を通過するので、&lt;x1/&gt;Ref{T}&lt;x2/&gt;の形式で宣言する必要があります。 メモリ位置へのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia, a function is an object that maps a tuple of argument values to a return value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025448Z" creationid="hsugawa8651" creationdate="20181110T025448Z">
        <seg>Juliaでは、関数は引数値のタプルを戻り値にマップするオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia, all arguments to functions are &lt;x1/&gt;passed by
sharing&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154159Z" creationid="hsugawa8651" creationdate="20181109T154159Z">
        <seg>Juliaでは、関数に対するすべての引数は、&lt;x1/&gt;に渡されます。 共有&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225601Z" creationid="hsugawa8651" creationdate="20181109T225601Z">
        <seg>ジュリアでは、指定されたタイプの最大表現可能な値を超えると、ラップアラウンド動作が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia, the binding of a variable &lt;x1/&gt;x&lt;x2/&gt; cannot be changed by passing &lt;x3/&gt;x&lt;x4/&gt; as an argument to a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025027Z" creationid="hsugawa8651" creationdate="20181110T025027Z">
        <seg>Juliaでは、変数&lt;x1/&gt;x&lt;x2/&gt;の結合は、関数の引数として&lt;x3/&gt;x&lt;x4/&gt;を渡すことで変更することはできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia, type objects also serve as constructor functions: they create new instances of themselves
when applied to an argument tuple as a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155624Z" creationid="hsugawa8651" creationdate="20181117T155624Z">
        <seg>ジュリアでは、オブジェクトもコンストラクタ関数として機能します。これらは、自分自身の新しいインスタンスを作成するためのものです。 関数として引数タプルに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia, types are
themselves run-time objects, and can also be used to convey information
to the compiler.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082257Z" creationid="hsugawa8651" creationdate="20181118T082257Z">
        <seg>Juliaでは、型そのものが実行時オブジェクトとなり、同時にコンパイラに対して情報を伝えるために利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Julia, we can access the parts independently to make a copy of that string:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151216Z" creationid="hsugawa8651" creationdate="20181117T151216Z">
        <seg>Juliaでは、その文字列のコピーを作成するために、パーツに独立してアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a Unix-like
environment, a reliable way to pass options to &lt;x6/&gt;julia&lt;x7/&gt; in an
executable script would be to start the script as a &lt;x8/&gt;bash&lt;x9/&gt; script and
use &lt;x10/&gt;exec&lt;x11/&gt; to replace the process to &lt;x12/&gt;julia&lt;x13/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024926Z" creationid="hsugawa8651" creationdate="20181110T024926Z">
        <seg>Unixライクな 環境、信頼できる方法で&lt;x6/&gt;julia&lt;x7/&gt;にオプションを渡すことができます。 実行可能スクリプトは、スクリプトを&lt;x8/&gt;bash&lt;x9/&gt;スクリプトとして起動します。 &lt;x10/&gt;exec&lt;x11/&gt;を使用して、プロセスを&lt;x12/&gt;ジュリア&lt;x13/&gt;に置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to all the iterable and indexable methods from above, these types can also interact
with each other and use most of the methods defined in Julia Base for &lt;x1/&gt;AbstractArrays&lt;x2/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094522Z" creationid="hsugawa8651" creationdate="20181118T094522Z">
        <seg>これらのタイプは、上記のすべてのiterableメソッドとindexableメソッドに加えて、相互作用することもできます。 &lt;x1/&gt;AbstractArrays&lt;x2/&gt;のために、Julia Baseで定義されたほとんどのメソッドをお互いに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the above, some
advantages of Julia over comparable systems include:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082616Z" creationid="hsugawa8651" creationdate="20181118T082616Z">
        <seg>これに加え、Juliaは以下のような長所を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to this manual, there are various other resources that may
help new users get started with Julia:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085632Z" creationid="hsugawa8651" creationdate="20181118T085632Z">
        <seg>新しいユーザーがJuliaを始めるにあたり、このマニュアルの他にも以下のリソースが参考になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111937Z" creationid="hsugawa8651" creationdate="20181112T111937Z">
        <seg>すべての場合に、あいまいさは数値リテラルとして解釈されるために解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In applications where overflow is possible, explicit checking for wraparound produced
by overflow is essential; otherwise, the &lt;x3/&gt;`BigInt`&lt;x4/&gt; type in &lt;x5/&gt;Arbitrary Precision Arithmetic&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110524Z" creationid="hsugawa8651" creationdate="20181112T110524Z">
        <seg>オーバーフローが可能なアプリケーションでは、ラップアラウンドの明示的なチェックが行われます。 オーバフローは必須である。それ以外の場合は、&lt;x5/&gt;'BigInt'&lt;x4/&gt;は任意精度演算&lt;x6/&gt;任意精度演算&lt;x6/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In conjunction with other control flow, however, &lt;x11/&gt;return&lt;x12/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025752Z" creationid="hsugawa8651" creationdate="20181110T025752Z">
        <seg>しかし、他の制御フローと連動して、&lt;x11/&gt;return&lt;x12/&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast with &lt;x1/&gt;for i = 1:length(A)&lt;x2/&gt;, iterating with &lt;x3/&gt;`eachindex`&lt;x4/&gt; provides an efficient way to
iterate over any array type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155900Z" creationid="hsugawa8651" creationdate="20181109T155900Z">
        <seg>i=1:長さ(A)&lt;x2/&gt;の&lt;x1/&gt;とは対照的に、&lt;x3/&gt;'の反復は、効率的な方法である。&lt;x3/&gt;"エアチンデス"&lt;x4/&gt;である 任意の配列タイプに対して繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, pointers returned by the C function called should be declared to be of output type
&lt;x9/&gt;`Ptr{T}`&lt;x10/&gt;, reflecting that the memory pointed to is managed by C only.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151446Z" creationid="hsugawa8651" creationdate="20181117T151446Z">
        <seg>これとは対照的に、呼び出されるC関数によって返されるポインタは、出力型であることが宣言されるべきです。 &lt;x9/&gt;`Ptr{T}&lt;x10/&gt;は、メモリがCによって管理されていることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, &lt;x11/&gt;f.(args...)&lt;x12/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161317Z" creationid="hsugawa8651" creationdate="20181114T161317Z">
        <seg>実際には、&lt;x11/&gt;f.(args.)&lt;x12/&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the &lt;x15/&gt;Pub&lt;x16/&gt; package has started to use it.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152856Z" creationid="hsugawa8651" creationdate="20181117T152856Z">
        <seg>実際には、&lt;x15/&gt;Pub&lt;x16/&gt;パッケージが使用されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, a broadcast operation is represented by a lazy &lt;x1/&gt;Broadcasted&lt;x2/&gt; container that holds onto
the function to be applied alongside its arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131512Z" creationid="hsugawa8651" creationdate="20181113T131512Z">
        <seg>一般的に、ブロードキャスト動作は 引数と共に適用される関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, unlike many other technical computing languages, Julia does not expect programs to
be written in a vectorized style for performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154152Z" creationid="hsugawa8651" creationdate="20181109T154152Z">
        <seg>一般的に、多くの他の技術計算言語とは異なり、Juliaはプログラムを期待していない。 パフォーマンスを向上させるためにベクトル化されたスタイルで記述する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to control the
type explicitly, a type can be prepended to the comprehension.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154854Z" creationid="hsugawa8651" creationdate="20181109T154854Z">
        <seg>制御を行うには 明示的にタイプを認識することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to define a new display backend, one should first create a subtype &lt;x1/&gt;D&lt;x2/&gt; of the abstract
class &lt;x3/&gt;AbstractDisplay&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063320Z" creationid="hsugawa8651" creationdate="20181114T063320Z">
        <seg>新しい表示バックエンドを定義するには、まず抽象のサブタイプ&lt;x1/&gt;D&lt;x2/&gt;を作成する必要があります。 クラス&lt;x3/&gt;AbstractDisplay&lt;x4/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to implement such a &lt;x1/&gt;copy&lt;x2/&gt; or &lt;x3/&gt;copyto!&lt;x4/&gt;, method, of course, you must
work with the &lt;x5/&gt;Broadcasted&lt;x6/&gt; wrapper to compute each element.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131713Z" creationid="hsugawa8651" creationdate="20181113T131713Z">
        <seg>このような&lt;x1/&gt;コピー&lt;x2/&gt;または&lt;x3/&gt;コピーを実装するには、もちろん、メソッドを使用する必要があります。 &lt;x5/&gt;ブロードキャストされた&lt;x6/&gt;ラッパーを使用して、各要素を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to pass this function to C, we obtain its address using the macro &lt;x1/&gt;@cfunction&lt;x2/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133256Z" creationid="hsugawa8651" creationdate="20181117T133256Z">
        <seg>この関数をCに渡すためには、マクロ&lt;x1/&gt;@cfunction&lt;x2/&gt;:を使ってアドレスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to support indexing with ranges or vectors of &lt;x9/&gt;Int&lt;x10/&gt;s, separate methods must be written:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113139Z" creationid="hsugawa8651" creationdate="20181112T113139Z">
        <seg>&lt;x9/&gt;Int&lt;x10/&gt;の範囲またはベクトルを用いたインデックス作成をサポートするためには、別の方法を記述する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other
words, while developing you might use a workflow something like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024745Z" creationid="hsugawa8651" creationdate="20181110T024745Z">
        <seg>その他 開発中にワークフローを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the binary representation is truncated
to fit.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031042Z" creationid="hsugawa8651" creationdate="20181114T031042Z">
        <seg>つまり、2進数表現は切り捨てられます。 フィットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the representable floating-point
numbers are densest in the real number line near zero, and grow sparser exponentially as one moves
farther away from zero.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111224Z" creationid="hsugawa8651" creationdate="20181112T111224Z">
        <seg>言い換えれば、表現可能浮動小数点 数は0近くの実数線で最も密集しており、指数関数的に成長するにつれて指数関数的に成長する 0から遠く離れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, nested dot calls like &lt;x2/&gt;f.(g.(x))&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132604Z" creationid="hsugawa8651" creationdate="20181113T132604Z">
        <seg>特に、&lt;x2/&gt;f.(g.(x))&lt;x3/&gt;のようなネストされたドットコール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, you'll need to set up a two-layered
system: the C callback should only &lt;x1/&gt;schedule&lt;x2/&gt; (via Julia's event loop) the execution of your "real"
callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152626Z" creationid="hsugawa8651" creationdate="20181117T152626Z">
        <seg>特に、2層を設定する必要があります。 システム:Cコールバックは、&lt;x1/&gt;スケジュール&lt;x2/&gt;(ジュリアのイベントループ経由)を実行して、"実"を実行することができます。 コールバック。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, especially when providing reusable functionality, one generally wraps &lt;x1/&gt;`ccall`&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224109Z" creationid="hsugawa8651" creationdate="20181109T224109Z">
        <seg>実際には、特に再利用可能な機能を提供する場合には、一般的には&lt;x1/&gt;"ccall"&lt;x2/&gt;"をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases it might be convenient not to have to define &lt;x1/&gt;MyStyle&lt;x2/&gt;, in which case you can
leverage one of the general broadcast wrappers:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131138Z" creationid="hsugawa8651" creationdate="20181113T131138Z">
        <seg>場合によっては、&lt;x1/&gt;MyStyle&lt;x2/&gt;を定義しなくてもよい場合があります。この場合は、次のような操作を行います。 一般的なブロードキャストラッパーの一つを活用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, types will want
to additionally specialize those extra behaviors when they know a more efficient algorithm can
be used in their specific case.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112852Z" creationid="hsugawa8651" creationdate="20181112T112852Z">
        <seg>場合によっては、タイプが必要になることがあります。 さらに効率的なアルゴリズムを知っているときにそれらの余分な行動を追加的に専門化すること 特定の場合に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In static languages, on the other hand, while one can — and usually
must — annotate types for the compiler, types exist only at compile time
and cannot be manipulated or expressed at run time.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082250Z" creationid="hsugawa8651" creationdate="20181118T082250Z">
        <seg> 一方静的言語においては、コンパイラのために型注釈をつけることができます（ほぼ必須でしょう）が、型の情報はコンパイル時にのみ存在し、実行時には操作したり取得したりすることができません。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, the result is always 1-d.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155056Z" creationid="hsugawa8651" creationdate="20181109T155056Z">
        <seg>この場合、結果は常に1-dになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, you may
need or want to evaluate &lt;x1/&gt;x .* (x .+ 1)&lt;x2/&gt; as if it had been
written &lt;x3/&gt;broadcast(*, x, broadcast(+, x, 1))&lt;x4/&gt;, where the inner operation is evaluated before
tackling the outer operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131603Z" creationid="hsugawa8651" creationdate="20181113T131603Z">
        <seg>このような場合は &lt;x1/&gt;x.*(x .+ 1)&lt;x2/&gt;を必要とするか、または評価する必要があるかを判断します。 &lt;x3/&gt;ブロードキャスト(*,x,ブロードキャスト(+, x, 1))&lt;x4/&gt;で、インナー操作は事前に評価されます。 外部操作に取り組んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such situations, it is generally clear from the context that the term
is used to mean "constructor method" rather than "constructor function", especially as it is often
used in the sense of singling out a particular method of the constructor from all of the others.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155702Z" creationid="hsugawa8651" creationdate="20181117T155702Z">
        <seg>このような状況では、一般的には、この用語は は、「コンストラクタ関数」ではなく「コンストラクタメソッド」を意味するために使用されます。特に コンストラクタの特定のメソッドを、他のすべてのコンストラクタから削除するという意味で使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the assignment form, the body of the function must be a single expression, although it can
be a compound expression (see &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-compound-expressions)).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025518Z" creationid="hsugawa8651" creationdate="20181110T025518Z">
        <seg>割り当てフォームでは、関数の本文は単一の式である必要がありますが 複合式(&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man compound expressions)を参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of leading zeros, the size is determined by the minimal needed size for a
literal, which has the same length but leading digit &lt;x3/&gt;1&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225440Z" creationid="hsugawa8651" creationdate="20181109T225440Z">
        <seg>先行ゼロの場合、サイズは、必要最小限のサイズで決定されます。 リテラルは同じ長さですが、先頭桁はx3/&gt;1&lt;x4/&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of function definitions, the &lt;x1/&gt;...&lt;x2/&gt; operator is used to combine many different arguments
into a single argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025236Z" creationid="hsugawa8651" creationdate="20181110T025236Z">
        <seg>関数定義のコンテキストでは、&lt;x1/&gt;.…&lt;x2/&gt;演算子は、多くの異なる引数を結合するために使用されます。 単一の引数に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the code between &lt;x1/&gt;&lt;x2/&gt;=&lt;x3/&gt; and &lt;x4/&gt;=&lt;x5/&gt;&lt;x6/&gt; is run as a &lt;x7/&gt;bash&lt;x8/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024937Z" creationid="hsugawa8651" creationdate="20181110T024937Z">
        <seg>上記の例では、&lt;x1/&gt;&lt;x2/&gt;=&lt;x3/&gt;と&lt;x4/&gt;=&lt;x5/&gt;&lt;x6/&gt;の間のコードは、&lt;x7/&gt;bash&lt;x8/&gt;のように実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example function, &lt;x1/&gt;f&lt;x2/&gt;, from
the previous section this is the value of the expression &lt;x3/&gt;x + y&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025728Z" creationid="hsugawa8651" creationdate="20181110T025728Z">
        <seg>例の関数では、&lt;x1/&gt;f&lt;x2/&gt;は 前のセクションは、式&lt;x3/&gt;x+y&lt;x4/&gt;の値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the expression &lt;x1/&gt;A[I_1, I_2, ..., I_n]&lt;x2/&gt;, each &lt;x3/&gt;I_k&lt;x4/&gt; may be a scalar index, an
array of scalar indices, or an object that represents an array of scalar
indices and can be converted to such by &lt;x5/&gt;`to_indices`&lt;x6/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155503Z" creationid="hsugawa8651" creationdate="20181109T155503Z">
        <seg>式&lt;x1/&gt;A[I_1,I_2,…I_n]&lt;x2/&gt;では、各&lt;x3/&gt;I_k&lt;x4/&gt;はスカラーインデックスであってもよいし スカラの配列、またはスカラーの配列を表すオブジェクト インデックスは、&lt;x5/&gt;から&lt;x6/&gt;までに変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the expression &lt;x1/&gt;a &amp;&amp; b&lt;x2/&gt;, the subexpression &lt;x3/&gt;b&lt;x4/&gt; is only evaluated if &lt;x5/&gt;a&lt;x6/&gt; evaluates to &lt;x7/&gt;true&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230234Z" creationid="hsugawa8651" creationdate="20181109T230234Z">
        <seg>&lt;x1/&gt;a&amp;b&lt;x2/&gt;では、サブ式&lt;x3/&gt;b&lt;x4/&gt;は、&lt;x5/&gt;a&lt;x6/&gt;が&lt;x7/&gt;真&lt;x8/&gt;と評価された場合にのみ評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the expression &lt;x1/&gt;a || b&lt;x2/&gt;, the subexpression &lt;x3/&gt;b&lt;x4/&gt; is only evaluated if &lt;x5/&gt;a&lt;x6/&gt; evaluates to &lt;x7/&gt;false&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230237Z" creationid="hsugawa8651" creationdate="20181109T230237Z">
        <seg>&lt;x1/&gt;a b&lt;x2/&gt;の式において、サブ式&lt;x/&gt;b&lt;x4/&gt;は、&lt;x5/&gt;a&lt;x6/&gt;が&lt;x7/&gt;false&lt;x8/&gt;と評価された場合にのみ評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following list of
such functions, calls with a &lt;x1/&gt;dims...&lt;x2/&gt; argument can either take a single tuple of dimension sizes
or a series of dimension sizes passed as a variable number of arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154340Z" creationid="hsugawa8651" creationdate="20181109T154340Z">
        <seg>以下の一覧 そのような関数は、&lt;x1/&gt;ディムスを持つ関数です。&lt;x2/&gt;引数を指定すると、1組の寸法サイズをとることができます。 または、変数の数として渡される一連の次元サイズを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the future,
however, it may do so, yielding even greater performance gains.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160601Z" creationid="hsugawa8651" creationdate="20181109T160601Z">
        <seg>将来は しかし、それによってパフォーマンスが向上する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the most general case,
an array may contain objects of type &lt;x1/&gt;`Any`&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154143Z" creationid="hsugawa8651" creationdate="20181109T154143Z">
        <seg>最も一般的なケースでは 配列は、&lt;x1/&gt;'のタイプのオブジェクトを含むことができます。&lt;x/&gt;&lt;x2/&gt;&lt;x/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous example, the
&lt;x1/&gt;println&lt;x2/&gt; call is shared by all three branches: the only real choice is which literal string to
print.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230106Z" creationid="hsugawa8651" creationdate="20181109T230106Z">
        <seg>前の例では &lt;x1/&gt;println&lt;x2/&gt;コールは3つのブランチすべてで共有されます。唯一の実際の選択は、次のいずれかです。 印刷。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second
construct, &lt;x1/&gt;i&lt;x2/&gt; will be an &lt;x3/&gt;Int&lt;x4/&gt; if &lt;x5/&gt;A&lt;x6/&gt; is an array type with fast linear indexing; otherwise,
it will be a &lt;x7/&gt;CartesianIndex&lt;x8/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155838Z" creationid="hsugawa8651" creationdate="20181109T155838Z">
        <seg>2番目の 構成,&lt;x1/&gt;i&lt;x2/&gt;は&lt;x5/&gt;Int&lt;x6/&gt;であり,&lt;x5/&gt;A&lt;x6/&gt;が高速線形インデックスを用いたアレイ型である場合は,それ以外の値である。 &lt;x7/&gt;CartesianIndex&lt;x8/&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this
case, the expression must evaluate to a &lt;x3/&gt;Ptr&lt;x4/&gt;, which will be used as the address of the native
function to call.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152325Z" creationid="hsugawa8651" creationdate="20181117T152325Z">
        <seg>この 例:式は、ネイティブのアドレスとして使用される&lt;x3/&gt;Ptr&lt;x4/&gt;に評価される必要があります。 関数が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case there will be no hidden arguments, at the cost of some
language features (e.g. only &lt;x11/&gt;character(len=1)&lt;x12/&gt; will be permitted to pass strings).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151123Z" creationid="hsugawa8651" creationdate="20181117T151123Z">
        <seg>この場合は、隠れた引数はありません。 言語機能(例えば、&lt;x11/&gt;文字(len=1)&lt;x12/&gt;は文字列を渡すことが許されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example it is accomplished by defining &lt;x1/&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083257Z" creationid="hsugawa8651" creationdate="20181113T083257Z">
        <seg>この例では、&lt;x1/&gt;のような{T}(A::SparseArray,::Type{T},dims::Dims)&lt;x2/&gt;を定義することによって達成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this style of definition, the code generation feature is essentially an optional
optimization.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032415Z" creationid="hsugawa8651" creationdate="20181116T032415Z">
        <seg>この定義の定義では、コード生成機能は基本的にオプションです。 最適化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-place broadcasting can be supported by defining the appropriate &lt;x1/&gt;copyto!(dest, bc::Broadcasted)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131637Z" creationid="hsugawa8651" creationdate="20181113T131637Z">
        <seg>インプレースブロードキャストは、適切な&lt;x1/&gt;copyto!(dest,bc::Broadcast)&lt;x2/&gt;を定義することでサポートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inclusion allows you to split a single program across multiple source files.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152659Z" creationid="hsugawa8651" creationdate="20181117T152659Z">
        <seg>インクルージョンを使用すると、複数のソースファイルにわたって単一のプログラムを分割できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incomplete Initialization</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155836Z" creationid="hsugawa8651" creationdate="20181117T155836Z">
        <seg>不完全な初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inconsistencies
can cause code that works correctly on one system to fail or produce indeterminate results on
a different system.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150551Z" creationid="hsugawa8651" creationdate="20181117T150551Z">
        <seg>不整合 は、1つのシステム上で正しく動作するコードを生成することができます。 別のシステムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Increasing the
index of dimension &lt;x9/&gt;k&lt;x10/&gt; by &lt;x11/&gt;1&lt;x12/&gt; should increase the index &lt;x13/&gt;i&lt;x14/&gt; of &lt;x15/&gt;`getindex(A,i)`&lt;x16/&gt; by
&lt;x17/&gt;`stride(A,k)`&lt;x18/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160502Z" creationid="hsugawa8651" creationdate="20181109T160502Z">
        <seg>増加 &lt;x11/&gt;1&lt;x12/&gt;&lt;x12/&gt;の寸法&lt;x9/&gt;k&lt;x10/&gt;は、&lt;x15/&gt;'getindex(A,i)'&lt;x15/&gt;のインデックス&lt;x13/&gt;i&lt;x14/&gt;を増加させます。 &lt;x17/&gt;`stride(A,k)`&lt;x18/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IndexCartesian()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113313Z" creationid="hsugawa8651" creationdate="20181112T113313Z">
        <seg>IndexCartesian()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IndexStyle(::Type)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113308Z" creationid="hsugawa8651" creationdate="20181112T113308Z">
        <seg>IndexStyle(::Type)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexable Collections</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041646Z" creationid="hsugawa8651" creationdate="20181112T041646Z">
        <seg>Indexable Collections</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexed assignment
syntax without the &lt;x6/&gt;end&lt;x7/&gt; keyword is equivalent to a call to
&lt;x8/&gt;`setindex!`&lt;x9/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155447Z" creationid="hsugawa8651" creationdate="20181109T155447Z">
        <seg>インデックス付きの割り当て &lt;x6/&gt;end&lt;x7/&gt;キーワードがない構文は、次のような呼び出しに相当します。 &lt;x8/&gt;`setindex!`&lt;x9/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexing and assignment</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150029Z" creationid="hsugawa8651" creationdate="20181117T150029Z">
        <seg>インデックス作成と割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexing by a boolean vector &lt;x3/&gt;B&lt;x4/&gt; is effectively the same as indexing by the
vector of integers that is returned by &lt;x5/&gt;`findall(B)`&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155758Z" creationid="hsugawa8651" creationdate="20181109T155758Z">
        <seg>ブール型ベクトル&lt;x3/&gt;B&lt;x4/&gt;によるインデックス作成は、実効的には、以下のようにして行われる。 &lt;x5/&gt;`findall(B)`&lt;x6/&gt;によって返される整数のベクトル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexing syntax without the &lt;x3/&gt;end&lt;x4/&gt; keyword is equivalent to a call to &lt;x5/&gt;`getindex`&lt;x6/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155245Z" creationid="hsugawa8651" creationdate="20181109T155245Z">
        <seg>&lt;x3/&gt;end&lt;x4/&gt;キーワードなしのインデックス構文は、&lt;x5/&gt;`getindex'&lt;x6/&gt;への呼び出しと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexing with
anything other than an &lt;x5/&gt;Int&lt;x6/&gt; will throw a &lt;x7/&gt;`MethodError`&lt;x8/&gt; saying that there was no matching method.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113131Z" creationid="hsugawa8651" creationdate="20181112T113131Z">
        <seg>インデックス作成 &lt;x5/&gt;Int&lt;x6/&gt;以外の何かは、一致する方法がないことを示す&lt;x7/&gt;'MethodError'&lt;x8/&gt;をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inf16&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110804Z" creationid="hsugawa8651" creationdate="20181112T110804Z">
        <seg>Inf16&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inf32&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110805Z" creationid="hsugawa8651" creationdate="20181112T110805Z">
        <seg>Inf32&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inf&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110806Z" creationid="hsugawa8651" creationdate="20181112T110806Z">
        <seg>Inf&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inf&lt;x1/&gt; is equal to itself and greater than everything else except &lt;x2/&gt;NaN&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030503Z" creationid="hsugawa8651" creationdate="20181114T030503Z">
        <seg>Inf&lt;x1/&gt;はそれ自身に等しく、&lt;x2/&gt;NaN&lt;x3/&gt;を除く他のすべてより大きい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inference on the generated function may be run at &lt;x1/&gt;any&lt;x2/&gt; time, including while your code is attempting
to observe or mutate this state.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032230Z" creationid="hsugawa8651" creationdate="20181116T032230Z">
        <seg>生成された関数の推論は、コードが試行されている間も、&lt;x x/&gt;&lt;x x2/&gt;時間で実行されることがあります。 この状態を観察または突然変異させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inner Constructor Methods</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155731Z" creationid="hsugawa8651" creationdate="20181117T155731Z">
        <seg>内部コンストラクタのメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>InsertionSort&lt;x1/&gt; is an O(n^2) stable sorting algorithm.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064050Z" creationid="hsugawa8651" creationdate="20181114T064050Z">
        <seg>InsertionSort&lt;x1/&gt;は、O(n^2)安定ソートアルゴリズムである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the &lt;x5/&gt;then&lt;x6/&gt; part of the &lt;x7/&gt;if @generated&lt;x8/&gt; block, code has the same semantics as other
generated functions: argument names refer to types, and the code should return an expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032402Z" creationid="hsugawa8651" creationdate="20181116T032402Z">
        <seg>&lt;x8/&gt;の&lt;x5/&gt;の中で、@生成された&lt;x8/&gt;ブロックの場合、コードは他のものと同じ意味を持つ。 生成された関数:引数名は型を参照し、コードは式を返す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead
of mutating objects as they are iterated over, Julia iterators may keep track
of the iteration state externally from the object.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112355Z" creationid="hsugawa8651" creationdate="20181112T112355Z">
        <seg>代わりに 反復されるときにオブジェクトをミューテートすることで、ジュリア反復子は追跡することができる オブジェクトからの繰り返し状態の繰り返し状態です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead define a convert method and pass the variables directly to the &lt;x5/&gt;`ccall`&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152230Z" creationid="hsugawa8651" creationdate="20181117T152230Z">
        <seg>代わりに変換メソッドを定義して、変数を直接&lt;x5/&gt;`ccall'&lt;x6/&gt;に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of &lt;x3/&gt;if &lt;x4/&gt; &lt;x5/&gt; end&lt;x6/&gt;, one can write &lt;x7/&gt;&lt;x8/&gt; &amp;&amp; &lt;x9/&gt;&lt;x10/&gt; (which could be
read as: &lt;x11/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230354Z" creationid="hsugawa8651" creationdate="20181109T230354Z">
        <seg>&lt;x4/&gt;&lt;x5/&gt;end&lt;x6/&gt;ではなく、&lt;x7/&gt;&lt;x8/&gt;&amp;&amp;&lt;x9/&gt;&lt;x10/&gt;(これは以下のようなものがあります)&lt;x x/&gt;&lt;x10/&gt;( read as:&lt;x11/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of defining all these behaviors
ourselves, we can officially define it as a subtype of an &lt;x6/&gt;`AbstractArray`&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113207Z" creationid="hsugawa8651" creationdate="20181112T113207Z">
        <seg>これらすべての行動を定義する代わりに 私たちは、公式には、&lt;x6/&gt;'AbstractArray'&lt;x7/&gt;のサブタイプとして定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of directly sorting an array, you can compute a permutation of the array's indices that
puts the array into sorted order:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150312Z" creationid="hsugawa8651" creationdate="20181117T150312Z">
        <seg>配列を直接ソートする代わりに、配列のインデックスの置換を計算することができます。 配列をソートされた順序に配置します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, declare an &lt;x3/&gt;isbits&lt;x4/&gt; struct type and use that instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151144Z" creationid="hsugawa8651" creationdate="20181117T151144Z">
        <seg>代わりに、&lt;x3/&gt;イスビトス&lt;x4/&gt;構造体を宣言し、代わりにそれを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, packages are identified by &lt;x1/&gt;universally unique identifiers&lt;x2/&gt; (UUIDs) which are assigned to them before they are registered.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152842Z" creationid="hsugawa8651" creationdate="20181117T152842Z">
        <seg>その代わりに、パッケージは、登録される前に割り当てられた&lt;x1/&gt;ユニバーサル一意識別子&lt;x2/&gt;(UUID)によって識別されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Int(round(x))&lt;x1/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031053Z" creationid="hsugawa8651" creationdate="20181114T031053Z">
        <seg>Int(round(x))&lt;x1/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Int16&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150913Z" creationid="hsugawa8651" creationdate="20181117T150913Z">
        <seg>Int16&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Int&lt;x1/&gt; indices.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083104Z" creationid="hsugawa8651" creationdate="20181113T083104Z">
        <seg>Int&lt;x1/&gt; indices.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Int&lt;x1/&gt;, &lt;x2/&gt;Float64&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150659Z" creationid="hsugawa8651" creationdate="20181117T150659Z">
        <seg>Int&lt;x1/&gt;, &lt;x2/&gt;Float64&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer division (the &lt;x1/&gt;div&lt;x2/&gt; function) has two exceptional cases: dividing by zero, and dividing
the lowest negative number (&lt;x3/&gt;`typemin`&lt;x4/&gt;) by -1.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110528Z" creationid="hsugawa8651" creationdate="20181112T110528Z">
        <seg>整数除算(&lt;x1/&gt;div&lt;x2/&gt;関数)は2つの例外的なケースを持っています:0で除算して除算します。 -1で最も低い負の数(&lt;x3/&gt;`テーパミン'&lt;x4/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer value N launches N additional local worker processes; &lt;x1/&gt;auto&lt;x2/&gt; launches as many workers as the number of local CPU threads (logical cores)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224711Z" creationid="hsugawa8651" creationdate="20181109T224711Z">
        <seg>整数値Nは、N個のローカル・ワーカー・プロセスを起動します。&lt;x1/&gt;自動&lt;x2/&gt;は、ローカルCPUスレッド(論理コア)の数と同じ数のワーカーを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044717Z" creationid="hsugawa8651" creationdate="20181112T044717Z">
        <seg>Integers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers and floating-point values are the basic building blocks of arithmetic and computation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225032Z" creationid="hsugawa8651" creationdate="20181109T225032Z">
        <seg>整数および浮動小数点値は、算術演算と計算の基本的な構成要素です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers are compared in the standard manner -- by comparison of bits.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030454Z" creationid="hsugawa8651" creationdate="20181114T030454Z">
        <seg>整数は、標準的な方法で比較されます(ビットを比較します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interacting with the contents or methods of &lt;x1/&gt;Core.Compiler&lt;x2/&gt; in any way.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032226Z" creationid="hsugawa8651" creationdate="20181116T032226Z">
        <seg>&lt;x1/&gt;コアの内容または方法との相互作用。コンパイラ&lt;x2/&gt;は任意の方法で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interactive mode; REPL runs and &lt;x1/&gt;isinteractive()&lt;x2/&gt; is true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224718Z" creationid="hsugawa8651" creationdate="20181109T224718Z">
        <seg>Interactiveモード;REPLは実行され、&lt;x1/&gt;イスインタラクティブ()&lt;x2/&gt;はtrueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, this code creates two implementations of the function: a generated one where
the first block in &lt;x1/&gt;if @generated&lt;x2/&gt; is used, and a normal one where the &lt;x3/&gt;else&lt;x4/&gt; block is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032404Z" creationid="hsugawa8651" creationdate="20181116T032404Z">
        <seg>内部的には、このコードは次の2つの実装を作成します:a生成された関数: &lt;x1/&gt;の最初のブロックは、@generated&lt;x2/&gt;が使用され、かつ&lt;x/&gt;else&lt;x4/&gt;ブロックが使用される通常のブロックである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internals</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042019Z" creationid="hsugawa8651" creationdate="20181110T042019Z">
        <seg>Internals</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IsInfinite()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112319Z" creationid="hsugawa8651" creationdate="20181112T112319Z">
        <seg>IsInfinite()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also makes writing exponential functions more elegant:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111756Z" creationid="hsugawa8651" creationdate="20181112T111736Z">
        <seg>また、指数関数をよりエレガントに書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also be used directly in a &lt;x4/&gt;`for`&lt;x5/&gt; loop since the syntax:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112437Z" creationid="hsugawa8651" creationdate="20181112T112437Z">
        <seg>構文は、構文が次のように指定されているため、&lt;x x/&gt;ループでは直接&lt;x4/&gt;で使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can even be combined with a &lt;x8/&gt;:&lt;x9/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155706Z" creationid="hsugawa8651" creationdate="20181109T155706Z">
        <seg>また、&lt;x8/&gt;:&lt;x9/&gt;と組み合わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this by creating and manipulating project files that describe what your project depends on, and manifest files that snapshot exact versions of your project's complete dependency graph.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152830Z" creationid="hsugawa8651" creationdate="20181117T152830Z">
        <seg>これはプロジェクトファイルを記述するプロジェクトファイルを作成して操作することによって、プロジェクトの完全な依存関係グラフの正確なバージョンをスナップショットで表示するファイルを作成することによって実現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It gets its name from being the only operator
in most languages taking three operands:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230049Z" creationid="hsugawa8651" creationdate="20181109T230049Z">
        <seg>その名前が唯一の演算子となります。 ほとんどの言語で3つのオペランドを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has a special compilation rule: a homogeneous tuple of &lt;x1/&gt;VecElement{T}&lt;x2/&gt; maps to an LLVM &lt;x3/&gt;vector&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063645Z" creationid="hsugawa8651" creationdate="20181114T063645Z">
        <seg>それは特別なコンパイル規則をもち、&lt;x1/&gt;VecElement{T}&lt;x2/&gt;マップの同種タプルをLLVM&lt;x3/&gt;ベクトル&lt;x4/&gt;にマッピングする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has access to a special locally existent function called &lt;x1/&gt;`new`&lt;x2/&gt; that creates objects of the
block's type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155739Z" creationid="hsugawa8651" creationdate="20181117T155739Z">
        <seg>それは、オブジェクトを作成する&lt;x1/&gt;'新しい&lt;x2/&gt;という特別なローカルに存在する機能にアクセスすることができます。 ブロックのタイプ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is
multi-paradigm, combining features of imperative, functional, and
object-oriented programming.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081817Z" creationid="hsugawa8651" creationdate="20181118T081641Z">
        <seg>Juliaは命令型プログラミング・関数型プログラミング・オブジェクト指向プログラミングの機能を組み合わせたマルチパラダイム言語です。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also often useful to allow iteration over a collection in &lt;x1/&gt;reverse order&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112857Z" creationid="hsugawa8651" creationdate="20181112T112857Z">
        <seg>また、&lt;x1/&gt;逆順&lt;x2/&gt;でのコレクションでの反復を可能にすることも、しばしば有用である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is considered unsafe because
converting an object to a native pointer can hide the object from the garbage collector, causing
it to be freed prematurely.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150611Z" creationid="hsugawa8651" creationdate="20181117T150611Z">
        <seg>それは安全ではないと考えられている。 オブジェクトをネイティブ・ポインタに変換すると、ガーベッジ・コレクターからオブジェクトを非表示にすることができます。 早期に解放することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is critical to exactly match the declared C type with its declaration in Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150549Z" creationid="hsugawa8651" creationdate="20181117T150549Z">
        <seg>宣言されたCタイプと、Juliaで宣言された宣言を正確に一致させることが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies
can cause code that works correctly on one system to fail or produce indeterminate results on
a different system.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134217Z" creationid="hsugawa8651" creationdate="20181117T134217Z">
        <seg>宣言されたCタイプと、Juliaの宣言を正確に一致させることが重要です。 は、1つのシステム上で正しく動作するコードを生成することができます。 別のシステムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155737Z" creationid="hsugawa8651" creationdate="20181117T155737Z">
        <seg>それは、通常のメソッドのような外部ではなく、型宣言のブロック内で宣言されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is defined by-value, and is stored without a type-tag.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150732Z" creationid="hsugawa8651" creationdate="20181117T150732Z">
        <seg>これは値によって定義され、タイプタグなしで保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is defined by-value, and may be stored with a type-tag.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150717Z" creationid="hsugawa8651" creationdate="20181117T150717Z">
        <seg>それは値によって定義され、タイプタグとともに格納されることがある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is efficient for very small &lt;x2/&gt;n&lt;x3/&gt;, and
is used internally by &lt;x4/&gt;QuickSort&lt;x5/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064045Z" creationid="hsugawa8651" creationdate="20181114T064045Z">
        <seg>非常に小さい&lt;x2/&gt;n&lt;x3/&gt;に対しては効率的である。 は、&lt;x4/&gt;QuickSort&lt;x5/&gt;によって内部的に使用されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally more efficient to use boolean arrays as
indices directly instead of first calling &lt;x13/&gt;`findall`&lt;x14/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155813Z" creationid="hsugawa8651" creationdate="20181109T155813Z">
        <seg>一般的に、boolean配列を使用する方が効率的です。 は、最初の呼び出し&lt;x13/&gt;'findall&lt;x14/&gt;を呼び出すのではなく、直接インデックスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is good practice to provide as few inner constructor methods as possible: only those
taking all arguments explicitly and enforcing essential error checking and transformation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155831Z" creationid="hsugawa8651" creationdate="20181117T155831Z">
        <seg>できるだけ少ないインナーコンストラクタメソッドを提供することは良い習慣ですが、それだけでよいのです。 すべての引数を明示的に取得し、必須のエラーチェックと変換を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is parameterized by
the number of dimensions &lt;x3/&gt;N&lt;x4/&gt; and the element type &lt;x5/&gt;T&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160240Z" creationid="hsugawa8651" creationdate="20181109T160240Z">
        <seg>パラメータは、パラメータによってパラメータ化されます。 次元の数&lt;x3/&gt;N&lt;x4/&gt;と、エレメント・タイプ&lt;x5/&gt;T&lt;x6/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to constrain the number of values passed as a variable argument; this will be discussed
later in &lt;x1/&gt;Parametrically-constrained Varargs methods&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101624Z" creationid="hsugawa8651" creationdate="20181112T101624Z">
        <seg>変数引数として渡される値の数を制限することは可能です。これについては、以下を参照してください。 &lt;x1/&gt;パラメトリックに拘束されたVarargsメソッド&lt;x2/&gt;の後にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to pass Julia functions to native C functions that accept function pointer arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153908Z" creationid="hsugawa8651" creationdate="20181109T153908Z">
        <seg>関数ポインタ引数を受け入れるネイティブC関数にJulia関数を渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to pass Julia functions to native C functions that accept function pointer arguments.
For example, to match C prototypes of the form:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133850Z" creationid="hsugawa8651" creationdate="20181117T133850Z">
        <seg>関数ポインタ引数を受け入れるネイティブC関数にJulia関数を渡すことができます。 たとえば、フォームのCプロトタイプに一致させるには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended that these operations
have nearly constant time complexity, or technically Õ(1) complexity, as otherwise some array
functions may be unexpectedly slow.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160322Z" creationid="hsugawa8651" creationdate="20181109T160322Z">
        <seg>これらの操作は、次のように操作することをお勧めします。 ほとんど一定の時間的複雑さ(技術的には1)、あるいは技術的には複雑さがある 機能が予期せぬほど遅くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended to also define &lt;x5/&gt;`firstindex`&lt;x6/&gt; to specify the first valid index:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113111Z" creationid="hsugawa8651" creationdate="20181112T113111Z">
        <seg>また、最初の有効なインデックスを指定するには、&lt;x5/&gt;'firstindex&lt;x6/&gt;を定義することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is significant that like &lt;x1/&gt;if&lt;x2/&gt;-&lt;x3/&gt;elseif&lt;x4/&gt;-&lt;x5/&gt;else&lt;x6/&gt;, the expressions before and after the &lt;x7/&gt;:&lt;x8/&gt; are
only evaluated if the condition expression evaluates to &lt;x9/&gt;true&lt;x10/&gt; or &lt;x11/&gt;false&lt;x12/&gt;, respectively:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230156Z" creationid="hsugawa8651" creationdate="20181109T230156Z">
        <seg>&lt;x2/&gt;-&lt;x3/&gt;elseif&lt;x4/&gt;&lt;x5/&gt;else&lt;x6/&gt;以外の&lt;x6/&gt;&lt;x6/&gt;の場合は、&lt;x7/&gt;:&lt;x8/&gt;:&lt;x8/&gt;=&lt;x8/&gt;となる。 条件式が&lt;x9/&gt;真&lt;x10/&gt;または&lt;x11/&gt;false&lt;x12/&gt;と評価された場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes useful to close (unload) a library so that it can be reloaded.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152352Z" creationid="hsugawa8651" creationdate="20181117T152352Z">
        <seg>ライブラリを閉じる(アンロードする)ことによって、ライブラリを再ロードすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes useful to perform element-by-element binary operations on arrays of different
sizes, such as adding a vector to each column of a matrix.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160040Z" creationid="hsugawa8651" creationdate="20181109T160040Z">
        <seg>異なる要素のバイナリ・バイナリ・バイナリ・オペレーションを実行する場合には、次のようにします。 行列の各列にベクトルを追加するなどのサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes useful to perform element-by-element binary operations on arrays of different
sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would
be to replicate the vector to the size of the matrix:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135218Z" creationid="hsugawa8651" creationdate="20181117T135218Z">
        <seg>異なる要素のバイナリ・バイナリ・バイナリ・オペレーションを実行する場合には、次のようにします。 行列の各列にベクトルを追加するなどのサイズです。効率的な方法はありません。 ベクトルをマトリックスのサイズに複製することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is stored and defined by-value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150705Z" creationid="hsugawa8651" creationdate="20181117T150705Z">
        <seg>それは値によって保存され、定義される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is strongly recommended not to use expressions with side effects (such
as printing) in chained comparisons.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030749Z" creationid="hsugawa8651" creationdate="20181114T030749Z">
        <seg>副作用のない表現式を使用しないことを強くお勧めします。 連鎖比較では、印刷として使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the default algorithm for non-numeric data.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064113Z" creationid="hsugawa8651" creationdate="20181114T064113Z">
        <seg>これは、非数値データのデフォルトアルゴリズムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is worth noting that you do not need to (and should not) define both argument orders
of this call; defining one is sufficient no matter what order the user supplies the arguments in.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131758Z" creationid="hsugawa8651" creationdate="20181113T131758Z">
        <seg>両方の引数の両方を定義する必要はありませんが、両方の命令を定義する必要はありません。 この呼び出しの定義では、ユーザが引数を指定する順序にかかわらず、一つだけで十分であることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will
be evaluated and returned depending on the preceding conditionals:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230826Z" creationid="hsugawa8651" creationdate="20181109T230826Z">
        <seg>それは 前の条件に応じて評価され、返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's easy to experiment with this behavior:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230248Z" creationid="hsugawa8651" creationdate="20181109T230248Z">
        <seg>この動作を試してみると簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating over the &lt;x1/&gt;CartesianIndices&lt;x2/&gt; of the &lt;x3/&gt;axes(::Broadcasted)&lt;x4/&gt; and using
indexing with the resulting &lt;x5/&gt;CartesianIndex&lt;x6/&gt; object to compute the result.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131732Z" creationid="hsugawa8651" creationdate="20181113T131732Z">
        <seg>&lt;x3/&gt;軸の&lt;x1/&gt;CartesianIndices&lt;x2/&gt;を繰り返し(::ブロードキャスト)&lt;x4/&gt;を使用して繰り返します。 結果の計算には、結果の&lt;x5/&gt;CartesianIndex&lt;x6/&gt;オブジェクトを使用してインデックスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iteration</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135120Z" creationid="hsugawa8651" creationdate="20181117T135120Z">
        <seg>反復</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iteration utilities</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043415Z" creationid="hsugawa8651" creationdate="20181112T043415Z">
        <seg>Iteration utilities</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IteratorEltype(IterType)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112140Z" creationid="hsugawa8651" creationdate="20181112T112140Z">
        <seg>IteratorEltype(IterType)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IteratorSize(IterType)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112117Z" creationid="hsugawa8651" creationdate="20181112T112117Z">
        <seg>IteratorSize(IterType)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its &lt;x9/&gt;i&lt;x10/&gt;th element is populated by &lt;x11/&gt;A[2, I[i], 3]&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160823Z" creationid="hsugawa8651" creationdate="20181114T160823Z">
        <seg>その&lt;x9/&gt;i&lt;x10/&gt;番目の要素は、&lt;x11/&gt;A[2,I[I],3]&lt;x12/&gt;で占められている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its implementation uses &lt;x2/&gt;`hash`&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041720Z" creationid="hsugawa8651" creationdate="20181112T041720Z">
        <seg>その実装は、&lt;x2/&gt;'ハッシュを使用します。&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JULIA_BINDIR&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054734Z" creationid="hsugawa8651" creationdate="20181116T054734Z">
        <seg>JULIA_BINDIR&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia
functions are not pure mathematical functions, in the sense that functions can alter and be affected
by the global state of the program.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025452Z" creationid="hsugawa8651" creationdate="20181110T025452Z">
        <seg>ジュリア 関数は純粋な数学的関数ではなく、関数が変更され、影響を受けることがあるという意味では プログラムの世界的な状態です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia Base Type</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150853Z" creationid="hsugawa8651" creationdate="20181117T150853Z">
        <seg>ジュリア・ベース・タイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia Base contains a range of functions and macros appropriate for performing
scientific and numerical computing, but is also as broad as those of many general purpose programming
languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150054Z" creationid="hsugawa8651" creationdate="20181110T041646Z">
        <seg>Julia Baseには、実行するために適切な関数とマクロが含まれています。 科学的・数値的計算ではあるが、一般的なプログラミングと同様に広範なものである 言語。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia aims to create an unprecedented combination of ease-of-use, power,
and efficiency in a single language.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082559Z" creationid="hsugawa8651" creationdate="20181118T082559Z">
        <seg>Juliaは、扱いやすさ・強力さ・効率性の前例のない組み合わせを1つの言語で実現しようとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia also defines the types &lt;x1/&gt;Int&lt;x2/&gt; and &lt;x3/&gt;UInt&lt;x4/&gt;, which are aliases for the system's signed and unsigned
native integer types respectively:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110348Z" creationid="hsugawa8651" creationdate="20181112T110348Z">
        <seg>また、Juliaは、システムの署名と符号なしのエイリアスである、&lt;x1/&gt;Int&lt;x2/&gt;と&lt;x3/&gt;UInt&lt;x4/&gt;のタイプを定義します。 ネイティブの整数型:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia also provides the &lt;x1/&gt;`nextfloat`&lt;x2/&gt; and &lt;x3/&gt;`prevfloat`&lt;x4/&gt; functions which return
the next largest or smallest representable floating-point number to the argument respectively:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111320Z" creationid="hsugawa8651" creationdate="20181112T111320Z">
        <seg>また、Juliaは、&lt;x1/&gt;`ネクトフロート'&lt;x2/&gt;と、&lt;x3/&gt;'プレビフロート'&lt;x4/&gt;関数を提供します。 引数に対して次の最大または最小の表現可能浮動小数点数をそれぞれ指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia applies the following order and associativity of operations, from highest precedence to lowest:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030806Z" creationid="hsugawa8651" creationdate="20181114T030806Z">
        <seg>Juliaは、最高優先順位から最低への順序付けと関連付けを適用し、次の順序を適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia automatically inserts calls to the &lt;x1/&gt;`Base.cconvert`&lt;x2/&gt; function to convert each argument
to the specified type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150600Z" creationid="hsugawa8651" creationdate="20181117T150600Z">
        <seg>Juliaは、各引数を変換するために&lt;x1/&gt;'Base.チコンベルト'&lt;x2/&gt;関数への呼び出しを自動的に挿入します。 で指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia automatically inserts calls to the &lt;x1/&gt;`Base.cconvert`&lt;x2/&gt; function to convert each argument
to the specified type. For example, the following call:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134250Z" creationid="hsugawa8651" creationdate="20181117T134250Z">
        <seg>Juliaは、各引数を変換するために&lt;x1/&gt;'Base.チコンベルト'&lt;x2/&gt;関数への呼び出しを自動的に挿入します。 指定されたタイプです。たとえば、次の呼び出しが行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia can be started in parallel mode with either the &lt;c0&gt;&lt;s1&gt;-p&lt;/s1&gt;&lt;/c0&gt; or the
&lt;c2&gt;&lt;s3&gt;--machinefile&lt;/s3&gt;&lt;/c2&gt; options.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085503Z" creationid="hsugawa8651" creationdate="20181118T084853Z">
        <seg>&lt;c0&gt;&lt;s1&gt;-p&lt;/s1&gt;&lt;/c0&gt; もしくは &lt;c2&gt;&lt;s3&gt;--machinefile&lt;/s3&gt;&lt;/c2&gt; オプションを設定することで、Juliaを並列モードで開始することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia can be started in parallel mode with either the &lt;x1/&gt;-p&lt;x2/&gt; or the &lt;x3/&gt;--machine-file&lt;x4/&gt; options.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092131Z" creationid="hsugawa8651" creationdate="20181109T224410Z">
        <seg>&lt;x1/&gt;-p&lt;x2/&gt; もしくは &lt;x3/&gt;--machinefile&lt;x4/&gt; オプションを設定することで、Juliaを並列モードで開始することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia does not have an analog of MATLAB's &lt;x1/&gt;clear&lt;x2/&gt; function; once a name is defined in a Julia
session (technically, in module &lt;x3/&gt;Main&lt;x4/&gt;), it is always present.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024636Z" creationid="hsugawa8651" creationdate="20181110T024636Z">
        <seg>JuliaはMATLABの&lt;x1/&gt;clear&lt;x2/&gt;関数のアナログを持っていない;名前がJuliaで定義された場合 セッション(技術的には、モジュール&lt;x3/&gt;メイン&lt;x4/&gt;)は常に存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia does not treat arrays in any special way.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154124Z" creationid="hsugawa8651" creationdate="20181109T154124Z">
        <seg>Juliaは、特別な方法でアレイを処理しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia features optional typing, multiple dispatch, and good
performance, achieved using type inference and &lt;a0&gt;just-in-time (JIT)
compilation&lt;/a0&gt;,
implemented using &lt;a1&gt;LLVM&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081814Z" creationid="hsugawa8651" creationdate="20181118T081625Z">
        <seg>Juliaは任意の型付け、多重ディスパッチ、そして優れた性能を提供します。 これは型推論と、&lt;a1&gt;LLVM&lt;/a1&gt;によって実装された &lt;a0&gt;just-in-time (JIT) コンパイラ&lt;/a0&gt;によって実現されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia function arguments follow a convention sometimes called "pass-by-sharing", which means that
values are not copied when they are passed to functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025705Z" creationid="hsugawa8651" creationdate="20181110T025705Z">
        <seg>Julia関数の引数は、「共有によるパス」と呼ばれる規則に従うことがあります。これは 値が関数に渡されると、値はコピーされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia has
a sophisticated type system and allows multiple dispatch on argument types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T105931Z" creationid="hsugawa8651" creationdate="20181112T105931Z">
        <seg>ジュリアは 洗練されたタイプのシステムで、引数型で複数のディスパッチを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia has a "no boilerplate" philosophy:
functions can be called directly from Julia without any "glue" code, code generation, or compilation
-- even from the interactive prompt.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160541Z" creationid="hsugawa8651" creationdate="20181109T160541Z">
        <seg>Juliaは「ボイラープレートなし」哲学を持っている。 関数は、"glue"コード、コード生成、コンパイルなしで、Juliaから直接呼び出すことができます。 --対話型プロンプトからでも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of
values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063708Z" creationid="hsugawa8651" creationdate="20181114T063708Z">
        <seg>Juliaは、すでにソートされた配列をソートし、相互に作用させるための広範で柔軟なAPIを持っています。 値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia has two mechanisms for loading code:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152655Z" creationid="hsugawa8651" creationdate="20181117T152655Z">
        <seg>Juliaには、コードをロードするための2つのメカニズムがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia installation is straightforward, whether using precompiled
binaries or compiling from source.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083710Z" creationid="hsugawa8651" creationdate="20181118T083710Z">
        <seg>コンパイル済のバイナリを使うのであれ、ソースからコンパイルするのであれ、Juliaのインストールは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia installation is straightforward, whether using precompiled binaries or compiling from source.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224247Z" creationid="hsugawa8651" creationdate="20181109T224247Z">
        <seg>ジュリアのインストールは、コンパイル済みのバイナリを使用するか、ソースからコンパイルするかにかかわらず、簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides &lt;x1/&gt;`eps`&lt;x2/&gt;, which gives the distance between &lt;x3/&gt;1.0&lt;x4/&gt; and the next larger representable
floating-point value:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111137Z" creationid="hsugawa8651" creationdate="20181112T111137Z">
        <seg>Juliaは&lt;x1/&gt;'eps'&lt;x2/&gt;を提供する。これは&lt;x3/&gt;1.0&lt;x4/&gt;と次に大きい表現型の距離を与える。 浮動小数点値:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and
bitwise operators as well as standard mathematical functions are defined over them.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225045Z" creationid="hsugawa8651" creationdate="20181109T225045Z">
        <seg>Juliaは、さまざまな原始的な数値型を提供し、算術演算の完全な補完を提供します。 ビット演算子と標準数学関数がそれらの上に定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its
numeric primitive types, as well as providing portable, efficient implementations of a comprehensive
collection of standard mathematical functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131929Z" creationid="hsugawa8651" creationdate="20181113T131929Z">
        <seg>Juliaはすべての基本的な演算子とビット演算子の完全なコレクションを提供しています。 数値プリミティブ型で、包括的で効率的な包括的な実装を提供します。 標準数学関数のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides a comprehensive collection of mathematical functions and operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030755Z" creationid="hsugawa8651" creationdate="20181114T030755Z">
        <seg>Juliaは、数学的関数と演算子の包括的なコレクションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides a variety of control flow constructs:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225711Z" creationid="hsugawa8651" creationdate="20181109T225711Z">
        <seg>Juliaは、さまざまな制御フロー構成を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides additional functions to test numbers for special values, which can be useful in
situations like hash key comparisons:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030534Z" creationid="hsugawa8651" creationdate="20181114T030534Z">
        <seg>Juliaは特別な値の数値をテストするための追加機能を提供しています。 ハッシュ・キー比較のような状況:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides ease and expressiveness
for high-level numerical computing, in the same way as languages such
as R, MATLAB, and Python, but also supports general programming.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081706Z" creationid="hsugawa8651" creationdate="20181118T081706Z">
        <seg>JuliaはR、MATLAB、Pythonなどと同様に高度な数値計算のための簡単で高い表現力を持つ記法を提供しつつ、一般的なプログラミングもサポートします。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the
type of a given variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112000Z" creationid="hsugawa8651" creationdate="20181112T112000Z">
        <seg>Juliaは、指定されたタイプまたは指定されたタイプに対応するリテラル0および1を返す関数を返します。 指定された変数のタイプです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia supports federated management of packages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152821Z" creationid="hsugawa8651" creationdate="20181117T152821Z">
        <seg>Juliaは、パッケージの連合管理をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia supports simple tuple "destructuring" that facilitates this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101454Z" creationid="hsugawa8651" creationdate="20181112T101454Z">
        <seg>Juliaは単純なタプル"destructing"をサポートしており、これを容易にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia supports three forms of numerical conversion, which differ in their handling of inexact
conversions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031029Z" creationid="hsugawa8651" creationdate="20181114T031029Z">
        <seg>Juliaは、3つの形式の数値変換をサポートしていますが、それは不正確であるためです。 変換。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia understands three kinds of environments:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152915Z" creationid="hsugawa8651" creationdate="20181117T152915Z">
        <seg>Juliaは3種類の環境を理解しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia's base library has a an internal &lt;x1/&gt;sub2ind&lt;x2/&gt; function to calculate a linear index into an n-dimensional
array, based on a set of n multilinear indices - in other words, to calculate the index &lt;x3/&gt;i&lt;x4/&gt; that
can be used to index into an array &lt;x5/&gt;A&lt;x6/&gt; using &lt;x7/&gt;A[i]&lt;x8/&gt;, instead of &lt;x9/&gt;A[x,y,z,...]&lt;x10/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032243Z" creationid="hsugawa8651" creationdate="20181116T032243Z">
        <seg>Juliaのベースライブラリは、n次元の線形インデックスを計算するための内部&lt;x1/&gt;sub2ind&lt;x2/&gt;関数を持っています。 配列は、n個の多線形インデックスの集合に基づいて、言い換えれば、インデックス&lt;x3/&gt;i&lt;x4/&gt;を計算することを意味する。 &lt;x9/&gt;A[i]&lt;x8/&gt;を用いて、&lt;x9/&gt;A[x,y,z,…]&lt;x10/&gt;の代わりに、配列&lt;x5/&gt;A&lt;x6/&gt;をインデックスにすることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia's compiler uses type inference and generates
optimized code for scalar array indexing, allowing programs to be written in a style that is convenient
and readable, without sacrificing performance, and using less memory at times.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154155Z" creationid="hsugawa8651" creationdate="20181109T154155Z">
        <seg>Juliaのコンパイラーは型推論を使用し スカラー配列インデックスの最適化されたコードで、プログラムをスタイルに便利なスタイルで記述できるようにします。 パフォーマンスを犠牲にすることなく読み取り可能で、時にはメモリを減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia's load path is a stacked environment, for example.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152932Z" creationid="hsugawa8651" creationdate="20181117T152932Z">
        <seg>Juliaのロードパスは、たとえばスタックされた環境です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia's package loading mechanism allows this by distinguishing the two &lt;x43/&gt;Priv&lt;x44/&gt; packages by context and UUID.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152908Z" creationid="hsugawa8651" creationdate="20181117T152908Z">
        <seg>Juliaのパッケージロードメカニズムでは、2つの&lt;x43/&gt;Priv&lt;x44/&gt;パッケージをコンテキストとUUIDで識別することによってこれを実現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia's package loading mechanism handles this by not requiring package names to be globally unique, even within the dependency graph of a single project.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152839Z" creationid="hsugawa8651" creationdate="20181117T152839Z">
        <seg>Juliaのパッケージロードメカニズムは、単一のプロジェクトの依存グラフ内でも、パッケージ名をグローバルに一意にする必要がないため、これを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia's promotion system makes arithmetic operations on mixtures of argument types "just work"
naturally and automatically.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132201Z" creationid="hsugawa8651" creationdate="20181113T132201Z">
        <seg>Juliaのプロモーションシステムは、引数型の混合物に対して、単に「働く」演算を行う。 自動的に自動的に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Julia, like most technical computing languages, provides a first-class array implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154040Z" creationid="hsugawa8651" creationdate="20181109T154040Z">
        <seg>Juliaは、ほとんどの技術的なコンピューティング言語と同様、一流のアレイ実装を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as in &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-array-indexing), the &lt;x4/&gt;end&lt;x5/&gt; keyword may be used
to represent the last index of each dimension within the indexing brackets, as
determined by the size of the array being assigned into.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155438Z" creationid="hsugawa8651" creationdate="20181109T155438Z">
        <seg>&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man array indexing)の場合と同様に、&lt;x4/&gt;end&lt;x5/&gt;キーワードを使用することもできます。 インデックス・ブラケット内の各次元の最後のインデックスを表示するには、次のように指定します。 割り当てられているアレイのサイズによって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as in &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-array-indexing), the &lt;x4/&gt;end&lt;x5/&gt; keyword may be used
to represent the last index of each dimension within the indexing brackets, as
determined by the size of the array being assigned into. Indexed assignment
syntax without the &lt;x6/&gt;end&lt;x7/&gt; keyword is equivalent to a call to
&lt;x8/&gt;`setindex!`&lt;x9/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134933Z" creationid="hsugawa8651" creationdate="20181117T134933Z">
        <seg>&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man array indexing)の場合と同様に、&lt;x4/&gt;end&lt;x5/&gt;キーワードを使用することもできます。 インデックス・ブラケット内の各次元の最後のインデックスを表示するには、次のように指定します。 割り当てられる配列のサイズによって決定されます。インデックス付きの割り当て &lt;x6/&gt;end&lt;x7/&gt;キーワードがない構文は、次のような呼び出しに相当します。 &lt;x8/&gt;`setindex!`&lt;x9/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as text output is performed by &lt;x1/&gt;`print`&lt;x2/&gt; and user-defined types can indicate their textual
representation by overloading &lt;x3/&gt;`show`&lt;x4/&gt;, Julia provides a standardized mechanism for rich multimedia
output (such as images, formatted text, or even audio and video), consisting of three parts:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T090648Z" creationid="hsugawa8651" creationdate="20181112T043216Z">
        <seg>テキスト出力が&lt;x1/&gt;`print`&lt;x2/&gt;によって実行されるように、ユーザ定義型はそのテキストを示すことができる オーバーロード&lt;x3/&gt;"show`&lt;x4/&gt;をオーバーロードすることで表現することで、リッチなマルチメディアを実現するための標準化されたメカニズムを提供する 出力(イメージ、フォーマットされたテキスト、オーディオやビデオなど)、3つの部分から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like
inner functions used elsewhere in the language, variables from the enclosing scope can be
"captured" in the inner function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155005Z" creationid="hsugawa8651" creationdate="20181109T155005Z">
        <seg>ちょうど 言語で他の場所で使用される内部関数、囲みスコープからの変数は、次のようになります。 「取り込み」は内部機能である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like all the
other machinery, &lt;x3/&gt;broadcasted&lt;x4/&gt; also computes and exposes the combined broadcast style of its
arguments, so instead of specializing on &lt;x5/&gt;broadcasted(f, args...)&lt;x6/&gt;, you can specialize on
&lt;x7/&gt;broadcasted(::DestStyle, f, args...)&lt;x8/&gt; for any combination of style, function, and arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131620Z" creationid="hsugawa8651" creationdate="20181113T131620Z">
        <seg>まるで その他の機械は、&lt;x3/&gt;をブロードキャストして、その組み合わせを計算します。 引数は、&lt;x5/&gt;ブロードキャスト(f,args.)&lt;x6/&gt;に特化するのではなく、特殊化することができます。 &lt;x7/&gt;ブロードキャスト(::DestStyle,f,args.)&lt;x8/&gt;任意のスタイル、関数、引数の組み合わせに対して&lt;x8/&gt;を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like condition expressions used in &lt;x1/&gt;if&lt;x2/&gt;, &lt;x3/&gt;elseif&lt;x4/&gt; or the ternary operator, the operands of
&lt;x5/&gt;&amp;&amp;&lt;x6/&gt; or &lt;x7/&gt;||&lt;x8/&gt; must be boolean values (&lt;x9/&gt;true&lt;x10/&gt; or &lt;x11/&gt;false&lt;x12/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230809Z" creationid="hsugawa8651" creationdate="20181109T230809Z">
        <seg>&lt;x2/&gt;、&lt;x3/&gt;elseif&lt;x4/&gt;、または三元演算子の&lt;x1/&gt;で使用される条件式と同じように、オペランドは次のようになります。 &lt;x5/&gt;&amp;&amp;&lt;x6/&gt;または&lt;x7/&gt;&lt;x8/&gt;は、ブール値(&lt;x9/&gt;true&lt;x10/&gt;または&lt;x11/&gt;false&lt;x12/&gt;)である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal
integer literals and engineering notation for floating-point literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111916Z" creationid="hsugawa8651" creationdate="20181112T111916Z">
        <seg>並列リテラル係数構文は、2つの数値リテラル構文と矛盾する場合があります:16進数 浮動小数点リテラルの整数リテラルとエンジニアリング表記。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LLVM Interface</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042029Z" creationid="hsugawa8651" creationdate="20181110T042029Z">
        <seg>LLVM Interface</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larger integer literals that cannot be represented using only 32 bits but can be represented in
64 bits always create 64-bit integers, regardless of the system type:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225319Z" creationid="hsugawa8651" creationdate="20181109T225319Z">
        <seg>32ビットのみを使用して表現することはできないが、次のように表現できる整数リテラル 64ビットは、システムタイプに関係なく、常に64ビットの整数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Largest value</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225129Z" creationid="hsugawa8651" creationdate="20181109T225129Z">
        <seg>最大値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Left</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030817Z" creationid="hsugawa8651" creationdate="20181114T030817Z">
        <seg>Left</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Libc.MS_ASYNC&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043203Z" creationid="hsugawa8651" creationdate="20181112T043203Z">
        <seg>Libc.MS_ASYNC&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Libc.MS_INVALIDATE&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043204Z" creationid="hsugawa8651" creationdate="20181112T043204Z">
        <seg>Libc.MS_INVALIDATE&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Libc.MS_SYNC&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043205Z" creationid="hsugawa8651" creationdate="20181112T043205Z">
        <seg>Libc.MS_SYNC&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Libdl.dlclose(lib) &lt;x4/&gt; Close the library explicitly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152410Z" creationid="hsugawa8651" creationdate="20181117T152410Z">
        <seg>Libdl.dlclose(lib)&lt;x4/&gt;ライブラリを明示的に閉じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lightweight “green” threading
(&lt;a0&gt;coroutines&lt;/a0&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083202Z" creationid="hsugawa8651" creationdate="20181118T082816Z">
        <seg>軽量で”greenな”スレッドシステム [1] （ &lt;a0&gt;コルーチン&lt;/a0&gt; ）
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like &lt;x2/&gt;Dict&lt;x3/&gt; it uses &lt;x4/&gt;hash&lt;x5/&gt; for hashing and &lt;x6/&gt;isequal&lt;x7/&gt; for equality, unlike &lt;x8/&gt;Dict&lt;x9/&gt; it does
not convert keys on insertion.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032110Z" creationid="hsugawa8651" creationdate="20181114T032110Z">
        <seg>&lt;x2/&gt;Dict&lt;x3/&gt;と同様に、&lt;x4/&gt;はハッシュに&lt;x4/&gt;ハッシュ&lt;x5/&gt;を使用し、&lt;x8/&gt;等価&lt;x7/&gt;は&lt;x8/&gt;等価&lt;x7/&gt;である。 挿入時にキーを変換しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153944Z" creationid="hsugawa8651" creationdate="20181109T153944Z">
        <seg>ccallと同様に、これらの引数はすべてコンパイル時に評価され、containingメソッドが定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Limit usage of CPU features up to &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;; set to &lt;x4/&gt;help&lt;x5/&gt; to see the available options</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224739Z" creationid="hsugawa8651" creationdate="20181109T224739Z">
        <seg>CPU機能の使用を制限&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;に制限します。&lt;x4/&gt;ヘルプ&lt;x5/&gt;に設定すると、使用可能なオプションが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lisp-like macros and other metaprogramming facilities</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082943Z" creationid="hsugawa8651" creationdate="20181118T082943Z">
        <seg>Lispライクなマクロやその他のメタプログラミング機構</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal &lt;x3/&gt;`Float32`&lt;x4/&gt; values can be
entered by writing an &lt;x5/&gt;f&lt;x6/&gt; in place of &lt;x7/&gt;e&lt;x8/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110604Z" creationid="hsugawa8651" creationdate="20181112T110604Z">
        <seg>リテラル&lt;x3/&gt;`Float32'&lt;x4/&gt;の値は &lt;x7/&gt;e&lt;x8/&gt;の代わりに&lt;x5/&gt;f&lt;x6/&gt;を書き込むことによって入力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal floating-point numbers are represented in the standard formats, using
&lt;x1/&gt;E-notation&lt;x2/&gt; when necessary:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110539Z" creationid="hsugawa8651" creationdate="20181112T110539Z">
        <seg>リテラル浮動小数点数は、標準形式で表されます。 &lt;x1/&gt;E表記法&lt;x2/&gt;必要に応じて&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal integers are represented in the standard manner:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225202Z" creationid="hsugawa8651" creationdate="20181109T225202Z">
        <seg>リテラル整数は、標準的な方法で表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal one of type &lt;x1/&gt;x&lt;x2/&gt; or type of variable &lt;x3/&gt;x&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112020Z" creationid="hsugawa8651" creationdate="20181112T112020Z">
        <seg>&lt;x1/&gt;x&lt;x2/&gt;または変数&lt;x3/&gt;x&lt;x4/&gt;の型のリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal zero of type &lt;x1/&gt;x&lt;x2/&gt; or type of variable &lt;x3/&gt;x&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112010Z" creationid="hsugawa8651" creationdate="20181112T112010Z">
        <seg>&lt;x1/&gt;x&lt;x2/&gt;のリテラル0、または変数&lt;x3/&gt;x&lt;x4/&gt;のタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Load &lt;x1/&gt;&lt;x2/&gt;/.julia/config/startup.jl&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031604Z" creationid="hsugawa8651" creationdate="20181109T224646Z">
        <seg>&lt;x1/&gt;&lt;x2/&gt;/.julia/config/startup.jl&lt;x3/&gt;をロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Load &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt; immediately on all processors</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224705Z" creationid="hsugawa8651" creationdate="20181109T224705Z">
        <seg>すべてのプロセッサで&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;を即時にロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Load or save history</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224730Z" creationid="hsugawa8651" creationdate="20181109T224730Z">
        <seg>履歴をロードまたは保存する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical indexing</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135104Z" creationid="hsugawa8651" creationdate="20181117T135104Z">
        <seg>論理索引付け</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many functions for constructing and initializing arrays are provided.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154333Z" creationid="hsugawa8651" creationdate="20181109T154333Z">
        <seg>配列を作成して初期化するための多くの関数が用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many methods in Julia such as &lt;x1/&gt;`unsafe_load`&lt;x2/&gt; and
&lt;x3/&gt;`String`&lt;x4/&gt; make copies of data instead of taking ownership of the buffer, so that it is
safe to free (or alter) the original data without affecting Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152244Z" creationid="hsugawa8651" creationdate="20181117T152244Z">
        <seg>&lt;x1/&gt;"unsafe_load"&lt;x2/&gt;などのJuliaでは多くのメソッドがあり &lt;x3/&gt;'String'&lt;x4/&gt;は、バッファの所有権を取得する代わりに、データのコピーを作成します。したがって、次のような結果が得られます。 Juliaに影響を与えることなく、元のデータを自由に(または変更)することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many newcomers to Julia find the use of &lt;x1/&gt;...&lt;x2/&gt; operator confusing.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025227Z" creationid="hsugawa8651" creationdate="20181110T025227Z">
        <seg>Juliaの新規参入者の多くは、&lt;x1/&gt;.…&lt;x2/&gt;演算子を混同していることを発見しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many non- mutating functions are implemented by
calling a function of the same name with an added &lt;x6/&gt;!&lt;x7/&gt; at the end on an explicit
copy of the input, and returning that copy.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154222Z" creationid="hsugawa8651" creationdate="20181109T154222Z">
        <seg>多くの非重複関数は、次のように実装されています。 明示的に最後に&lt;x6/&gt;!&lt;x7/&gt;を追加して、同じ名前の関数を呼び出します。 入力のコピーを返し、そのコピーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mapping C Functions to Julia</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151457Z" creationid="hsugawa8651" creationdate="20181117T151457Z">
        <seg>C関数をジュリアにマッピングする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mapping C Types to Julia</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150547Z" creationid="hsugawa8651" creationdate="20181117T150547Z">
        <seg>Cタイプをジュリアにマッピングする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mathematical Functions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043424Z" creationid="hsugawa8651" creationdate="20181112T043424Z">
        <seg>Mathematical Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mathematics</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043421Z" creationid="hsugawa8651" creationdate="20181112T043421Z">
        <seg>Mathematics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory Ownership</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151338Z" creationid="hsugawa8651" creationdate="20181117T151338Z">
        <seg>メモリの所有権</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory allocation and deallocation of such objects must be handled by calls to the appropriate
cleanup routines in the libraries being used, just like in any C program.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151428Z" creationid="hsugawa8651" creationdate="20181117T151428Z">
        <seg>このようなオブジェクトのメモリ割り当てと解放は、適切なものを呼び出して処理する必要があります。 これは、Cプログラムの場合と同様に、使用されているライブラリ内のクリーンアップルーチンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory layout</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041853Z" creationid="hsugawa8651" creationdate="20181110T041853Z">
        <seg>Memory layout</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MergeSort&lt;x1/&gt; is an O(n log n) stable sorting algorithm but is not in-place – it requires a temporary
array of half the size of the input array – and is typically not quite as fast as &lt;x2/&gt;QuickSort&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064117Z" creationid="hsugawa8651" creationdate="20181114T064117Z">
        <seg>MergeSort&lt;x1/&gt;は、O(nログn)安定ソートアルゴリズムですが、インプレースではありません。一時的に必要です。 入力アレイのサイズの半分の配列で、通常は&lt;x2/&gt;QuickSort&lt;x3/&gt;のように高速ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MethodError&lt;x1/&gt; should be thrown if no supported MIME types are found
for &lt;x2/&gt;x&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043329Z" creationid="hsugawa8651" creationdate="20181112T043329Z">
        <seg>サポートされているMIMEタイプが見つからない場合は、MethodError&lt;x1/&gt;をスローする必要があります。 &lt;x2/&gt;x&lt;x3/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods to implement</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094350Z" creationid="hsugawa8651" creationdate="20181118T094350Z">
        <seg>実装する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030621Z" creationid="hsugawa8651" creationdate="20181114T030621Z">
        <seg>符号付き整数、符号なし整数、浮動小数点間の混合型比較は、難しいことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifications to mutable values (such as &lt;x3/&gt;Array&lt;x4/&gt;s) made within
a function will be visible to the caller.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025712Z" creationid="hsugawa8651" creationdate="20181110T025712Z">
        <seg>(&lt;x3/&gt;Array&lt;x4/&gt;s)のような可変値への変更 呼び出し側から関数が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules can be replaced by redefining them, and so if you wrap all your new code inside a module
you can redefine types and constants.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024738Z" creationid="hsugawa8651" creationdate="20181110T024738Z">
        <seg>モジュールを再定義すると、モジュールを再定義することができます。したがって、モジュール内の新しいコードをすべてラップすることができます。 タイプと定数を再定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More About Callbacks</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152638Z" creationid="hsugawa8651" creationdate="20181117T152638Z">
        <seg>コールバックの詳細</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More concrete examples
can be found within the &lt;x25/&gt;&lt;x26/&gt;&lt;x27/&gt;(@ref man-interface-strided-arrays).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160515Z" creationid="hsugawa8651" creationdate="20181109T160515Z">
        <seg>具体的な事例 は、&lt;x25/&gt;&lt;x26/&gt;&lt;x27/&gt;(@ref man interface strided配列)内にあることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More on this below.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152745Z" creationid="hsugawa8651" creationdate="20181117T152745Z">
        <seg>以下にその詳細を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More specifically, &lt;x1/&gt;a .^ b&lt;x2/&gt; is parsed as the &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man-vectorized)
&lt;x6/&gt;(^).(a,b)&lt;x7/&gt;, which performs a &lt;x8/&gt;&lt;x9/&gt;&lt;x10/&gt;(@ref Broadcasting) operation:
it can combine arrays and scalars, arrays of the same size (performing
the operation elementwise), and even arrays of different shapes (e.g.
combining row and column vectors to produce a matrix).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132539Z" creationid="hsugawa8651" creationdate="20181113T132539Z">
        <seg>より具体的には、&lt;x1/&gt;a.^b&lt;x2/&gt;は、&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref manベクトル化)として解析されます。 &lt;x6/&gt;(^).(a,b)&lt;x7/&gt;&lt;x8/&gt;&lt;x8/&gt;&lt;x9/&gt;(@ref Broadcasting)動作を実行します。 配列とスカラを組み合わせることができ、同じサイズの配列(実行することができる) この操作エレメントは、異なる形状の配列(例えば 行列を生成するために行と列のベクトルを結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, &lt;x5/&gt;&amp;&lt;x6/&gt; may be used with any expression,
such as &lt;x7/&gt;&amp;0&lt;x8/&gt; or &lt;x9/&gt;&amp;f(x)&lt;x10/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151902Z" creationid="hsugawa8651" creationdate="20181117T151858Z">
        <seg>さらに、&lt;x5/&gt;&amp;&lt;x6/&gt;は、任意の発現とともに使用することができる。 &lt;x7/&gt;&amp;0&lt;x8/&gt;や&lt;x9/&gt;&amp;f(x)&lt;x10/&gt;のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, an attempt to use &lt;x8/&gt;A&lt;x9/&gt; will likely result in an error, because most methods are not defined on type &lt;x10/&gt;Nothing&lt;x11/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024705Z" creationid="hsugawa8651" creationdate="20181110T024705Z">
        <seg>さらに、&lt;x8/&gt;A&lt;x9/&gt;を使用しようとすると、エラーが発生する可能性があります。なぜなら、ほとんどのメソッドは、タイプ&lt;x10/&gt;Nothing&lt;x11/&gt;では定義されていないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, like
all vectorized "dot calls," these "dot operators" are
&lt;x11/&gt;fusing&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132535Z" creationid="hsugawa8651" creationdate="20181113T132535Z">
        <seg>さらに すべてのベクトル化された"ドット・コール"ドット・オペレーター"ドット・オペレーター"は &lt;x11/&gt;融合&lt;x12/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, these functions (like any Julia function) can be applied in "vectorized" fashion to
arrays and other collections with the &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-vectorized) &lt;x4/&gt;f.(A)&lt;x5/&gt;,
e.g. &lt;x6/&gt;sin.(A)&lt;x7/&gt; will compute the sine of each element of an array &lt;x8/&gt;A&lt;x9/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030803Z" creationid="hsugawa8651" creationdate="20181114T030803Z">
        <seg>さらに、これらの関数(Julia関数のような)は、「ベクトル化」された形式で適用することができます。 &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man vectorized)&lt;x4/&gt;f.(A)&lt;x5/&gt;(A)&lt;x5/&gt;の配列とその他のコレクション 例えば、&lt;x6/&gt;sin(A)&lt;x7/&gt;は、配列&lt;x8/&gt;A&lt;x9/&gt;の各要素の正弦を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most
technical computing languages pay a lot of attention to their array implementation at the expense
of other containers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154112Z" creationid="hsugawa8651" creationdate="20181109T154112Z">
        <seg>ほとんど テクニカル・コンピューティング言語は、アレイ実装に多大な関心を払っています。 その他の容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most C and Fortran libraries ship
compiled as shared libraries already, but if you are compiling the code yourself using GCC (or
Clang), you will need to use the &lt;x1/&gt;-shared&lt;x2/&gt; and &lt;x3/&gt;-fPIC&lt;x4/&gt; options.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160550Z" creationid="hsugawa8651" creationdate="20181109T160550Z">
        <seg>ほとんどのCおよびFortranライブラリは出荷されています。 はすでに共有ライブラリとしてコンパイルされていますが、GCCを使用して自分でコードをコンパイルする場合は Clang)は、&lt;x1/&gt;-shared&lt;x2/&gt;および&lt;x3/&gt;-fPIC&lt;x4/&gt;オプションを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of these functions
also accept a first input &lt;x3/&gt;T&lt;x4/&gt;, which is the element type of the array.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154343Z" creationid="hsugawa8651" creationdate="20181109T154343Z">
        <seg>これらの関数の大部分 また、配列の要素タイプである最初の入力&lt;x3/&gt;T&lt;x4/&gt;を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes
it is important to know the distance between two adjacent representable floating-point numbers,
which is often known as &lt;x1/&gt;machine epsilon&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111132Z" creationid="hsugawa8651" creationdate="20181112T111132Z">
        <seg>ほとんどの実数は浮動小数点数で正確に表現することはできません。したがって、多くの目的で使用することはできません。 2つの隣接する表現可能浮動小数点数間の距離を知ることが重要です。 これはしばしば&lt;x1/&gt;機械イプシロン&lt;x2/&gt;と呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-Threading</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043427Z" creationid="hsugawa8651" creationdate="20181112T043427Z">
        <seg>Multi-Threading</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multimedia I/O</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043215Z" creationid="hsugawa8651" creationdate="20181112T043215Z">
        <seg>Multimedia I/O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multimedia-capable display backends may be registered by subclassing a generic &lt;x1/&gt;AbstractDisplay&lt;x2/&gt; type
and pushing them onto a stack of display backends via &lt;x3/&gt;`pushdisplay`&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043256Z" creationid="hsugawa8651" creationdate="20181112T043256Z">
        <seg>マルチメディア対応のディスプレイバックエンドは、一般的な&lt;x1/&gt;AbstractDisplay&lt;x2/&gt;タイプをサブクラス化することによって登録することができる。 そして、&lt;x3/&gt;"プッシュディスプレイ"&lt;x4/&gt;を介して、ディスプレイのバックエンドのスタックに押し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple &lt;x9/&gt;if @generated&lt;x10/&gt; blocks may occur, in which case the generated implementation uses
all of the &lt;x11/&gt;then&lt;x12/&gt; blocks and the alternate implementation uses all of the &lt;x13/&gt;else&lt;x14/&gt; blocks.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032408Z" creationid="hsugawa8651" creationdate="20181116T032408Z">
        <seg>@生成&lt;x10/&gt;ブロックが発生した場合には複数の&lt;x9/&gt;が存在し、その場合には生成された実装が使用される。 すべての&lt;x11/&gt;&lt;x12/&gt;ブロックと代替実装は、すべて&lt;x13/&gt;else&lt;x14/&gt;ブロックを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple arguments to &lt;x15/&gt;D[...]&lt;x16/&gt; are converted to tuples; for example, the syntax
&lt;x17/&gt;D[x,y]&lt;x18/&gt;  is equivalent to &lt;x19/&gt;D[(x,y)]&lt;x20/&gt;, i.e. it refers to the value keyed by the tuple &lt;x21/&gt;(x,y)&lt;x22/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063224Z" creationid="hsugawa8651" creationdate="20181114T063224Z">
        <seg>&lt;x15/&gt;D[.…]&lt;x16/&gt;への複数の引数は、タプルに変換されます。たとえば、構文は &lt;x17/&gt;D[x,y]&lt;x18/&gt;は、&lt;x19/&gt;D[(x,y)]&lt;x20/&gt;、即ち、タプル&lt;X21/&gt;(x,y)&lt;x22/&gt;によってキー付けされる値を意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>N/A</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110219Z" creationid="hsugawa8651" creationdate="20181112T110219Z">
        <seg>N/A</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN16&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110837Z" creationid="hsugawa8651" creationdate="20181112T110837Z">
        <seg>NaN16&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN32&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110838Z" creationid="hsugawa8651" creationdate="20181112T110838Z">
        <seg>NaN32&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110839Z" creationid="hsugawa8651" creationdate="20181112T110839Z">
        <seg>NaN&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN&lt;x1/&gt; is not equal to, not less than, and not greater than anything, including itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030509Z" creationid="hsugawa8651" creationdate="20181114T030509Z">
        <seg>NaN&lt;x1/&gt;は、それ自体を含めて、以下ではなく、それ以上ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Name</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110802Z" creationid="hsugawa8651" creationdate="20181112T110802Z">
        <seg>Name</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized
expression, however, can be used to imply multiplication:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111842Z" creationid="hsugawa8651" creationdate="20181112T111842Z">
        <seg>括弧で括られた2つの表現の並列化はなく、括弧で括られたものの前に変数を配置することもない しかし、表現は乗算を意味するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested "dot calls" &lt;x5/&gt;f.(...)&lt;x6/&gt; (including calls to &lt;x7/&gt;.+&lt;x8/&gt; etcetera)
&lt;x9/&gt;&lt;x10/&gt;&lt;x11/&gt;(@ref man-dot-operators) into a single &lt;x12/&gt;broadcast&lt;x13/&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160131Z" creationid="hsugawa8651" creationdate="20181109T160131Z">
        <seg>ネストされた「ドットコール」&lt;x5/&gt;f.(...)&lt;x6/&gt;(&lt;x7/&gt;.+&lt;x8/&gt;eteteraへの呼び出しを含む) &lt;x9/&gt;&lt;x10/&gt;&lt;x11/&gt;(@ref man dot演算子)は、単一の&lt;x12/&gt;ブロードキャスト・&lt;x13/&gt;コールに対して使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Network I/O</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150200Z" creationid="hsugawa8651" creationdate="20181117T150200Z">
        <seg>ネットワークI/O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No matter how an &lt;x2/&gt;AbstractArray{T,N}&lt;x3/&gt; is represented internally, &lt;x4/&gt;T&lt;x5/&gt; is the type of
object returned by &lt;x6/&gt;integer&lt;x7/&gt; indexing (&lt;x8/&gt;A[1, ..., 1]&lt;x9/&gt;, when &lt;x10/&gt;A&lt;x11/&gt; is not empty) and &lt;x12/&gt;N&lt;x13/&gt; should be
the length of the tuple returned by &lt;x14/&gt;`size`&lt;x15/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160357Z" creationid="hsugawa8651" creationdate="20181109T160357Z">
        <seg>&lt;x2/&gt;AbstractArray{T,N}&lt;x3/&gt;が内部的にどのように表されても、&lt;x4/&gt;T&lt;x5/&gt;は以下のタイプである。 &lt;x6/&gt;整数&lt;x7/&gt;インデックス(&lt;x8/&gt;A[1,.…,1]&lt;x9/&gt;,&lt;x10/&gt;)は&lt;x10/&gt;A&lt;x11/&gt;であり、&lt;x12/&gt;N&lt;x13/&gt;は&lt;x12/&gt;n&lt;x13/&gt;である。 &lt;x14/&gt;`size'&lt;x15/&gt;によって返されるタプルの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No need to vectorize code for performance; devectorized code is fast</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082754Z" creationid="hsugawa8651" creationdate="20181118T082737Z">
        <seg>性能のためにコードをベクトル化する必要がありません。ベクトル化されていないコードも高速に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No, you are not allowed to have a &lt;x1/&gt;using&lt;x2/&gt; or &lt;x3/&gt;import&lt;x4/&gt; statement inside a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025132Z" creationid="hsugawa8651" creationdate="20181110T025132Z">
        <seg>いいえ、関数内の&lt;x/&gt;または&lt;x3/&gt;インポート&lt;x4/&gt;ステートメントを&lt;x2/&gt;のインポートを使用することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-boolean integers</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134951Z" creationid="hsugawa8651" creationdate="20181117T134951Z">
        <seg>非ブール値の整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-constant Function Specifications</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152257Z" creationid="hsugawa8651" creationdate="20181117T152257Z">
        <seg>非定常関数仕様</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-traditional indices&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094502Z" creationid="hsugawa8651" creationdate="20181118T094502Z">
        <seg>非伝統的なインデックス&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None of the examples
given here provide any type annotations on their arguments, meaning that they are applicable to
all types of arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T105935Z" creationid="hsugawa8651" creationdate="20181112T105935Z">
        <seg>None of the examples
given here provide any type annotations on their arguments, meaning that they are applicable to
all types of arguments.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all types support &lt;x1/&gt;axes&lt;x2/&gt; and indexing, but many are convenient to allow in broadcast.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131033Z" creationid="hsugawa8651" creationdate="20181113T131033Z">
        <seg>すべてのタイプが&lt;x1/&gt;軸&lt;x2/&gt;とインデックス作成をサポートするわけではありませんが、ブロードキャストでは多くの場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
that if the object was not originally allocated by Julia, the new object will never be finalized
by Julia's garbage collector.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152543Z" creationid="hsugawa8651" creationdate="20181117T152543Z">
        <seg>注 オブジェクトが元々ジュリアによって割り当てられていない場合、新しいオブジェクトは最終的にはファイナライズされません。 ジュリアのガーベジ・コレクターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that UTF-8 string data in Julia is internally
NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making
a copy (but using the &lt;x7/&gt;Cwstring&lt;x8/&gt; type will cause an error to be thrown if the string itself contains
NUL characters).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151033Z" creationid="hsugawa8651" creationdate="20181117T151033Z">
        <seg>また、JuliaのUTF-8文字列データは内部的に存在することにも注意してください。 NUE終端されているので、Nendは コピー(ただし、&lt;x7/&gt;Cwstring&lt;x8/&gt;タイプを使用すると、文字列自体にエラーが発生することがあります) NUL文字)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note how the size of the resulting array is different in the last two cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160912Z" creationid="hsugawa8651" creationdate="20181114T160912Z">
        <seg>最後の2つのケースでは、結果として得られる配列のサイズが異なることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;x1/&gt;islinux&lt;x2/&gt; and &lt;x3/&gt;isapple&lt;x4/&gt; are mutually exclusive subsets of &lt;x5/&gt;isunix&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224942Z" creationid="hsugawa8651" creationdate="20181109T224942Z">
        <seg>&lt;x1/&gt;アリヌス&lt;x2/&gt;および&lt;x3/&gt;イサプリ&lt;x4/&gt;は、&lt;x5/&gt;イシュニク&lt;x6/&gt;の相互排他的なサブセットであることに留意されたい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;x9/&gt;ARGS&lt;x10/&gt; is
also set when a Julia expression is given using the &lt;x11/&gt;-e&lt;x12/&gt; option on the command line (see the
&lt;x13/&gt;julia&lt;x14/&gt; help output below) but &lt;x15/&gt;PROGRAM_FILE&lt;x16/&gt; will be empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091953Z" creationid="hsugawa8651" creationdate="20181109T224338Z">
        <seg>コマンドラインで &lt;x11/&gt;-e&lt;x12/&gt; オプションが設定された際にも &lt;x9/&gt;ARGS&lt;x10/&gt; は設定されます（下の &lt;x13/&gt;julia&lt;x14/&gt; ヘルプ出力を参照してください）が、&lt;x15/&gt;PROGRAM_FILE&lt;x16/&gt;は空です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Julia
knows how to convert an array into a &lt;x5/&gt;Ptr{Cdouble}&lt;x6/&gt;, how to compute the size of a type in bytes
(identical to C's &lt;x7/&gt;sizeof&lt;x8/&gt; operator), and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150540Z" creationid="hsugawa8651" creationdate="20181117T150540Z">
        <seg>ジュリア 配列を&lt;x5/&gt;Ptr{Cdouble}&lt;x6/&gt;に変換する方法を知っています。バイト単位でタイプのサイズを計算する方法 (Cの&lt;x7/&gt;sizeof&lt;x8/&gt;演算子と同じ)などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that comparisons such as &lt;x1/&gt;==&lt;x2/&gt; operate on whole arrays, giving a single boolean
answer.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160005Z" creationid="hsugawa8651" creationdate="20181109T160005Z">
        <seg>&lt;x1/&gt;==&lt;x2/&gt;のような比較は、すべての配列に対して動作し、単一のブール値を与えることに注意してください。 答えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that comparisons such as &lt;x1/&gt;==&lt;x2/&gt; operate on whole arrays, giving a single boolean
answer. Use dot operators like &lt;x3/&gt;.==&lt;x4/&gt; for elementwise comparisons. (For comparison
operations like &lt;x5/&gt;&lt;&lt;x6/&gt;, &lt;x7/&gt;only&lt;x8/&gt; the elementwise &lt;x9/&gt;.&lt;&lt;x10/&gt; version is applicable to arrays.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135141Z" creationid="hsugawa8651" creationdate="20181117T135141Z">
        <seg>&lt;x1/&gt;==&lt;x2/&gt;のような比較は、すべての配列に対して動作し、単一のブール値を与えることに注意してください。 答え:&lt;x3/&gt;.==&lt;x4/&gt;のようなドット演算子を使用して、要素ごとの比較を行います(比較のために)。 &lt;x5/&gt;&lt;x6/&gt;のような操作、&lt;x7/&gt;&lt;x6/&gt;&lt;x8/&gt;&lt;x10/&gt;&lt;x8/&gt;&lt;x10/&gt;は、配列に適用されます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that events may be coalesced, so multiple calls to &lt;x1/&gt;uv_async_send&lt;x2/&gt; may result in a single wakeup
notification to the condition.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152636Z" creationid="hsugawa8651" creationdate="20181117T152636Z">
        <seg>イベントは合体することがあるので、&lt;x1/&gt;uv_async_send&lt;x2/&gt;への複数の呼び出しは単一のウェイクアップを引き起こす可能性があることに注意してください。 条件への通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that for this code to work correctly, &lt;x1/&gt;result_array&lt;x2/&gt; must be declared to be of type &lt;x3/&gt;Ref{Cdouble}&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152205Z" creationid="hsugawa8651" creationdate="20181117T152205Z">
        <seg>このコードが正しく動作するためには、&lt;x1/&gt;の結果_array&lt;x2/&gt;は&lt;x3/&gt;Ref{Cdouble}&lt;x4/&gt;の型であることが宣言されている必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it's very important to specify the two parameters of the &lt;x1/&gt;AbstractArray&lt;x2/&gt;; the first
defines the &lt;x3/&gt;`eltype`&lt;x4/&gt;, and the second defines the &lt;x5/&gt;`ndims`&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083208Z" creationid="hsugawa8651" creationdate="20181113T083208Z">
        <seg>&lt;x1/&gt;AbstractArray&lt;x2/&gt;の2つのパラメータを指定することが非常に重要であることに注意してください。最初のパラメータは次のようになります。 &lt;x3/&gt;'エルテープ&lt;x4/&gt;を定義し、2番目は&lt;x5/&gt;'ンダムス''&lt;x6/&gt;を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no C header files are used anywhere in the process of calling C functions: you are responsible
for making sure that your Julia types and call signatures accurately reflect those in the C header
file.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150553Z" creationid="hsugawa8651" creationdate="20181117T150553Z">
        <seg>Cの関数を呼び出すプロセスでは、Cヘッダー・ファイルは使用されないことに注意してください。 あなたのジュリア・タイプとコール・シグニチャーがCヘッダーにあるものを正確に反映していることを確認するために ファイルを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no C header files are used anywhere in the process of calling C functions: you are responsible
for making sure that your Julia types and call signatures accurately reflect those in the C header
file. (The &lt;x1/&gt;Clang package&lt;x2/&gt; can be used to auto-generate
Julia code from a C header file.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134221Z" creationid="hsugawa8651" creationdate="20181117T134221Z">
        <seg>Cの関数を呼び出すプロセスでは、Cヘッダー・ファイルは使用されないことに注意してください。 あなたのジュリア・タイプとコール・シグニチャーがCヘッダーにあるものを正確に反映していることを確認するために ファイル(&lt;x1/&gt;Clangパッケージ&lt;x2/&gt;は自動生成のために使用できます。 Cヘッダー・ファイルからのJuliaコード。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no whitespace may come between a numeric literal coefficient
and the identifier or parenthesized expression which it multiplies.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111907Z" creationid="hsugawa8651" creationdate="20181112T111907Z">
        <seg>数値リテラル係数の間に空白がないことに注意してください。 また、乗算する識別子または括弧で括られた式を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that symbols such as &lt;x1/&gt;:sin&lt;x2/&gt; return precedence &lt;x3/&gt;0&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031020Z" creationid="hsugawa8651" creationdate="20181114T031020Z">
        <seg>&lt;x1/&gt;:sin&lt;x2/&gt;return precedence&lt;x3/&gt;0&lt;x4/&gt;のような記号があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the argument
list can — and often does — include other nested &lt;x4/&gt;Broadcasted&lt;x5/&gt; wrappers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131346Z" creationid="hsugawa8651" creationdate="20181113T131346Z">
        <seg>引数は リストは、他のネストされた&lt;x4/&gt;ブロードキャストされた&lt;x5/&gt;ラッパーを含むことが多い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the argument type tuple must be written as &lt;x1/&gt;(Cstring,)&lt;x2/&gt;, rather than &lt;x3/&gt;(Cstring)&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224054Z" creationid="hsugawa8651" creationdate="20181109T224054Z">
        <seg>引数のタイプは、&lt;x3/&gt;(Cstring)&lt;x4/&gt;ではなく、&lt;x1/&gt;(Cstring,)&lt;x2/&gt;として記述する必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the argument type tuple must be written as &lt;x1/&gt;(Cstring,)&lt;x2/&gt;, rather than &lt;x3/&gt;(Cstring)&lt;x4/&gt;. This
is because &lt;x5/&gt;(Cstring)&lt;x6/&gt; is just the expression &lt;x7/&gt;Cstring&lt;x8/&gt; surrounded by parentheses, rather than
a 1-tuple containing &lt;x9/&gt;Cstring&lt;x10/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133827Z" creationid="hsugawa8651" creationdate="20181117T133827Z">
        <seg>引数のタイプは、&lt;x3/&gt;(Cstring)&lt;x4/&gt;ではなく&lt;x1/&gt;(Cstring)&lt;x2/&gt;として記述する必要があることに注意してください。 &lt;x5/&gt;(Cstring)&lt;x6/&gt;は、&lt;x7/&gt;Cstring&lt;x8/&gt;で囲まれた括弧で囲まれた表現であり &lt;x9/&gt;Cstring&lt;x10/&gt;:を含む1組のタプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the set of operations that should not be attempted in a generated function is unbounded,
and the runtime system can currently only detect a subset of the invalid operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032217Z" creationid="hsugawa8651" creationdate="20181116T032217Z">
        <seg>生成された関数で試行されるべきではない一連の操作は、制限されないことに注意してください。 ランタイム・システムは、現在、無効な操作のサブセットのみを検出できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the spaces around &lt;x19/&gt;?&lt;x20/&gt; and &lt;x21/&gt;:&lt;x22/&gt; are mandatory: an expression
like &lt;x23/&gt;a?b:c&lt;x24/&gt; is not a valid ternary expression (but a newline is acceptable after both the &lt;x25/&gt;?&lt;x26/&gt; and
the &lt;x27/&gt;:&lt;x28/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230058Z" creationid="hsugawa8651" creationdate="20181109T230058Z">
        <seg>&lt;x19/&gt;?&lt;x20/&gt;と&lt;X21/&gt;:&lt;x22/&gt;以外のスペースは必須です。式は次のようになります。 &lt;x23/&gt;a?b:c&lt;x24/&gt;は、有効な三元表現ではありません(ただし、&lt;x25/&gt;?&lt;x26/&gt;&lt;x26/&gt;)は、&lt;x25/&gt;?&lt;x26/&gt;と &lt;x27/&gt;:&lt;x28/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit
Evaluation in Julia, as outlined in the next section.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230030Z" creationid="hsugawa8651" creationdate="20181109T230030Z">
        <seg>非常に短い条件文(oneliner)は、短絡を使用して頻繁に表現されることに注意してください。 次のセクションで概説されているように、Juliaでの評価。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when using &lt;x1/&gt;ccall&lt;x2/&gt; with the tuple input
(e.g., &lt;x3/&gt;ccall((:my_fcn, "./my_lib.so"), ...)&lt;x4/&gt;), the library is opened implicitly
and it may not be explicitly closed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152413Z" creationid="hsugawa8651" creationdate="20181117T152413Z">
        <seg>タプル入力で&lt;x1/&gt;ccall&lt;x2/&gt;を使用するときに注意してください。 (例:&lt;x3/&gt;ccall((:my_fcn,"./my_lib.so"),.)&lt;x4/&gt;)ライブラリは暗黙的にオープンされます。 明示的にクローズされることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the dot syntax is also applicable to user-defined operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132633Z" creationid="hsugawa8651" creationdate="20181113T132633Z">
        <seg>ドット構文は、ユーザ定義の演算子にも適用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the evaluation behavior of chained comparisons:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030727Z" creationid="hsugawa8651" creationdate="20181114T030727Z">
        <seg>チェーン化された比較の評価動作に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note though, that &lt;x10/&gt;import X&lt;x11/&gt; can load different packages in different contexts: &lt;x12/&gt;X&lt;x13/&gt; can refer to one package named &lt;x14/&gt;X&lt;x15/&gt; in the main project but potentially different packages named &lt;x16/&gt;X&lt;x17/&gt; in each dependency.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152743Z" creationid="hsugawa8651" creationdate="20181117T152743Z">
        <seg>ただし、&lt;x10/&gt;インポートX&lt;x11/&gt;は異なるコンテキストで異なるパッケージをロードできます。&lt;x12/&gt;X&lt;x13/&gt;は主プロジェクトで&lt;x14/&gt;X&lt;x15/&gt;という名前のパッケージを参照できますが、各依存関係では&lt;x16/&gt;X&lt;x17/&gt;という名前のパッケージがある可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, though, that the above &lt;x1/&gt;only&lt;x2/&gt; defines &lt;x3/&gt;`getindex`&lt;x4/&gt; with one integer index.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113135Z" creationid="hsugawa8651" creationdate="20181112T113135Z">
        <seg>しかし、上記の&lt;x1/&gt;は、1つの整数インデックスを有する&lt;x3/&gt;'getindex'&lt;x4/&gt;を定義することに注意されたい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151250Z" creationid="hsugawa8651" creationdate="20181117T151250Z">
        <seg>注:この機能は現在、64ビットのx86およびAArch64プラットフォームでのみ実装されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that this is an &lt;x1/&gt;IndexCartesian&lt;x2/&gt; array, so we must manually define &lt;x3/&gt;`getindex`&lt;x4/&gt; and &lt;x5/&gt;`setindex!`&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083225Z" creationid="hsugawa8651" creationdate="20181113T083225Z">
        <seg>これは、&lt;x1/&gt;IndexCartesian&lt;x2/&gt;配列であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that we have to be careful about the return type: &lt;x1/&gt;qsort&lt;x2/&gt; expects a function returning
a C &lt;x3/&gt;int&lt;x4/&gt;, so we annotate the return type of the function to be sure it returns a &lt;x5/&gt;Cint&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133254Z" creationid="hsugawa8651" creationdate="20181117T133254Z">
        <seg>戻り値のタイプに注意する必要があることに注意してください。&lt;x1/&gt;qsort&lt;x2/&gt;qsort&lt;x2/&gt;は関数を返すことに注意してください。 C&lt;x3/&gt;int&lt;x4/&gt;であるため、関数の戻り値の型に注釈を付けて、&lt;x5/&gt;Cint&lt;x6/&gt;を返すことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that, after
the function call, &lt;x9/&gt;x&lt;x10/&gt; is still bound to the same array, but the content of that array changed:
the variables &lt;x11/&gt;A&lt;x12/&gt; and &lt;x13/&gt;x&lt;x14/&gt; were distinct bindings referring to the same mutable &lt;x15/&gt;Array&lt;x16/&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025111Z" creationid="hsugawa8651" creationdate="20181110T025111Z">
        <seg>次の点に注目してください。 関数呼び出し&lt;x9/&gt;x&lt;x10/&gt;は、まだ同じ配列にバインドされていますが、その配列の内容は変更されています。 変数&lt;x11/&gt;A&lt;x12/&gt;および&lt;x13/&gt;x14/&gt;は、同じ可変の&lt;x15/&gt;配列&lt;x16/&gt;オブジェクトを参照する別個のバインディングである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now &lt;x1/&gt;OrderedPair&lt;x2/&gt; objects can only be constructed such that &lt;x3/&gt;x &lt;= y&lt;x4/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155749Z" creationid="hsugawa8651" creationdate="20181117T155749Z">
        <seg>&lt;x1/&gt;OrderedPair&lt;x2/&gt;オブジェクトは、&lt;x3/&gt;x&lt;=y&lt;x4/&gt;のように構成できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now,
by default, &lt;x11/&gt;broadcasted&lt;x12/&gt; just calls the &lt;x13/&gt;Broadcasted&lt;x14/&gt; constructor to create the lazy representation
of the fused expression tree, but you can choose to override it for a particular combination
of function and arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131612Z" creationid="hsugawa8651" creationdate="20181113T131612Z">
        <seg>さて デフォルトでは、&lt;x11/&gt;ブロードキャストされた&lt;x12/&gt;は、&lt;x13/&gt;ブロードキャストされた&lt;x14/&gt;コンストラクタを呼び出して、遅延表現を作成します。 融合された表現ツリーのうち、特定の組み合わせに対して上書きすることを選択できます。 関数と引数を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, suppose that we have a 1d array &lt;x17/&gt;A&lt;x18/&gt; of values in Julia that we want to sort
using the &lt;x19/&gt;qsort&lt;x20/&gt; function (rather than Julia's built-in &lt;x21/&gt;sort&lt;x22/&gt; function).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150528Z" creationid="hsugawa8651" creationdate="20181117T150528Z">
        <seg>次に、1d配列があると仮定します。これは、配列をソートするために、Juliaに値を&lt;x17/&gt;A&lt;x18/&gt;とします。 &lt;x19/&gt;qsort&lt;x20/&gt;関数を使用します(Julyの組み込み&lt;X21/&gt;ソート&lt;x22/&gt;関数ではなく、&lt;x22/&gt;関数を使用します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, when we ask Julia to &lt;x1/&gt;`collect`&lt;x2/&gt; all the elements into an array it can preallocate a &lt;x3/&gt;Vector{Int}&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112802Z" creationid="hsugawa8651" creationdate="20181112T112802Z">
        <seg>さて、ジュリアに「collect」&lt;x×2/&gt;の要素を「collect」&lt;x2/&gt;に尋ねると、&lt;x3/&gt;Vector{Int}&lt;x4/&gt;をプリ割り当てすることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Number of bits</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110228Z" creationid="hsugawa8651" creationdate="20181109T225120Z">
        <seg>Number of bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Number&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041604Z" creationid="hsugawa8651" creationdate="20181112T041604Z">
        <seg>Number&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric literals also work as coefficients to parenthesized expressions:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093832Z" creationid="hsugawa8651" creationdate="20181118T093832Z">
        <seg>数値リテラルは、括弧で括られた式への係数としても機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OR</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135422Z" creationid="hsugawa8651" creationdate="20181117T135422Z">
        <seg>または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, messing around with an object's internals uninvited is bad practice.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155757Z" creationid="hsugawa8651" creationdate="20181117T155757Z">
        <seg>もちろん、オブジェクトの内部悪魔の招待状を回避することは、不適切なプラクティスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of particular interest may be &lt;x2/&gt;An Interview with the Old Man of Floating-Point&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111534Z" creationid="hsugawa8651" creationdate="20181112T111534Z">
        <seg>特に関心があるのは、&lt;x2/&gt;である。浮動小数点のOld Manとのインタビューである&lt;x3/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often referred to as logical indexing or indexing with a logical mask, indexing
by a boolean array selects elements at the indices where its values are &lt;x1/&gt;true&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155734Z" creationid="hsugawa8651" creationdate="20181109T155734Z">
        <seg>論理的なインデックス作成と呼ばれる論理的インデックス作成またはインデックス作成と呼ばれることが多いインデックス作成 ブール型配列では、値が&lt;x1/&gt;真&lt;x2/&gt;であるインデックスで要素を選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often referred to as logical indexing or indexing with a logical mask, indexing
by a boolean array selects elements at the indices where its values are &lt;x1/&gt;true&lt;x2/&gt;.
Indexing by a boolean vector &lt;x3/&gt;B&lt;x4/&gt; is effectively the same as indexing by the
vector of integers that is returned by &lt;x5/&gt;`findall(B)`&lt;x6/&gt;. Similarly, indexing
by a &lt;x7/&gt;N&lt;x8/&gt;-dimensional boolean array is effectively the same as indexing by the
vector of &lt;x9/&gt;CartesianIndex{N}&lt;x10/&gt;s where its values are &lt;x11/&gt;true&lt;x12/&gt;. A logical index
must be a vector of the same length as the dimension it indexes into, or it
must be the only index provided and match the size and dimensionality of the
array it indexes into. It is generally more efficient to use boolean arrays as
indices directly instead of first calling &lt;x13/&gt;`findall`&lt;x14/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135109Z" creationid="hsugawa8651" creationdate="20181117T135109Z">
        <seg>論理的なインデックス作成と呼ばれる論理的インデックス作成またはインデックス作成と呼ばれることが多いインデックス作成 ブール型配列では、値が&lt;x1/&gt;真&lt;x2/&gt;であるインデックスで要素を選択します。 ブール型ベクトル&lt;x3/&gt;B&lt;x4/&gt;によるインデックス作成は、実効的には、以下のようにして行われる。 &lt;x5/&gt;'findall(B)`&lt;x6/&gt;によって返される整数のベクトル。同様に索引付け &lt;x7/&gt;N&lt;x8/&gt;-次元ブール配列は、実効的には、以下のように、インデックス化と同じである。 &lt;x9/&gt;CartesianIndex{N}&lt;x10/&gt;sのベクトル。その値は&lt;x11/&gt;真&lt;x12/&gt;である。論理インデックス は、インデックスを作成する寸法と同じ長さのベクトルである必要があります。また 指定された唯一のインデックスであり にインデックスを作成する配列です。一般的には、ブール型配列を使用する方が効率的です。 は、最初の呼び出し&lt;x13/&gt;'findall&lt;x14/&gt;を呼び出すのではなく、直接インデックスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often the best way to deal with these is to deal with the byte offsets directly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151211Z" creationid="hsugawa8651" creationdate="20181117T151211Z">
        <seg>これらを処理する最良の方法は、バイトオフセットを直接処理することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On all systems we currently support, basic C/C++ value types may be translated to Julia types
as follows.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150836Z" creationid="hsugawa8651" creationdate="20181117T150836Z">
        <seg>現在サポートされているすべてのシステムでは、基本的なC/C++の値タイプがJuliaタイプに変換されることがあります。 以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On all systems we currently support, basic C/C++ value types may be translated to Julia types
as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C.
This can help for writing portable code (and remembering that an &lt;x1/&gt;int&lt;x2/&gt; in C is not the same as
an &lt;x3/&gt;Int&lt;x4/&gt; in Julia).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T140911Z" creationid="hsugawa8651" creationdate="20181117T140911Z">
        <seg>現在サポートされているすべてのシステムでは、基本的なC/C++の値タイプがJuliaタイプに変換されることがあります。 次のように、C型はすべて、同じ名前で接頭辞をつけられた同じ名前を持つ、対応するジュリア型を持っています。 これは、移植可能なコードを書くのに役立ちます(そして、Cでは&lt;x1/&gt;int&lt;x2/&gt;が同じではないことを思い出してください)。 &lt;x3/&gt;のInt&lt;x4/&gt;Int&lt;x4/&gt;int&lt;x4/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the flip side, it is often handy to "splat" the values contained in an iterable collection
into a function call as individual arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101627Z" creationid="hsugawa8651" creationdate="20181112T101627Z">
        <seg>逆に、iterableコレクションに含まれる値を"splat"するのは便利なことが多い。 関数呼び出しに個別の引数として指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, any type of expression can be used at the end of a conditional chain.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230819Z" creationid="hsugawa8651" creationdate="20181109T230819Z">
        <seg>一方、条件付きチェーンの最後では、任意のタイプの表現を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once
the user has entered a complete expression, such as &lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt; &lt;s10&gt;+&lt;/s10&gt; &lt;s11&gt;2&lt;/s11&gt;&lt;/c8&gt;, and
hits enter, the interactive session evaluates the expression and shows
its value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084316Z" creationid="hsugawa8651" creationdate="20181118T083924Z">
        <seg>ユーザーが完全な式、例えば &lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt; &lt;s10&gt;+&lt;/s10&gt; &lt;s11&gt;2&lt;/s11&gt; を入力し、エンターキーを押すと、その式が評価され、値が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once created, they participate in arithmetic
with all other numeric types thanks to Julia's &lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref conversion-and-promotion):</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111549Z" creationid="hsugawa8651" creationdate="20181112T111549Z">
        <seg>作成されると、計算に参加します。 その他の数値タイプは、Juliaの&lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref conversion and promotion)(@ref conversion and promotion)のおかげです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the user has entered a complete expression, such as &lt;x11/&gt;1 + 2&lt;x12/&gt;, and hits enter, the interactive
session evaluates the expression and shows its value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091352Z" creationid="hsugawa8651" creationdate="20181109T224313Z">
        <seg>ユーザーが完全な式、例えば &lt;x11/&gt; 1 + &lt;x12/&gt; を入力し、エンターキーを押すと、その式が評価され、値が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you understand how Julia
works, it’s easy to write code that’s nearly as fast as C.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081603Z" creationid="hsugawa8651" creationdate="20181118T081603Z">
        <seg> Juliaがどのように動作するかを理解すれば、C言語と同等の速さで動くコードを簡単に書くことができるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can either restart Julia or use the
&lt;x1/&gt;Libdl&lt;x2/&gt; functions to manage the library explicitly, such as:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152357Z" creationid="hsugawa8651" creationdate="20181117T152357Z">
        <seg>Juliaを再起動するか &lt;x1/&gt;Libdl&lt;x2/&gt;は、ライブラリを明示的に管理するために、次のような関数を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One common gotcha is that a 1-tuple must be
written with a trailing comma.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224037Z" creationid="hsugawa8651" creationdate="20181109T224037Z">
        <seg>一般的なゴチャの一つは、1タプルが必要であるということです。 後続のカンマで作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One consequence of federation is that there cannot be a central authority for package naming.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152831Z" creationid="hsugawa8651" creationdate="20181117T152831Z">
        <seg>フェデレーションの一つの結果は、パッケージ命名の中心的な権限を持つことができないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One could declare it
like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155742Z" creationid="hsugawa8651" creationdate="20181117T155742Z">
        <seg>それを宣言することができる こんな感じです</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of &lt;x1/&gt;HasLength()&lt;x2/&gt;, &lt;x3/&gt;HasShape{N}()&lt;x4/&gt;, &lt;x5/&gt;IsInfinite()&lt;x6/&gt;, or &lt;x7/&gt;SizeUnknown()&lt;x8/&gt; as appropriate</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112136Z" creationid="hsugawa8651" creationdate="20181112T112126Z">
        <seg>&lt;x1/&gt;HasLength()&lt;x2/&gt;の一つ、&lt;x3/&gt;HasShape{N}()&lt;x4/&gt;、&lt;x5/&gt;IsInfinite()&lt;x6/&gt;、必要に応じて&lt;x8/&gt;、&lt;x8/&gt;SizeUnknown()&lt;x8/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One rather
important distinction between the previous &lt;x2/&gt;while&lt;x3/&gt; loop form and the &lt;x4/&gt;for&lt;x5/&gt; loop form is the scope
during which the variable is visible.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T231156Z" creationid="hsugawa8651" creationdate="20181109T231156Z">
        <seg>一つ &lt;x3/&gt;ループ形態と&lt;x4/&gt;ループ形態の&lt;x4/&gt;は、前の&lt;x2/&gt;と&lt;x4/&gt;の間の重要な区別である。 変数が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations on &lt;x11/&gt;AbstractArray&lt;x12/&gt; objects are defined using higher
level operators and functions, in a way that is independent of the underlying storage.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160305Z" creationid="hsugawa8651" creationdate="20181109T160305Z">
        <seg>&lt;x11/&gt;AbstractArray&lt;x12/&gt;オブジェクトに対する操作は、より高い値を使用して定義されます。 レベル演算子と関数は、基礎となる記憶域とは独立して存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are just functions with special notation — to extend
addition to new user-defined data types, you define new methods for the
&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082506Z" creationid="hsugawa8651" creationdate="20181118T082432Z">
        <seg>これに対してJuliaの演算子は（特殊な記法を持った）単なる関数に過ぎません。 ユーザーが定義したデータ型に対して加算処理を追加したい場合は、&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt; 関数に対して新たなメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional methods&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094608Z" creationid="hsugawa8651" creationdate="20181118T094608Z">
        <seg>オプションのメソッド&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally, with this form you can also specialize on the type of &lt;x1/&gt;dest&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131651Z" creationid="hsugawa8651" creationdate="20181113T131651Z">
        <seg>オプションで、このフォームでは、&lt;x1/&gt;dest&lt;x2/&gt;のタイプに特化することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or for use with Julia's metaprogramming functionality:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020127Z" creationid="hsugawa8651" creationdate="20181116T020127Z">
        <seg>Or for use with Julia's metaprogramming functionality:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or in reverse order by a transformation:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044919Z" creationid="hsugawa8651" creationdate="20181112T044919Z">
        <seg>Or in reverse order by a transformation:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you could put that code into a script and run it:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224350Z" creationid="hsugawa8651" creationdate="20181109T224350Z">
        <seg>あるいは、スクリプトにコードを挿入して実行することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Order-Related Functions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150334Z" creationid="hsugawa8651" creationdate="20181117T150334Z">
        <seg>順序関連の関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other compositions of unary operators are parsed with right-associativity, e.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030930Z" creationid="hsugawa8651" creationdate="20181114T030918Z">
        <seg>単項演算子の他の組成は、右の連想であるeで解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other supported conventions are: &lt;x3/&gt;stdcall&lt;x4/&gt;, &lt;x5/&gt;cdecl&lt;x6/&gt;, &lt;x7/&gt;fastcall&lt;x8/&gt;, and &lt;x9/&gt;thiscall&lt;x10/&gt; (no-op on 64-bit Windows).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152431Z" creationid="hsugawa8651" creationdate="20181117T152431Z">
        <seg>その他のサポートされる規則は以下の通りです:&lt;x3/&gt;stdcall&lt;x4/&gt;,&lt;x5/&gt;cdecl&lt;x6/&gt;,&lt;x7/&gt;fastcall&lt;x8/&gt;,&lt;x9/&gt;(64ビットWindows上でのno-op on64ビットWindows)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise,
&lt;x5/&gt;X&lt;x6/&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the
indices.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155131Z" creationid="hsugawa8651" creationdate="20181109T155131Z">
        <seg>そうでない場合は &lt;x5/&gt;x&lt;x6/&gt;は、すべての次元の次元性の合計と同じ数の次元を持つ配列です。 索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outer constructor methods can only ever create a new instance
by calling another constructor method, such as the automatically provided default ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155729Z" creationid="hsugawa8651" creationdate="20181117T155729Z">
        <seg>外部コンストラクタのメソッドは、新しいインスタンスを作成することしかできません。 別のコンストラクタ・メソッド(自動的に提供されるデフォルトのデフォルト値など)を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overloading &lt;x1/&gt;`show`&lt;x2/&gt; allows one to indicate arbitrary multimedia representations (keyed by standard
MIME types) of user-defined types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043253Z" creationid="hsugawa8651" creationdate="20181112T043253Z">
        <seg>オーバロード&lt;x1/&gt;`show`&lt;x2/&gt;は、任意のマルチメディア表現を示すことができます(標準でキー設定されています)。 ユーザー定義型のMIMEタイプ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Override the computation of the lazy broadcast's axes</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131004Z" creationid="hsugawa8651" creationdate="20181113T131004Z">
        <seg>遅延ブロードキャストの軸の計算をオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Override the default lazy behavior within a fused expression</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083633Z" creationid="hsugawa8651" creationdate="20181113T083633Z">
        <seg>融合式の中でデフォルトの遅延動作をオーバーライドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package loading is built on top of code inclusion and is a lot more complex.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152749Z" creationid="hsugawa8651" creationdate="20181117T152749Z">
        <seg>パッケージのロードはコードインクルージョンの上に構築され、より複雑なものになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package loading:&lt;x1/&gt; e.g. &lt;x2/&gt;import X&lt;x3/&gt; or &lt;x4/&gt;using X&lt;x5/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152734Z" creationid="hsugawa8651" creationdate="20181117T152734Z">
        <seg>パッケージ荷重:&lt;x1/&gt;例えば&lt;x2/&gt;インポートX&lt;x3/&gt;または&lt;x4/&gt;をX&lt;x5/&gt;を使用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Packages from various registries are installed and managed using a common set of tools and workflows.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152825Z" creationid="hsugawa8651" creationdate="20181117T152825Z">
        <seg>さまざまなレジストリからのパッケージは、共通のツールとワークフローを使用してインストールされ、管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Packed structs and union declarations are not supported by Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151147Z" creationid="hsugawa8651" creationdate="20181117T151147Z">
        <seg>Packed構造体とUnion宣言は、Juliaではサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pair{Int, Int}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150709Z" creationid="hsugawa8651" creationdate="20181117T150709Z">
        <seg>Pair{Int, Int}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PartialQuickSort(k)&lt;x1/&gt; is similar to &lt;x2/&gt;QuickSort&lt;x3/&gt;, but the output array is only sorted up to index
&lt;x4/&gt;k&lt;x5/&gt; if &lt;x6/&gt;k&lt;x7/&gt; is an integer, or in the range of &lt;x8/&gt;k&lt;x9/&gt; if &lt;x10/&gt;k&lt;x11/&gt; is an &lt;x12/&gt;OrdinalRange&lt;x13/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064103Z" creationid="hsugawa8651" creationdate="20181114T064103Z">
        <seg>PartialQuickSort(k)&lt;x1/&gt;は&lt;x2/&gt;QuickSort&lt;x3/&gt;と類似していますが、出力配列はインデックスにのみソートされています。 &lt;x4/&gt;k&lt;x5/&gt;は、&lt;x6/&gt;k&lt;x7/&gt;が整数である場合、&lt;x10/&gt;k&lt;x11/&gt;が&lt;x12/&gt;k&lt;x11/&gt;の場合、&lt;x12/&gt;k&lt;x11/&gt;の範囲である。OrdinalRange。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Partially implemented by:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041654Z" creationid="hsugawa8651" creationdate="20181112T041654Z">
        <seg>Partially implemented by:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Partly because of run-time type inference (augmented by optional type
annotations), and partly because of a strong focus on performance from
the inception of the project, Julia’s computational efficiency exceeds
that of other dynamic languages, and even rivals that of
statically-compiled languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082529Z" creationid="hsugawa8651" creationdate="20181118T082529Z">
        <seg>実行時型推論（任意の型注釈で補うこともできます）によって、またプロジェクト発足時からの性能に対する強い欲求によって、Juliaの計算効率は他の動的言語を圧倒し、静的コンパイル言語と競うレベルにあります。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing Pointers for Modifying Inputs</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151822Z" creationid="hsugawa8651" creationdate="20181117T151822Z">
        <seg>入力を変更するためのポインタを渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing options to &lt;x1/&gt;julia&lt;x2/&gt; in so-called shebang by, e.g.,
&lt;x3/&gt;&lt;x4/&gt;!/usr/bin/env julia --startup-file=no&lt;x5/&gt; may not work in some
platforms such as Linux.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024920Z" creationid="hsugawa8651" creationdate="20181110T024920Z">
        <seg>例えば、シェバンでは、&lt;x1/&gt;july&lt;x2/&gt;に渡すオプションを指定します。 &lt;x3/&gt;&lt;x4/&gt;!/usr/bin/env julia--startup file=no&lt;x5/&gt;は動作しない場合があります。 Linuxなどのプラットフォームです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perhaps you've defined a type and then realize you need to add a new field.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024714Z" creationid="hsugawa8651" creationdate="20181110T024714Z">
        <seg>おそらく、タイプを定義してから、新しいフィールドを追加する必要があることを認識しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointers contained in C
structs should be represented as fields of type &lt;x11/&gt;Ptr{T}&lt;x12/&gt; within the corresponding Julia struct
types designed to mimic the internal structure of corresponding C structs.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151449Z" creationid="hsugawa8651" creationdate="20181117T151449Z">
        <seg>Cに含まれるポインタ 構造体は、対応するジュリア構造内の&lt;x11/&gt;Ptr{T}&lt;x12/&gt;の型のフィールドとして表されるべきである。 は、対応するC構造体の内部構造を模倣するように設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Positive zero is equal but not greater than negative zero.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030501Z" creationid="hsugawa8651" creationdate="20181114T030501Z">
        <seg>正の0は負の値で、負の値は0より大きくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Powerful shell-like capabilities for managing other processes</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082917Z" creationid="hsugawa8651" creationdate="20181118T082917Z">
        <seg>シェルのような強力なプロセス管理
n</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical use of it
requires using &lt;x3/&gt;llvmcall&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063640Z" creationid="hsugawa8651" creationdate="20181114T063640Z">
        <seg>実用化 &lt;x3/&gt;リウムカル&lt;x4/&gt;を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precision</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110226Z" creationid="hsugawa8651" creationdate="20181112T110226Z">
        <seg>Precision</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Print this message</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224608Z" creationid="hsugawa8651" creationdate="20181109T224608Z">
        <seg>このメッセージを印刷する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Project environments provide &lt;x1/&gt;reproducibility.&lt;x2/&gt; By checking a project environment into version control—e.g. a git repository—along with the rest of the project's source code, you can reproduce the exact state of the project &lt;x3/&gt;and&lt;x4/&gt; all of its dependencies since the manifest file captures the exact version of every dependency.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T153207Z" creationid="hsugawa8651" creationdate="20181117T153207Z">
        <seg>プロジェクト環境は、&lt;x1/&gt;再現性を提供します。&lt;x2/&gt;プロジェクト環境をバージョン制御することによって&lt;x/&gt;は、プロジェクトのソースコードとともに、プロジェクトの正確な状態を再現できます。&lt;x3/&gt;は、すべての依存関係の正確なバージョンをキャプチャするため、すべての依存関係の正確な状態を再現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties of Types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041836Z" creationid="hsugawa8651" creationdate="20181110T041836Z">
        <seg>Properties of Types</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines
for more efficient linear algebra routines.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083503Z" creationid="hsugawa8651" creationdate="20181113T083503Z">
        <seg>配列の要素タイプがBLASと互換性がある場合、strider配列はBLASとLAPACKルーチンを利用することができます。 より効率的な線形代数のルーチンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ptr&lt;x1/&gt; is always a word-size primitive type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151240Z" creationid="hsugawa8651" creationdate="20181117T151240Z">
        <seg>Ptr&lt;x1/&gt;は常にワードサイズのプリミティブ型である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ptr{Any}&lt;x1/&gt; (&lt;x2/&gt;Ref{Any}&lt;x3/&gt; is invalid as a return type)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151807Z" creationid="hsugawa8651" creationdate="20181117T151807Z">
        <seg>Ptr{Any}&lt;x1/&gt;(&lt;x2/&gt;Ref{Any}&lt;x3/&gt;は、戻り型として無効です)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ptr{Cdouble}&lt;x1/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152206Z" creationid="hsugawa8651" creationdate="20181117T152206Z">
        <seg>Ptr{Cdouble}&lt;x1/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ptr{Cvoid}&lt;x1/&gt; (you may need to use &lt;x2/&gt;`@cfunction`&lt;x3/&gt; explicitly to create this pointer)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151602Z" creationid="hsugawa8651" creationdate="20181117T151602Z">
        <seg>Ptr{Cvoid}&lt;x1/&gt;(このポインタを作成するためには、&lt;x2/&gt;`@cfunction`&lt;x3/&gt;を明示的に使用する必要があります)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ptr{T}&lt;x1/&gt;, where &lt;x2/&gt;T&lt;x3/&gt; is the Julia type corresponding to &lt;x4/&gt;T&lt;x5/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151820Z" creationid="hsugawa8651" creationdate="20181117T151820Z">
        <seg>Ptr{T}&lt;x1/&gt;。ここで、&lt;x2/&gt;T&lt;x3/&gt;は、&lt;x4/&gt;T&lt;x5/&gt;に対応するジュリア型である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Punctuation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150207Z" creationid="hsugawa8651" creationdate="20181117T150202Z">
        <seg>句読点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>QuickSort&lt;x1/&gt; is an O(n log n) sorting algorithm which is in-place, very fast, but not stable –
i.e. elements which are considered equal will not remain in the same order in which they originally
appeared in the array to be sorted.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064040Z" creationid="hsugawa8651" creationdate="20181114T064040Z">
        <seg>QuickSort&lt;x1/&gt;はO(nログn)ソートアルゴリズムで、インプレースではなく、非常に高速ですが、安定しています。 すなわち、等しいと考えられる要素は、本来は同じ順序では存在しない 配列に表示され、ソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>QuickSort&lt;x1/&gt; is selected as it is faster and indistinguishable
in this case from a stable sort (unless the array records its mutations in some way).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064123Z" creationid="hsugawa8651" creationdate="20181114T064123Z">
        <seg>クイックソート&lt;x1/&gt;が選択されると同時に選択され、識別できなくなります。 この場合は、安定なソート(配列が何らかの方法でその突然変異を記録しない限り)である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quiet startup: no banner, suppress REPL warnings</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224722Z" creationid="hsugawa8651" creationdate="20181109T224722Z">
        <seg>quietスタートアップ:バナーがない、REPL警告が省略されていない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ranges in generators and comprehensions can depend on previous ranges by writing multiple &lt;x1/&gt;for&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155036Z" creationid="hsugawa8651" creationdate="20181109T155036Z">
        <seg>生成の範囲は、&lt;x2/&gt;を&lt;x2/&gt;に書くことによって、以前の範囲に依存することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ranges like &lt;x1/&gt;a:c&lt;x2/&gt; or &lt;x3/&gt;a:b:c&lt;x4/&gt;, which select contiguous or strided subsections from &lt;x5/&gt;a&lt;x6/&gt; to &lt;x7/&gt;c&lt;x8/&gt; (inclusive)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155527Z" creationid="hsugawa8651" creationdate="20181109T155527Z">
        <seg>&lt;x1/&gt;a:c&lt;x2/&gt;または&lt;x3/&gt;a:b&lt;x4/&gt;のような範囲。&lt;x5/&gt;から&lt;x6/&gt;&lt;x8/&gt;&lt;x8/&gt;(含む)まで連続するサブセクションまたはストライドされたサブセクションを選択する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than relying on "vectorized" methods of functions like &lt;x8/&gt;sin&lt;x9/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150005Z" creationid="hsugawa8651" creationdate="20181117T150005Z">
        <seg>&lt;x8/&gt;sin&lt;x9/&gt;のような"ベクトル化された"関数の関数に依存するのではなく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recall that the variable &lt;x1/&gt;`ans`&lt;x2/&gt; is set to the value of the last expression evaluated in
an interactive session.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225338Z" creationid="hsugawa8651" creationdate="20181109T225338Z">
        <seg>変数&lt;x1/&gt;`は、最後に評価された最後の式の値に設定されていることを思い出してください。 対話型セッションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reflection</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042017Z" creationid="hsugawa8651" creationdate="20181110T042017Z">
        <seg>Reflection</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ref{Any}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151540Z" creationid="hsugawa8651" creationdate="20181117T151540Z">
        <seg>Ref{Any}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ref{T}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134447Z" creationid="hsugawa8651" creationdate="20181117T134447Z">
        <seg>Ref{T}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ref{T}&lt;x1/&gt;, where &lt;x2/&gt;T&lt;x3/&gt; is the Julia type corresponding to &lt;x4/&gt;T&lt;x5/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151553Z" creationid="hsugawa8651" creationdate="20181117T151553Z">
        <seg>参照{T}&lt;x1/&gt;。&lt;x2/&gt;T&lt;x3/&gt;は、&lt;x4/&gt;T&lt;x5/&gt;に対応するジュリア型である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex("^\\s*(?:&lt;x1/&gt;|\$)")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015626Z" creationid="hsugawa8651" creationdate="20181116T015626Z">
        <seg>Regex("^\\s*(?:&lt;x1/&gt;|\$)")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represented as either an array or a struct.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150802Z" creationid="hsugawa8651" creationdate="20181117T150802Z">
        <seg>配列または構造体として表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required Methods</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094116Z" creationid="hsugawa8651" creationdate="20181118T094116Z">
        <seg>必要なメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return a mutable array with the specified element type and size</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094500Z" creationid="hsugawa8651" creationdate="20181118T094500Z">
        <seg>指定されたエレメントタイプとともに、可変配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return a mutable array with the specified indices &lt;x1/&gt;inds&lt;x2/&gt; (see below)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022621Z" creationid="hsugawa8651" creationdate="20181113T022621Z">
        <seg>指定されたインデックス&lt;x1/&gt;インスタンス&lt;x2/&gt;(以下参照)を使用して、可変配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return an array similar to &lt;x1/&gt;T&lt;x2/&gt; with the specified indices &lt;x3/&gt;inds&lt;x4/&gt; (see below)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022647Z" creationid="hsugawa8651" creationdate="20181113T022647Z">
        <seg>&lt;x1/&gt;T&lt;x2/&gt;のような配列を指定されたインデックス&lt;x3/&gt;inds&lt;x4/&gt;(以下参照)と同様に返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return the &lt;x1/&gt;AbstractUnitRange&lt;x2/&gt; of valid indices</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094507Z" creationid="hsugawa8651" creationdate="20181118T094507Z">
        <seg>有効なインデックスの&lt;x1/&gt;AbstractUnitRange&lt;x2/&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return the distance in memory (in number of elements) between adjacent elements in dimension k.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094614Z" creationid="hsugawa8651" creationdate="20181118T094614Z">
        <seg>寸法kの隣り合う要素間のメモリ内の距離(要素数)を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094558Z" creationid="hsugawa8651" creationdate="20181118T094558Z">
        <seg>各次元内の隣り合う要素間の距離をタプルとして、メモリ内の距離を返します(要素数)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return the native address of an array.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094606Z" creationid="hsugawa8651" creationdate="20181118T094606Z">
        <seg>配列のネイティブ・アドレスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return type</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133907Z" creationid="hsugawa8651" creationdate="20181117T133907Z">
        <seg>戻り値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return type (see below for mapping the declared C type to Julia)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223843Z" creationid="hsugawa8651" creationdate="20181109T223843Z">
        <seg>戻り型(宣言されたC型をJuliaにマッピングするには、次を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning to the sequence of squares from above, we could instead define it as a subtype of an
&lt;x1/&gt;AbstractArray{Int, 1}&lt;x2/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083159Z" creationid="hsugawa8651" creationdate="20181113T083159Z">
        <seg>上からの2乗のシーケンスに戻ると、それをサブタイプとして定義することができます。 &lt;x1/&gt;AbstractArray{Int,1}&lt;x2/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a tuple containing the dimensions of &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113218Z" creationid="hsugawa8651" creationdate="20181112T113218Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;の次元を含むタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns either &lt;x1/&gt;IndexLinear()&lt;x2/&gt; or &lt;x3/&gt;IndexCartesian()&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113322Z" creationid="hsugawa8651" creationdate="20181112T113322Z">
        <seg>&lt;x1/&gt;IndexLinear()&lt;x2/&gt;または&lt;x3/&gt;IndexCartesian()&lt;x4/&gt;のいずれかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns either a tuple of the first item and initial state or &lt;x1/&gt;`nothing`&lt;x2/&gt; if empty</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112101Z" creationid="hsugawa8651" creationdate="20181112T112101Z">
        <seg>最初の項目と初期状態のタプルを返すか、&lt;x1/&gt;'nothing"&lt;x2/&gt;"&lt;x2/&gt;のいずれかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns either a tuple of the next item and next state or &lt;x1/&gt;nothing&lt;x2/&gt; if no items remain</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112109Z" creationid="hsugawa8651" creationdate="20181112T112109Z">
        <seg>次の項目のタプルを返し、次の状態または&lt;x1/&gt;何もしない&lt;x2/&gt;を返します。項目が残っていない場合は、&lt;x/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run processes on hosts listed in &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224714Z" creationid="hsugawa8651" creationdate="20181109T224714Z">
        <seg>&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;にリストされたホスト上でプロセスを実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running a Julia script using &lt;x1/&gt;julia file.jl&lt;x2/&gt; does not throw
&lt;x3/&gt;`InterruptException`&lt;x4/&gt; when you try to terminate it with CTRL-C
(SIGINT).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024906Z" creationid="hsugawa8651" creationdate="20181110T024906Z">
        <seg>&lt;x1/&gt;ジュリアファイル.jl&lt;x2/&gt;を使用してジュリアスクリプトを実行しても、スローされません。 CTRL-Cで終了しようとすると、&lt;x3/&gt;'InterruptException'&lt;x4/&gt;となります。 (SIGINT)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SIMD Support</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063634Z" creationid="hsugawa8651" creationdate="20181114T063634Z">
        <seg>SIMDサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SIMD Values</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151248Z" creationid="hsugawa8651" creationdate="20181117T151248Z">
        <seg>SIMD値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values passed to these functions are treated as 1-element arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154559Z" creationid="hsugawa8651" creationdate="20181109T154559Z">
        <seg>これらの関数に渡されるスカラー値は、1要素配列として扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values passed to these functions are treated as 1-element arrays. For example,</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134540Z" creationid="hsugawa8651" creationdate="20181117T134540Z">
        <seg>これらの関数に渡されるスカラー値は、1要素配列として扱われます。たとえば、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scientific computing has traditionally required the highest performance,
yet domain experts have largely moved to slower dynamic languages for
daily work.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081334Z" creationid="hsugawa8651" creationdate="20181118T081334Z">
        <seg>科学技術計算には常に最高の性能が求められますが、この分野のエキスパートたちはより低速な動的言語を使って仕事をしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second"
 "3.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161332Z" creationid="hsugawa8651" creationdate="20181114T161332Z">
        <seg>Second"
 "3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
the &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man-multi-dim-arrays) and the &lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref lib-arrays) for more supported methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022656Z" creationid="hsugawa8651" creationdate="20181113T022656Z">
        <seg>「」を参照してください。 サポートされるメソッドについては、&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref manマルチdimアレイ)および&lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref lib arrays)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref conversion-and-promotion) for details of the promotion
system.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132207Z" creationid="hsugawa8651" creationdate="20181113T132207Z">
        <seg>プロモーションの詳細については、&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref変換とプロモーション)を参照してください。 システム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;x5/&gt;Iteration&lt;x6/&gt; below, and for some more advanced
examples, see &lt;x7/&gt;this blog post on multidimensional algorithms and
iteration&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155626Z" creationid="hsugawa8651" creationdate="20181109T155626Z">
        <seg>以下の「&lt;x5/&gt;イテレーション&lt;x6/&gt;」を参照してください。また、詳細については、以下を参照してください。 例を参照してください。このブログ記事は、多次元アルゴリズムに関するこのブログ記事を参照してください。 繰り返し&lt;x8/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-scripting) for more information on writing Julia scripts.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224404Z" creationid="hsugawa8651" creationdate="20181109T224404Z">
        <seg>Juliaスクリプトの記述についての詳細は、&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man scripting)も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-vectorized);
for example, &lt;x4/&gt;f.(args...)&lt;x5/&gt; implicitly calls &lt;x6/&gt;broadcast(f, args...)&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150003Z" creationid="hsugawa8651" creationdate="20181117T150003Z">
        <seg>&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref manベクトル化)も参照してください。 たとえば、&lt;x4/&gt;f.(args...)&lt;x5/&gt;は暗黙的に&lt;x6/&gt;ブロードキャスト(f,args.…)&lt;x7/&gt;を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043138Z" creationid="hsugawa8651" creationdate="20181112T043138Z">
        <seg>See also:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man-interface-array) for more details
on implementing a custom array type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154135Z" creationid="hsugawa8651" creationdate="20181109T154135Z">
        <seg>詳細については、&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man interface array)を参照してください。 カスタム・アレイ・タイプの実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man-interface-iteration) for more details about defining a custom
iterable type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041550Z" creationid="hsugawa8651" creationdate="20181112T041550Z">
        <seg>カスタムを定義する方法の詳細については、&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man interface iteration)を参照してください。 iterable型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the description below.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113328Z" creationid="hsugawa8651" creationdate="20181112T113328Z">
        <seg>以下の説明を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selecting an appropriate output array for the given set of arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131027Z" creationid="hsugawa8651" creationdate="20181113T131027Z">
        <seg>指定された引数のセットに対して適切な出力配列を選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selecting an efficient implementation for the given set of arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131030Z" creationid="hsugawa8651" creationdate="20181113T131030Z">
        <seg>指定された引数のセットに対する効率的な実装の選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sequential iteration is implemented by the &lt;x1/&gt;`iterate`&lt;x2/&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112352Z" creationid="hsugawa8651" creationdate="20181112T112352Z">
        <seg>逐次的反復は、&lt;x1/&gt;'reiterate'&lt;x2/&gt;関数によって実装される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set &lt;x1/&gt; as the home project/environment.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224611Z" creationid="hsugawa8651" creationdate="20181109T224611Z">
        <seg>&lt;x1/&gt;をホームプロジェクト/環境として設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set location of &lt;x1/&gt;julia&lt;x2/&gt; executable</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224639Z" creationid="hsugawa8651" creationdate="20181109T224639Z">
        <seg>&lt;x1/&gt;ジュリア&lt;x2/&gt;実行可能ファイルの場所を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the optimization level (default level is 2 if unspecified or 3 if used without a level)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224743Z" creationid="hsugawa8651" creationdate="20181109T224743Z">
        <seg>最適化レベルを設定します(指定されていない場合はデフォルトレベルは2、レベルなしで使用される場合は3です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set-Like Collections</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041820Z" creationid="hsugawa8651" creationdate="20181112T041820Z">
        <seg>Set-Like Collections</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shared libraries and functions are referenced by a tuple of the form &lt;x1/&gt;(:function, "library")&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161432Z" creationid="hsugawa8651" creationdate="20181114T161432Z">
        <seg>共有ライブラリと関数は、&lt;x1/&gt;(:関数、"ライブラリ")&lt;x2/&gt;という形式のタプルによって参照されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short, simple function definitions
are common in Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025617Z" creationid="hsugawa8651" creationdate="20181110T025617Z">
        <seg>簡潔で単純な関数定義 ジュリアによく見られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short-Circuit Evaluation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230217Z" creationid="hsugawa8651" creationdate="20181109T230217Z">
        <seg>Short-Circuit Evaluation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short-Circuit Evaluation&lt;x1/&gt;: &lt;x2/&gt;&amp;&amp;&lt;x3/&gt;, &lt;x4/&gt;||&lt;x5/&gt; and chained comparisons.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225726Z" creationid="hsugawa8651" creationdate="20181109T225726Z">
        <seg>短絡評価&lt;x1/&gt;:&lt;x2/&gt;&amp;&amp;&lt;x3/&gt;、&lt;x4/&gt;&lt;x5/&gt;および連鎖比較。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short-circuit evaluation is quite similar to conditional evaluation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230224Z" creationid="hsugawa8651" creationdate="20181109T230224Z">
        <seg>短絡評価は条件付き評価と非常によく似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signed&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134438Z" creationid="hsugawa8651" creationdate="20181117T134438Z">
        <seg>Signed&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signed?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110030Z" creationid="hsugawa8651" creationdate="20181112T110030Z">
        <seg>Signed?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly for unary
operators like &lt;x17/&gt;!&lt;x18/&gt; or &lt;x19/&gt;√&lt;x20/&gt;, there is a corresponding &lt;x21/&gt;.√&lt;x22/&gt; that
applies the operator elementwise.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132515Z" creationid="hsugawa8651" creationdate="20181113T132501Z">
        <seg>単項についても同様 &lt;x17/&gt;!&lt;x18/&gt;や&lt;x19/&gt;√x20/&gt;のような演算子は、対応する&lt;X21/&gt;.√&lt;x22/&gt;となります。 は、演算子要素を適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, for array arguments (&lt;x11/&gt;T[]&lt;x12/&gt; or &lt;x13/&gt;T*&lt;x14/&gt;), the
Julia type should again be &lt;x15/&gt;Ptr{T}&lt;x16/&gt;, not &lt;x17/&gt;Vector{T}&lt;x18/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151015Z" creationid="hsugawa8651" creationdate="20181117T151015Z">
        <seg>同様に、配列引数(&lt;x11/&gt;T[]&lt;x12/&gt;または&lt;x13/&gt;T*&lt;x14/&gt;)では、次のようになります。 また、Julia型は、再び&lt;x15/&gt;Ptr{T}&lt;x16/&gt;であり、&lt;x17/&gt;ベクトル{T}&lt;x18/&gt;ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, indexing
by a &lt;x7/&gt;N&lt;x8/&gt;-dimensional boolean array is effectively the same as indexing by the
vector of &lt;x9/&gt;CartesianIndex{N}&lt;x10/&gt;s where its values are &lt;x11/&gt;true&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155802Z" creationid="hsugawa8651" creationdate="20181109T155802Z">
        <seg>同様にインデックス化 &lt;x7/&gt;N&lt;x8/&gt;-次元ブール配列は、実効的には、以下のように、インデックス化と同じである。 &lt;x9/&gt;CartesianIndex{N}&lt;x10/&gt;sのベクトルであり、その値は&lt;x11/&gt;真&lt;x12/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, some subtypes may wish to override &lt;x4/&gt;&lt;x5/&gt;&lt;x6/&gt;(@ref Base.Multimedia.redisplay).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063328Z" creationid="hsugawa8651" creationdate="20181114T063328Z">
        <seg>同様に、サブタイプによっては、&lt;x4/&gt;&lt;x5/&gt;&lt;x6/&gt;(@ref Base.Multimedia.redisplay)をオーバーライドすることを希望する場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can completely override out-of-place broadcasting with a &lt;x1/&gt;copy(::Broadcasted)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131708Z" creationid="hsugawa8651" creationdate="20181113T131708Z">
        <seg>同様に、&lt;x1/&gt;コピー(:ブロードキャスト)&lt;x2/&gt;を使用して、場所を指定しないブロードキャストを完全に上書きできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since counting up and
down like the above &lt;x3/&gt;while&lt;x4/&gt; loop does is so common, it can be expressed more concisely with a
&lt;x5/&gt;for&lt;x6/&gt; loop:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T231131Z" creationid="hsugawa8651" creationdate="20181109T231131Z">
        <seg>カウントアップして &lt;x4/&gt;ループは非常に一般的であるので、上記&lt;x3/&gt;のようにダウンすることができる。 &lt;x6/&gt;ループの場合は&lt;x5/&gt;&lt;x6/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since indexing is
such an important part of an array and often occurs in hot loops, it's important to make both
indexing and indexed assignment as efficient as possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022702Z" creationid="hsugawa8651" creationdate="20181113T022702Z">
        <seg>インデックス作成は このような重要な部分は、多くの場合、ホット・ループで発生するため、両方とも重要です。 インデックス化とインデックス化された割り当ては可能な限り効率的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since outer constructor
methods can only create objects by calling other constructor methods, ultimately, some inner constructor
must be called to create an object.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155801Z" creationid="hsugawa8651" creationdate="20181117T155801Z">
        <seg>外部コンストラクタ メソッドは、他のコンストラクタ・メソッドを呼び出してオブジェクトを作成できるだけで、最終的には内部コンストラクタを作成できます オブジェクトを作成するために呼び出される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the body of the generated function is non-deterministic, its behavior, &lt;x1/&gt;and the behavior of all subsequent code&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032051Z" creationid="hsugawa8651" creationdate="20181116T032051Z">
        <seg>生成された関数の本体は決定的ではないので、その振る舞いは、&lt;x1/&gt;と、その後のすべてのコード&lt;x2/&gt;の振る舞いとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the decentralized naming problem is somewhat abstract, it may help to walk through a concrete scenario to understand the issue.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152846Z" creationid="hsugawa8651" creationdate="20181117T152846Z">
        <seg>分散ネーミング問題は幾分抽象的なので、この問題を理解するためには、具体的なシナリオをウォークスルーすることが有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the fundamental difficulty may not be immediately
obvious, let us briefly explain it.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155840Z" creationid="hsugawa8651" creationdate="20181117T155840Z">
        <seg>根本的な困難はすぐにはない わかりやすく説明しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since these are fairly small, simple expressions, they could easily be placed onto a single line,
which is where the &lt;x1/&gt;(;)&lt;x2/&gt; chain syntax comes in handy:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225809Z" creationid="hsugawa8651" creationdate="20181109T225809Z">
        <seg>これらはかなり小さいので、簡単な表現で簡単に1行に配置することができます。 ここでは、&lt;x1/&gt;(;)&lt;x2/&gt;チェイン構文が便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since these two &lt;x31/&gt;Priv&lt;x32/&gt; packages are different but both required for &lt;x33/&gt;App&lt;x34/&gt; to continue working correctly, the expression &lt;x35/&gt;import Priv&lt;x36/&gt; must refer to different &lt;x37/&gt;Priv&lt;x38/&gt; packages depending on whether it occurs in &lt;x39/&gt;App&lt;x40/&gt;'s code or in &lt;x41/&gt;Pub&lt;x42/&gt;'s code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152906Z" creationid="hsugawa8651" creationdate="20181117T152906Z">
        <seg>これらの2つの&lt;x31/&gt;Priv&lt;x32/&gt;パッケージは異なりますが、&lt;x33/&gt;App&lt;x34/&gt;は正常に動作するためには必要です。&lt;x35/&gt;import Priv&lt;x36/&gt;は、&lt;x41/&gt;の&lt;x40/&gt;のコードで発生するか、&lt;x41/&gt;Pub&lt;x42/&gt;Pub&lt;x42/&gt;のコードで発生するかによって、&lt;x33/&gt;Priv&lt;x38/&gt;の異なるを参照しなければなりません。x39。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SizeUnknown()&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112328Z" creationid="hsugawa8651" creationdate="20181112T112328Z">
        <seg>SizeUnknown()&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Smallest value</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225124Z" creationid="hsugawa8651" creationdate="20181109T225124Z">
        <seg>最小値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So &lt;x1/&gt;-2x&lt;x2/&gt; is parsed as &lt;x3/&gt;(-2) * x&lt;x4/&gt; and &lt;x5/&gt;√2x&lt;x6/&gt; is parsed as &lt;x7/&gt;(√2) * x&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111801Z" creationid="hsugawa8651" creationdate="20181112T111801Z">
        <seg>&lt;x1/&gt;-2x&lt;x2/&gt;は&lt;x3/&gt;(-2)*x&lt;x4/&gt;と解析され、&lt;x2/&gt;は&lt;x7/&gt;(√2)×x&lt;x8/&gt;と解析され、&lt;x7/&gt;となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, the method body that will be used here doesn't include a loop at all - just indexing into
the two tuples, multiplication and addition/subtraction.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032334Z" creationid="hsugawa8651" creationdate="20181116T032334Z">
        <seg>このため、ここで使用されるメソッド本体はループを一切含まず、単にインデックス作成するだけです。 2つのタプル、乗算と加算、減算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, we could have defined the &lt;x6/&gt;test&lt;x7/&gt; function above as</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225921Z" creationid="hsugawa8651" creationdate="20181109T225921Z">
        <seg>そこで、上記の&lt;x6/&gt;test&lt;x7/&gt;関数を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe
you'll need to take some extra precautions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152623Z" creationid="hsugawa8651" creationdate="20181117T152623Z">
        <seg>Cライブラリの中には、別のスレッドからコールバックを実行するものもあれば、スレッドセーフではないものもあります。 さらに注意する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Examples of C Wrappers</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151907Z" creationid="hsugawa8651" creationdate="20181117T151907Z">
        <seg>Cラッパーのいくつかの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some examples:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135007Z" creationid="hsugawa8651" creationdate="20181117T135007Z">
        <seg>いくつかの例を次に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some functions have both modifying (e.g., &lt;x3/&gt;sort!&lt;x4/&gt;) and non-modifying (&lt;x5/&gt;sort&lt;x6/&gt;) versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041726Z" creationid="hsugawa8651" creationdate="20181110T041726Z">
        <seg>関数の中には、修正(例えば&lt;x3/&gt;ソート!&lt;x4/&gt;)や修正されない(&lt;x5/&gt;ソート&lt;x6/&gt;)バージョンの両方があるものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some general notes:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150044Z" creationid="hsugawa8651" creationdate="20181117T150044Z">
        <seg>一般的な注意事項は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operations that should not be attempted include:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032222Z" creationid="hsugawa8651" creationdate="20181116T032222Z">
        <seg>試行されるべきでない操作には、次のものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes invariants must be enforced, either by checking arguments
or by transforming them.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155644Z" creationid="hsugawa8651" creationdate="20181117T155644Z">
        <seg>時には、引数をチェックすることによって、変数を強制する必要があります。 変えることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it is convenient to have a single expression which evaluates several subexpressions
in order, returning the value of the last subexpression as its value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225754Z" creationid="hsugawa8651" creationdate="20181109T225754Z">
        <seg>いくつかのサブ式を評価する単一の表現を持つことが便利な場合もあります。 は、最後のサブ式の値をその値として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, it's just convenient to be able to construct objects
with fewer or different types of parameters than they have fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155648Z" creationid="hsugawa8651" creationdate="20181117T155648Z">
        <seg>場合によっては、オブジェクトを構築することができます。 フィールドには、フィールドとは異なるタイプのパラメータが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting Algorithms</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063958Z" creationid="hsugawa8651" creationdate="20181114T063958Z">
        <seg>Sorting Algorithms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting Functions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150319Z" creationid="hsugawa8651" creationdate="20181117T150319Z">
        <seg>ソート関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting and Related Functions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150304Z" creationid="hsugawa8651" creationdate="20181117T150304Z">
        <seg>ソートと関連機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SparseVecStyle(::Val{0}) = SparseVecStyle()
SparseVecStyle(::Val{1}) = SparseVecStyle()
SparseVecStyle(::Val{2}) = SparseMatStyle()
SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131900Z" creationid="hsugawa8651" creationdate="20181113T131900Z">
        <seg>SparseVecStyle(::Val{0}) = SparseVecStyle()
SparseVecStyle(::Val{1}) = SparseVecStyle()
SparseVecStyle(::Val{2}) = SparseMatStyle()
SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Reference Syntax for ccall (deprecated):</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151838Z" creationid="hsugawa8651" creationdate="20181117T151838Z">
        <seg>ccall(廃止された)のための特別なリファレンス構文:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041912Z" creationid="hsugawa8651" creationdate="20181110T041912Z">
        <seg>Special Types</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special floating-point values</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110751Z" creationid="hsugawa8651" creationdate="20181112T110751Z">
        <seg>Special floating-point values</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151306Z" creationid="hsugawa8651" creationdate="20181117T151306Z">
        <seg>具体的には、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SquaresVector&lt;x1/&gt;, we are able to define &lt;x2/&gt;`setindex!`&lt;x3/&gt;,
and so we can mutate the array:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083229Z" creationid="hsugawa8651" creationdate="20181113T083229Z">
        <seg>SquaresVector&lt;x1/&gt;では、&lt;x2/&gt;'setindex!&lt;x3/&gt;を定義することができます。 配列を突然変異させることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StackTraces</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064236Z" creationid="hsugawa8651" creationdate="20181114T064236Z">
        <seg>StackTraces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard Julia Alias</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150851Z" creationid="hsugawa8651" creationdate="20181117T150851Z">
        <seg>標準ジュリアエイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard Numeric Types</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044707Z" creationid="hsugawa8651" creationdate="20181112T044707Z">
        <seg>Standard Numeric Types</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard comparison operations are defined for all the primitive numeric types:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132654Z" creationid="hsugawa8651" creationdate="20181113T132654Z">
        <seg>標準的な比較操作は、すべてのプリミティブ数値タイプに対して定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start up with the given system image file</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224637Z" creationid="hsugawa8651" creationdate="20181109T224637Z">
        <seg>指定されたシステムイメージファイルで起動する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strided arrays
must define a &lt;x3/&gt;`strides(A)`&lt;x4/&gt; method that returns a tuple of "strides" for each dimension; a
provided &lt;x5/&gt;`stride(A,k)`&lt;x6/&gt; method accesses the &lt;x7/&gt;k&lt;x8/&gt;th element within this tuple.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160458Z" creationid="hsugawa8651" creationdate="20181109T160458Z">
        <seg>ストローブされた配列 は、各次元のタプルを返す&lt;x3/&gt;`end(A)'&lt;x4/&gt;メソッドを定義する必要があります。 &lt;x5/&gt;`stride(A,k)'は、このタプル内の&lt;x7/&gt;k&lt;x8/&gt;番目のエレメントにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings in Julia can contain invalid UTF-8 code unit sequences.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020620Z" creationid="hsugawa8651" creationdate="20181116T020620Z">
        <seg>Strings in Julia can contain invalid UTF-8 code unit sequences.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Struct Type correspondences</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151131Z" creationid="hsugawa8651" creationdate="20181117T151131Z">
        <seg>構造型の対応付け</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SubArray&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041653Z" creationid="hsugawa8651" creationdate="20181112T041653Z">
        <seg>SubArray&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SubArray&lt;x1/&gt; is a specialization of &lt;x2/&gt;AbstractArray&lt;x3/&gt; that performs indexing by
sharing memory with the original array rather than by copying it.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160427Z" creationid="hsugawa8651" creationdate="20181109T160427Z">
        <seg>サブアレイ&lt;x1/&gt;は、インデックス作成を実行する&lt;x2/&gt;AbstractArray&lt;x3/&gt;の特殊化です。 コピーするのではなく、オリジナルのアレイとメモリを共有することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SubArray&lt;x1/&gt; is a specialization of &lt;x2/&gt;AbstractArray&lt;x3/&gt; that performs indexing by
sharing memory with the original array rather than by copying it. A &lt;x4/&gt;SubArray&lt;x5/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135339Z" creationid="hsugawa8651" creationdate="20181117T135339Z">
        <seg>サブアレイ&lt;x1/&gt;は、インデックス作成を実行する&lt;x2/&gt;AbstractArray&lt;x3/&gt;の特殊化です。 コピーするよりも、元のアレイとのメモリを共有することです。&lt;x4/&gt;サブアレイ&lt;x5/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, however, an unrelated package also named &lt;x13/&gt;Priv&lt;x14/&gt; has been published and become popular.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152854Z" creationid="hsugawa8651" creationdate="20181117T152854Z">
        <seg>その後、&lt;x13/&gt;Priv&lt;x14/&gt;という名前の無関係なパッケージが発行され、一般的になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such behaviour can be avoided by using &lt;x7/&gt;ISO_C_BINDING&lt;x8/&gt; and
including &lt;x9/&gt;bind(c)&lt;x10/&gt; in the definition of the subroutine, which is strongly recommended for
interoperable code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151121Z" creationid="hsugawa8651" creationdate="20181117T151121Z">
        <seg>このような動作は、&lt;x7/&gt;ISO_C_BINDING&lt;x8/&gt;を使用して回避することができます。 サブルーチンの定義には&lt;x9/&gt;bind(c)&lt;x10/&gt;を含めることが強く推奨されます。このサブルーチンは、以下のように強く推奨されます。 相互運用可能なコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you call a function like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024957Z" creationid="hsugawa8651" creationdate="20181110T024957Z">
        <seg>次のような関数を呼び出すとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you're developing an application called &lt;x1/&gt;App&lt;x2/&gt;, which uses two packages: &lt;x3/&gt;Pub&lt;x4/&gt; and  &lt;x5/&gt;Priv&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152848Z" creationid="hsugawa8651" creationdate="20181117T152848Z">
        <seg>&lt;x1/&gt;App&lt;x2/&gt;というアプリケーションを開発していると仮定します。&lt;x3/&gt;Pub&lt;x4/&gt;と&lt;x5/&gt;Priv&lt;x6/&gt;の2つのパッケージを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronization Primitives</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044704Z" creationid="hsugawa8651" creationdate="20181112T044704Z">
        <seg>Synchronization Primitives</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030853Z" creationid="hsugawa8651" creationdate="20181114T030853Z">
        <seg>Syntax</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax / Keyword</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150615Z" creationid="hsugawa8651" creationdate="20181117T150615Z">
        <seg>構文/キーワード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Independent:&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150843Z" creationid="hsugawa8651" creationdate="20181117T150843Z">
        <seg>システムに依存しない:&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System-dependent:&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150959Z" creationid="hsugawa8651" creationdate="20181117T150959Z">
        <seg>システム依存:&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T (*)(...)&lt;x1/&gt; (e.g. a pointer to a function)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151559Z" creationid="hsugawa8651" creationdate="20181117T151559Z">
        <seg>T(*)(...)&lt;x1/&gt;(例:関数へのポインタ)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T(Base.to_shape(inds))&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094513Z" creationid="hsugawa8651" creationdate="20181118T094513Z">
        <seg>T(Base.to_shape(inds))&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T*&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151547Z" creationid="hsugawa8651" creationdate="20181117T151547Z">
        <seg>T*&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T...&lt;x1/&gt; (where &lt;x2/&gt;T&lt;x3/&gt; is one of the above types, variadic functions of different argument types are not supported)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150946Z" creationid="hsugawa8651" creationdate="20181117T150946Z">
        <seg>T.…&lt;x1/&gt;(ここで、&lt;x2/&gt;T&lt;x3/&gt;は、異なる引数タイプの変数はサポートされていません。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T...&lt;x1/&gt;, where &lt;x2/&gt;T&lt;x3/&gt; is the Julia type</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151748Z" creationid="hsugawa8651" creationdate="20181117T151748Z">
        <seg>T.…&lt;x1/&gt;は、&lt;x2/&gt;T&lt;x3/&gt;はジュリア型である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031120Z" creationid="hsugawa8651" creationdate="20181114T031120Z">
        <seg>T&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T&lt;x1/&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063648Z" creationid="hsugawa8651" creationdate="20181114T063648Z">
        <seg>T&lt;x1/&gt;はプリミティブビット型であり、タプル長はセット{2-6,8-10,16}にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T&lt;x1/&gt; is not known statically.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151245Z" creationid="hsugawa8651" creationdate="20181117T151245Z">
        <seg>T&lt;x1/&gt;は静的に認識されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T&lt;x1/&gt;, where &lt;x2/&gt;T&lt;x3/&gt; is a Julia Leaf Type</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151805Z" creationid="hsugawa8651" creationdate="20181117T151805Z">
        <seg>T&lt;x1/&gt;。ここで&lt;x2/&gt;T&lt;x3/&gt;はJulia Leaf Typeである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T&lt;x1/&gt;, where &lt;x2/&gt;T&lt;x3/&gt; is a Julia leaf type</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151519Z" creationid="hsugawa8651" creationdate="20181117T151519Z">
        <seg>T&lt;x1/&gt;は、&lt;x2/&gt;T&lt;x3/&gt;はJulia leaf型である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T&lt;x1/&gt;, where &lt;x2/&gt;T&lt;x3/&gt; is an equivalent Julia Bits Type (per the table above)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151510Z" creationid="hsugawa8651" creationdate="20181117T151510Z">
        <seg>T&lt;x1/&gt;は、&lt;x2/&gt;T&lt;x3/&gt;であり、ここで、&lt;x2/&gt;は、等価なジュリア・ビット型(上記表に基づく)である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T&lt;x1/&gt;, where &lt;x2/&gt;T&lt;x3/&gt; is one of the primitive types: &lt;x4/&gt;char&lt;x5/&gt;, &lt;x6/&gt;int&lt;x7/&gt;, &lt;x8/&gt;long&lt;x9/&gt;, &lt;x10/&gt;short&lt;x11/&gt;, &lt;x12/&gt;float&lt;x13/&gt;, &lt;x14/&gt;double&lt;x15/&gt;,
&lt;x16/&gt;complex&lt;x17/&gt;, &lt;x18/&gt;enum&lt;x19/&gt; or any of their &lt;x20/&gt;typedef&lt;x21/&gt; equivalents</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151508Z" creationid="hsugawa8651" creationdate="20181117T151508Z">
        <seg>T&lt;x1/&gt;ここで&lt;x2/&gt;T&lt;x3/&gt;はプリミティブ型の一つであり、&lt;x4/&gt;char&lt;x5/&gt;、&lt;x6/&gt;int&lt;x7/&gt;、&lt;x8/&gt;、&lt;x9/&gt;、&lt;x12/&gt;、&lt;x12/&gt;、&lt;x12/&gt;、x12/&gt;、&lt;x14/&gt;、x15/&gt;、x15/&gt;、x15/&gt;、x15/&gt;、x15/&gt;、x15/&gt;、x15/&gt;、x15/&gt;である。 &lt;x16/&gt;コンプレックス&lt;x17/&gt;、&lt;x18/&gt;enum&lt;x19/&gt;、またはそれらの&lt;x20/&gt;typedef&lt;X21/&gt;等価物のいずれか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking any locks: C code you call out to may use locks internally, (for example, it is not problematic
to call &lt;x1/&gt;malloc&lt;x2/&gt;, even though most implementations require locks internally) but don't attempt
to hold or acquire any while executing Julia code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032233Z" creationid="hsugawa8651" creationdate="20181116T032233Z">
        <seg>ロックを取る:呼び出し先のCコードは、内部的にロックを使用することがあります(たとえば、問題が発生しないようにします)。 &lt;x1/&gt;malloc&lt;x2/&gt;を呼び出すためには、ほとんどの実装は内部的にロックを必要としますが、実行しないでください。 は、ジュリア・コードの実行中に保持または取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044738Z" creationid="hsugawa8651" creationdate="20181112T044738Z">
        <seg>Tasks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Text I/O</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043213Z" creationid="hsugawa8651" creationdate="20181112T043213Z">
        <seg>Text I/O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That allows the user to control
the size.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225434Z" creationid="hsugawa8651" creationdate="20181109T225434Z">
        <seg>これによってユーザは サイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, &lt;x11/&gt;eps(x)&lt;x12/&gt; yields a value of the same type as &lt;x13/&gt;x&lt;x14/&gt; such that
&lt;x15/&gt;x + eps(x)&lt;x16/&gt; is the next representable floating-point value larger than &lt;x17/&gt;x&lt;x18/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111202Z" creationid="hsugawa8651" creationdate="20181112T111202Z">
        <seg>すなわち、&lt;x11/&gt;eps(x)&lt;x12/&gt;は、&lt;x13/&gt;x&lt;x14/&gt;と同じタイプの値を生成し、それによって &lt;x15/&gt;x+eps(x)&lt;x16/&gt;は、&lt;x17/&gt;x&lt;x18/&gt;より大きい次の表現可能浮動小数点値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if &lt;x1/&gt;a&lt;x2/&gt; contained
a reference to &lt;x3/&gt;b&lt;x4/&gt; and both &lt;x5/&gt;a&lt;x6/&gt; and &lt;x7/&gt;b&lt;x8/&gt; are due for garbage collection, there is no guarantee
that &lt;x9/&gt;b&lt;x10/&gt; would be finalized after &lt;x11/&gt;a&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152252Z" creationid="hsugawa8651" creationdate="20181117T152252Z">
        <seg>すなわち、&lt;x1/&gt;a&lt;x2/&gt;が含まれる場合 &lt;x3/&gt;b&lt;x4/&gt;への参照と、&lt;x5/&gt;a&lt;x6/&gt;と&lt;x7/&gt;b&lt;x8/&gt;は、ガーベッジ・コレクションのためのものであり、保証するものではありません。 &lt;x9/&gt;b&lt;x10/&gt;は、&lt;x11/&gt;a&lt;x12/&gt;の後に最終的に確定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that the values and types of local variables are not available at code generation
time --- the code-generation code can only see the types of arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032413Z" creationid="hsugawa8651" creationdate="20181116T032413Z">
        <seg>つまり、ローカル変数の値と型は、コード生成では使用できないということです。 time--コード生成コードは、引数の種類だけを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That supertype and those three
methods are all it takes for &lt;x7/&gt;SquaresVector&lt;x8/&gt; to be an iterable, indexable, and completely functional
array:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083211Z" creationid="hsugawa8651" creationdate="20181113T083211Z">
        <seg>そのスーパータイプと3は メソッドは、&lt;x7/&gt;SquaresVector&lt;x8/&gt;を実行するために必要とされるものであり、これは、実行可能な、インデックス可能な、完全に機能するものです。 配列:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
Julia programming language fills this role: it is a flexible dynamic
language, appropriate for scientific and numerical computing, with
performance comparable to traditional statically-typed languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081452Z" creationid="hsugawa8651" creationdate="20181118T081452Z">
        <seg> Juliaはこのような目的のために開発されています。つまり、Juliaは柔軟な動的言語であると同時に、古くからの静的型付け言語と同等の性能を実現することで科学計算や数値計算に適してたものになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
name of the script itself is passed in as the global &lt;x7/&gt;PROGRAM_FILE&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224334Z" creationid="hsugawa8651" creationdate="20181109T224334Z">
        <seg>の スクリプト自体の名前は、グローバルな&lt;x7/&gt;PROGRAM_FILE&lt;x8/&gt;として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
resulting expression contains &lt;x5/&gt;only&lt;x6/&gt; the second &lt;x7/&gt;println&lt;x8/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015342Z" creationid="hsugawa8651" creationdate="20181116T015342Z">
        <seg>The
resulting expression contains &lt;x5/&gt;only&lt;x6/&gt; the second &lt;x7/&gt;println&lt;x8/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 32-bit floating-point literal expression &lt;x1/&gt;1.5f22&lt;x2/&gt; could be interpreted as the numeric literal
&lt;x3/&gt;1.5&lt;x4/&gt; multiplied by the variable &lt;x5/&gt;f22&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111934Z" creationid="hsugawa8651" creationdate="20181112T111934Z">
        <seg>32ビット浮動小数点リテラル式&lt;x1/&gt;1f22&lt;x2/&gt;は、数値リテラルとして解釈することができます。 &lt;x3/&gt;1.5&lt;x4/&gt;は、変数&lt;x5/&gt;F22&lt;x6/&gt;で乗算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c14&gt;&lt;s15&gt;ans&lt;/s15&gt;&lt;/c14&gt; variable is only bound in interactive
sessions, not when Julia code is run in other ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084210Z" creationid="hsugawa8651" creationdate="20181118T084007Z">
        <seg>&lt;c14&gt;&lt;s15&gt;ans &lt;/s15&gt;&lt;/c14&gt;はインタラクティブ・セッションでのみ利用可能で、他の方法でJuliaのコードが実行された際には使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;&amp;&lt;x2/&gt; syntax is deprecated, use the &lt;x3/&gt;Ref{T}&lt;x4/&gt; argument type instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151841Z" creationid="hsugawa8651" creationdate="20181117T151841Z">
        <seg>&lt;x1/&gt;&amp;&lt;x2/&gt;構文は廃止されます。代わりに、&lt;x3/&gt;Ref{T}&lt;x4/&gt;引数タイプを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;--&lt;x2/&gt; delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224357Z" creationid="hsugawa8651" creationdate="20181109T224357Z">
        <seg>&lt;x1/&gt;--&lt;x2/&gt;デリミタは、July:を対象とした引数から、スクリプトファイルに対して指定されたコマンドライン引数を区切るために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;AbstractArray&lt;x2/&gt; type includes anything vaguely array-like, and implementations of it might
be quite different from conventional arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160313Z" creationid="hsugawa8651" creationdate="20181109T160313Z">
        <seg>&lt;x1/&gt;AbstractArray&lt;x2/&gt;タイプは、曖昧な配列を含んでおり、実装は実装されています。 従来のアレイとは大きく異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;AbstractArray&lt;x2/&gt; type includes anything vaguely array-like, and implementations of it might
be quite different from conventional arrays. For example, elements might be computed on request
rather than stored. However, any concrete &lt;x3/&gt;AbstractArray{T,N}&lt;x4/&gt; type should generally implement
at least &lt;x5/&gt;`size(A)`&lt;x6/&gt; (returning an &lt;x7/&gt;Int&lt;x8/&gt; tuple), &lt;x9/&gt;`getindex(A,i)`&lt;x10/&gt; and &lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;(@ref getindex);
mutable arrays should also implement &lt;x14/&gt;`setindex!`&lt;x15/&gt;. It is recommended that these operations
have nearly constant time complexity, or technically Õ(1) complexity, as otherwise some array
functions may be unexpectedly slow. Concrete types should also typically provide a &lt;x16/&gt;`similar(A,T=eltype(A),dims=size(A))`&lt;x17/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135318Z" creationid="hsugawa8651" creationdate="20181117T135318Z">
        <seg>&lt;x1/&gt;AbstractArray&lt;x2/&gt;タイプは、曖昧な配列を含んでおり、実装は実装されています。 従来のアレイとはかなり異なります。たとえば、要求に対して要素が計算される場合があります。 ただし、保存するのではなく、すべての具体的な&lt;x3/&gt;AbstractArray{T,N}&lt;x4/&gt;タイプを実装する必要があります。 &lt;x5/&gt;'size(A)'&lt;x6/&gt;(return an&lt;x7/&gt;Int&lt;x8/&gt;タプルを返す)&lt;x9/&gt;`getindex(A,i)`&lt;x10/&gt;&lt;x13/&gt;&lt;x13/&gt;&lt;x13/&gt;&lt;x13/&gt;(@ref getindex); mutable配列は、&lt;x14/&gt;'setindex!`&lt;x15/&gt;を実装する必要があります。これらの操作を行うには、次の操作を行うことをお勧めします ほとんど一定の時間的複雑さ(技術的には1)、あるいは技術的には複雑さがある 関数は予期せぬほど遅くなります。具体的には、&lt;x16/&gt;`同様(A、T=エルテープ(A)、dims=size(A))`&lt;x17/&gt;を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;GNU Scientific Library&lt;x2/&gt; (here assumed to be accessible
through &lt;x3/&gt;:libgsl&lt;x4/&gt;) defines an opaque pointer, &lt;x5/&gt;gsl_permutation *&lt;x6/&gt;, as the return type of the C
function &lt;x7/&gt;gsl_permutation_alloc&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152041Z" creationid="hsugawa8651" creationdate="20181117T152041Z">
        <seg>&lt;x1/&gt;GNU Scientific Library&lt;x2/&gt;(ここではアクセス可能であると仮定される) &lt;x3/&gt;:libgsl&lt;x4/&gt;は、Cの戻り型として、不透明ポインタ&lt;x5/&gt;gsl_substitutions*&lt;x6/&gt;を定義している。 関数&lt;x7/&gt;gsl_mutation_alloc&lt;x8/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;Pkg&lt;x2/&gt; package manager ships with Julia 0.7/1.0 and lets you install and manage your projects' dependencies.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152827Z" creationid="hsugawa8651" creationdate="20181117T152827Z">
        <seg>&lt;x1/&gt;Pkg&lt;x2/&gt;パッケージマネージャはJulia0.7/1.0と一緒に出荷され、プロジェクトの依存関係をインストールして管理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;Rounding functions&lt;x2/&gt; take a type &lt;x3/&gt;T&lt;x4/&gt; as an optional argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031049Z" creationid="hsugawa8651" creationdate="20181114T031049Z">
        <seg>&lt;x1/&gt;丸め関数&lt;x2/&gt;は、オプションの引数として&lt;x3/&gt;T&lt;x4/&gt;の型をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;`BigFloat`&lt;x2/&gt; and &lt;x3/&gt;`BigInt`&lt;x4/&gt; types implements
arbitrary-precision floating point and integer arithmetic, respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032210Z" creationid="hsugawa8651" creationdate="20181114T032210Z">
        <seg>&lt;x1/&gt;`BigFloat'&lt;x2/&gt;と、&lt;x3/&gt;"BigInt"&lt;x4/&gt;型は実装されている。 任意精度浮動小数点および整数算術。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;`Cstring`&lt;x2/&gt; type is essentially a synonym for &lt;x3/&gt;Ptr{UInt8}&lt;x4/&gt;, except the conversion to &lt;x5/&gt;Cstring&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150948Z" creationid="hsugawa8651" creationdate="20181117T150948Z">
        <seg>&lt;x1/&gt;のCstring&lt;x2/&gt;型は本質的に&lt;x3/&gt;Ptr{UInt8}&lt;x4/&gt;の同義語であり、&lt;x5/&gt;Cstring&lt;x6/&gt;への変換を除く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;`typemin`&lt;x2/&gt; and &lt;x3/&gt;`typemax`&lt;x4/&gt; functions also apply to floating-point types:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111123Z" creationid="hsugawa8651" creationdate="20181112T110920Z">
        <seg>&lt;x1/&gt;`テーパミン'&lt;x2/&gt;と&lt;x3/&gt;'テーペマス'&lt;x4/&gt;関数も浮動小数点型に適用される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;base&lt;x2/&gt; argument is a pointer to an array of length &lt;x3/&gt;nmemb&lt;x4/&gt;, with elements of &lt;x5/&gt;size&lt;x6/&gt; bytes
each.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150525Z" creationid="hsugawa8651" creationdate="20181117T150525Z">
        <seg>&lt;x1/&gt;の基本&lt;x2/&gt;引数は、&lt;x5/&gt;nmemb&lt;x4/&gt;の配列へのポインタであり、&lt;x5/&gt;サイズ&lt;x6/&gt;バイトの要素がある。 各。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;base&lt;x2/&gt; argument is a pointer to an array of length &lt;x3/&gt;nmemb&lt;x4/&gt;, with elements of &lt;x5/&gt;size&lt;x6/&gt; bytes
each. &lt;x7/&gt;compare&lt;x8/&gt; is a callback function which takes pointers to two elements &lt;x9/&gt;a&lt;x10/&gt; and &lt;x11/&gt;b&lt;x12/&gt; and returns
an integer less/greater than zero if &lt;x13/&gt;a&lt;x14/&gt; should appear before/after &lt;x15/&gt;b&lt;x16/&gt; (or zero if any order
is permitted). Now, suppose that we have a 1d array &lt;x17/&gt;A&lt;x18/&gt; of values in Julia that we want to sort
using the &lt;x19/&gt;qsort&lt;x20/&gt; function (rather than Julia's built-in &lt;x21/&gt;sort&lt;x22/&gt; function). Before we worry about
calling &lt;x23/&gt;qsort&lt;x24/&gt; and passing arguments, we need to write a comparison function that works for some
arbitrary objects (which define &lt;x25/&gt;&lt;&lt;x26/&gt;):</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133933Z" creationid="hsugawa8651" creationdate="20181117T133931Z">
        <seg>The &lt;x1/&gt;base&lt;x2/&gt; argument is a pointer to an array of length &lt;x3/&gt;nmemb&lt;x4/&gt;, with elements of &lt;x5/&gt;size&lt;x6/&gt; bytes
each. &lt;x7/&gt;compare&lt;x8/&gt; is a callback function which takes pointers to two elements &lt;x9/&gt;a&lt;x10/&gt; and &lt;x11/&gt;b&lt;x12/&gt; and returns
an integer less/greater than zero if &lt;x13/&gt;a&lt;x14/&gt; should appear before/after &lt;x15/&gt;b&lt;x16/&gt; (or zero if any order
is permitted). Now, suppose that we have a 1d array &lt;x17/&gt;A&lt;x18/&gt; of values in Julia that we want to sort
using the &lt;x19/&gt;qsort&lt;x20/&gt; function (rather than Julia's built-in &lt;x21/&gt;sort&lt;x22/&gt; function). Before we worry about
calling &lt;x23/&gt;qsort&lt;x24/&gt; and passing arguments, we need to write a comparison function that works for some
arbitrary objects (which define &lt;x25/&gt;&lt;&lt;x26/&gt;):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;for&lt;x2/&gt; loop makes common repeated evaluation idioms easier to write.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T231125Z" creationid="hsugawa8651" creationdate="20181109T231125Z">
        <seg>&lt;x2/&gt;ループのための&lt;x1/&gt;は、共通の繰り返し評価イディオムを書くのを容易にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;isless&lt;x2/&gt; function is invoked by default, but the relation
can be specified via the &lt;x3/&gt;lt&lt;x4/&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063935Z" creationid="hsugawa8651" creationdate="20181114T063935Z">
        <seg>&lt;x1/&gt;isless&lt;x2/&gt;関数はデフォルトで呼び出されますが、関係は次のようになります。 は&lt;x3/&gt;lt&lt;x4/&gt;キーワードで指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;state&lt;x2/&gt; object may be anything, and should be chosen appropriately for each iterable type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032029Z" creationid="hsugawa8651" creationdate="20181114T032029Z">
        <seg>The &lt;x1/&gt;state&lt;x2/&gt; object may be anything, and should be chosen appropriately for each iterable type.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x1/&gt;while&lt;x2/&gt; loop evaluates the condition expression (&lt;x3/&gt;i &lt;= 5&lt;x4/&gt; in this case), and as long it remains
&lt;x5/&gt;true&lt;x6/&gt;, keeps also evaluating the body of the &lt;x7/&gt;while&lt;x8/&gt; loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230858Z" creationid="hsugawa8651" creationdate="20181109T230858Z">
        <seg>&lt;x1/&gt;while&lt;x2/&gt;ループは条件式(この場合は&lt;x3/&gt;i&lt;=5&lt;x4/&gt;)を評価しており、それは長いままである &lt;x5/&gt;true&lt;x6/&gt;は、&lt;x8/&gt;ループでは、&lt;x7/&gt;のボディを評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x15/&gt;ans&lt;x16/&gt; variable is only
bound in interactive sessions, not when Julia code is run in other ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091601Z" creationid="hsugawa8651" creationdate="20181114T031402Z">
        <seg>&lt;x15/&gt;ans &lt;x16/&gt;はインタラクティブ・セッションでのみ利用可能で、他の方法でJuliaのコードが実行された際には使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x3/&gt;`Base.broadcastable`&lt;x4/&gt; function is called on each argument to broadcast, allowing
it to return something different that supports &lt;x5/&gt;axes&lt;x6/&gt; and indexing.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131036Z" creationid="hsugawa8651" creationdate="20181113T131036Z">
        <seg>&lt;x3/&gt;'Base.broadcastable'&lt;x4/&gt;関数は、各引数で呼び出され、ブロードキャストされます。 &lt;x5/&gt;軸&lt;x6/&gt;とインデックス作成をサポートするものとは異なるものを返すことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x5/&gt;AbstractArray&lt;x6/&gt; fallback methods use &lt;x7/&gt;`similar`&lt;x8/&gt; to allocate an &lt;x9/&gt;Array&lt;x10/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083303Z" creationid="hsugawa8651" creationdate="20181113T083303Z">
        <seg>&lt;x5/&gt;AbstractArray&lt;x6/&gt;フォールバックメソッドは&lt;x7/&gt;'を使用して、&lt;x9/&gt;アレイを割り当てます。&lt;x6/&gt;&lt;x10/&gt;&lt;x10/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x5/&gt;`BigInt`&lt;x6/&gt; and &lt;x7/&gt;`BigFloat`&lt;x8/&gt; types are available in Julia for arbitrary
precision integer and floating point numbers respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111544Z" creationid="hsugawa8651" creationdate="20181112T111544Z">
        <seg>&lt;x5/&gt;"BigInt"&lt;x6/&gt;および&lt;x7/&gt;"BigFloat"&lt;x8/&gt;"は、任意のためにJuliaで利用可能である。 精度整数と浮動小数点数をそれぞれ指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x7/&gt;`Array`&lt;x8/&gt; type is a specific instance
of &lt;x9/&gt;DenseArray&lt;x10/&gt;;  &lt;x11/&gt;`Vector`&lt;x12/&gt; and &lt;x13/&gt;`Matrix`&lt;x14/&gt; are aliases for the 1-d and 2-d cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160422Z" creationid="hsugawa8651" creationdate="20181109T160422Z">
        <seg>&lt;x7/&gt;「Array」&lt;x8/&gt;タイプは、特定のインスタンスです。 &lt;x9/&gt;DenseArray&lt;x10/&gt;;&lt;x11/&gt;'Vector'&lt;x12/&gt;および&lt;x13/&gt;'Matrix'&lt;x14/&gt;は、1-dおよび2-dケースのエイリアスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;x9/&gt;`eps`&lt;x10/&gt; function can also take a floating-point value as an
argument, and gives the absolute difference between that value and the next representable
floating point value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111150Z" creationid="hsugawa8651" creationdate="20181112T111150Z">
        <seg>&lt;x9/&gt;'eps'&lt;x10/&gt;関数は、浮動小数点値を 引数は、その値と次の表現可能な値との間に絶対差を与えます。 浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C &lt;x1/&gt;getenv&lt;x2/&gt; function indicates an error by returning &lt;x3/&gt;NULL&lt;x4/&gt;, but other standard C functions
indicate errors in various different ways, including by returning -1, 0, 1 and other special values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224130Z" creationid="hsugawa8651" creationdate="20181109T224130Z">
        <seg>C&lt;x1/&gt;getenv&lt;x2/&gt;関数は、&lt;x3/&gt;NULL&lt;x4/&gt;を返すことによってエラーを示しますが、他の標準的なC関数の関数です。 -1 0 1、その他の特別な値を返すなど、さまざまな方法でエラーを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C &lt;x1/&gt;getenv&lt;x2/&gt; function indicates an error by returning &lt;x3/&gt;NULL&lt;x4/&gt;, but other standard C functions
indicate errors in various different ways, including by returning -1, 0, 1 and other special values.
This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent
environment variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134122Z" creationid="hsugawa8651" creationdate="20181117T134122Z">
        <seg>C&lt;x1/&gt;getenv&lt;x2/&gt;関数は、&lt;x3/&gt;NULL&lt;x4/&gt;を返すことによってエラーを示しますが、他の標準的なC関数の関数です。 -1 0 1、その他の特別な値を返すなど、さまざまな方法でエラーを表示します。 このラッパーは、呼び出し者が存在しないことを示す問題を明確に示す例外をスローします。 環境変数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C function wrapped returns an integer error code; the results of the actual evaluation of
the Bessel J function populate the Julia array &lt;x1/&gt;result_array&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152202Z" creationid="hsugawa8651" creationdate="20181117T152202Z">
        <seg>C関数は、整数エラー・コードを返します。実際の評価結果は次のようになります。 Bessel J関数は、Julia配列&lt;x1/&gt;result_array&lt;x2/&gt;を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Julia internal variable &lt;x1/&gt;`Sys.WORD_SIZE`&lt;x2/&gt; indicates whether the target system is 32-bit
or 64-bit:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110332Z" creationid="hsugawa8651" creationdate="20181112T110332Z">
        <seg>Julia内部変数&lt;x1/&gt;`Sys.WORD_SIZE`&lt;x2/&gt;は、ターゲットシステムが32ビットであるかどうかを示します。 または64ビット:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to define function behavior across many combinations of
argument types via &lt;a0&gt;multiple
dispatch&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082157Z" creationid="hsugawa8651" creationdate="20181118T082117Z">
        <seg>&lt;a0&gt;多重ディスパッチ&lt;/a0&gt; によってさまざまな引数の組み合わせごとに関数の振る舞いを定義できます
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above results are all &lt;x1/&gt;`Float64`&lt;x2/&gt; values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110619Z" creationid="hsugawa8651" creationdate="20181112T110619Z">
        <seg>上記の結果は全て&lt;x1/&gt;'Float64&lt;x2/&gt;の値である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above syntactic enhancements significantly reduce the visual noise incurred when writing common
mathematical formulae.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111904Z" creationid="hsugawa8651" creationdate="20181112T111904Z">
        <seg>上記の構文的拡張は、一般的な書き込みの際に発生する視覚的なノイズを大幅に低減します。 数式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The absolute path of the directory containing the Julia executable, which sets
the global variable &lt;x1/&gt;`Sys.BINDIR`&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054725Z" creationid="hsugawa8651" creationdate="20181116T054725Z">
        <seg>The absolute path of the directory containing the Julia executable, which sets
the global variable &lt;x1/&gt;`Sys.BINDIR`&lt;x2/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual allocation of the result array is
handled by &lt;x1/&gt;similar&lt;x2/&gt;, using the Broadcasted object as its first argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131302Z" creationid="hsugawa8651" creationdate="20181113T131302Z">
        <seg>結果配列の実際の割り当ては次のとおりです。 ブロードキャストオブジェクトを最初の引数として使用して、&lt;x1/&gt;類似の&lt;x2/&gt;で処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))

julia&gt; eval(ex)
I execute at runtime.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015349Z" creationid="hsugawa8651" creationdate="20181116T015349Z">
        <seg>The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))

julia&gt; eval(ex)
I execute at runtime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument is: ", $arg))
       end
@twostep (macro with 1 method)

julia&gt; ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );
I execute at parse time.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015339Z" creationid="hsugawa8651" creationdate="20181116T015339Z">
        <seg>The argument is: ", $arg))
       end
@twostep (macro with 1 method)

julia&gt; ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );
I execute at parse time.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array library is implemented
almost completely in Julia itself, and derives its performance from the compiler, just like any
other code written in Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154129Z" creationid="hsugawa8651" creationdate="20181109T154129Z">
        <seg>アレイ・ライブラリーは実装されています。 ほとんどの場合、ジュリア自身は、コンパイラーからのパフォーマンスを導き出し その他のコードはジュリアに書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base Julia runtime provides only plain-text display, but richer displays may be enabled by
loading external modules or by using graphical Julia environments (such as the IPython-based IJulia
notebook).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043259Z" creationid="hsugawa8651" creationdate="20181112T043259Z">
        <seg>基本的なJuliaランタイムはプレーンテキスト表示のみを提供しますが、よりリッチなディスプレイを有効にすることができます。 外部モジュールをロードするか、グラフィカルなJulia環境(IPythonベースのIJuliaなど)を使用する )を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base array type in Julia is the abstract type &lt;x1/&gt;`AbstractArray{T,N}`&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161340Z" creationid="hsugawa8651" creationdate="20181114T161340Z">
        <seg>ジュリアのベース・アレイ型は、抽象型の&lt;x1/&gt;`AbstractArray{T,N}'&lt;x2/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base array type in Julia is the abstract type &lt;x1/&gt;`AbstractArray{T,N}`&lt;x2/&gt;. It is parameterized by
the number of dimensions &lt;x3/&gt;N&lt;x4/&gt; and the element type &lt;x5/&gt;T&lt;x6/&gt;. &lt;x7/&gt;`AbstractVector`&lt;x8/&gt; and &lt;x9/&gt;`AbstractMatrix`&lt;x10/&gt; are
aliases for the 1-d and 2-d cases. Operations on &lt;x11/&gt;AbstractArray&lt;x12/&gt; objects are defined using higher
level operators and functions, in a way that is independent of the underlying storage. These operations
generally work correctly as a fallback for any specific array implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135313Z" creationid="hsugawa8651" creationdate="20181117T135313Z">
        <seg>Juliaの基本配列タイプは、抽象型&lt;x1/&gt;'AbstractArray{T,N}'&lt;x2/&gt;であり、パラメータ化されています。 次元の数&lt;x3/&gt;N&lt;x4/&gt;および要素タイプ&lt;x5/&gt;T&lt;x6/&gt;.&lt;x7/&gt;'AbstractVector'&lt;x8/&gt;および&lt;x9/&gt;'AbstractMatrix'&lt;x10/&gt;は 1dおよび2dケースのエイリアス。&lt;x11/&gt;AbstractArray&lt;x12/&gt;オブジェクトに対する操作は、より高い値を使用して定義されます。 レベル演算子と関数は、基礎となるストレージとは無関係です。これらの操作は、次のような操作によって行われます。 一般的には、特定のアレイ実装のフォールバックとして正しく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic syntax for defining functions in Julia is:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025456Z" creationid="hsugawa8651" creationdate="20181110T025456Z">
        <seg>Juliaで関数を定義するための基本的な構文は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior is found in
most imperative programming languages having the &lt;x1/&gt;&amp;&amp;&lt;x2/&gt; and &lt;x3/&gt;||&lt;x4/&gt; boolean operators: in a series
of boolean expressions connected by these operators, only the minimum number of expressions are
evaluated as are necessary to determine the final boolean value of the entire chain.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230229Z" creationid="hsugawa8651" creationdate="20181109T230229Z">
        <seg>動作は &lt;x1/&gt;&amp;&amp;&lt;x2/&gt;と&lt;x3/&gt;&lt;x4/&gt;ブール演算子を持つ最も命令的なプログラミング言語:シリーズ これらの演算子によって接続されたブール式のうち、最小の数だけが チェーン全体の最終的なブール値を決定するために必要な評価が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body becomes almost identical, but
instead of calculating the linear index, we build up an &lt;x1/&gt;expression&lt;x2/&gt; that calculates the index:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032316Z" creationid="hsugawa8651" creationdate="20181116T032316Z">
        <seg>体はほぼ同じですが 線形インデックスを計算する代わりに、インデックスを計算する&lt;x1/&gt;式&lt;x2/&gt;を構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast style is computed for every broadcasting operation to allow for
dispatch and specialization.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131259Z" creationid="hsugawa8651" creationdate="20181113T131259Z">
        <seg>ブロードキャスト・スタイルは、すべてのブロードキャスト・オペレーションに対して計算され 派遣・専門化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built-in
broadcast machinery will then determine the result type and size based upon the arguments, allocate
it, and then finally copy the realization of the &lt;x13/&gt;Broadcasted&lt;x14/&gt; object into it with a default
&lt;x15/&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;x16/&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131542Z" creationid="hsugawa8651" creationdate="20181113T131542Z">
        <seg>内蔵の ブロードキャスト・マシンは、引数に基づいて結果のタイプとサイズを決定し、割り当てます。 そして、最後に、&lt;x13/&gt;ブロードキャストされた&lt;x14/&gt;オブジェクトの実現をデフォルトでその中にコピーします。 &lt;x15/&gt;copyto!(::AbstractArray,::ブロードキャスト)&lt;x16/&gt;メソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built-in fallback &lt;x17/&gt;broadcast&lt;x18/&gt; and
&lt;x19/&gt;broadcast!&lt;x20/&gt; methods similarly construct a transient &lt;x21/&gt;Broadcasted&lt;x22/&gt; representation of the operation
so they can follow the same codepath.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131537Z" creationid="hsugawa8651" creationdate="20181113T131537Z">
        <seg>組み込みのフォールバック&lt;x17/&gt;ブロードキャスト&lt;x18/&gt;と &lt;x19/&gt;ブロードキャスト!&lt;x20/&gt;メソッドは、同様に、操作の一時的な&lt;X21/&gt;ブロードキャスト&lt;x22/&gt;表現を構成します。 同じコデパスにたどり着くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The callback you pass to C should only execute a &lt;x1/&gt;`ccall`&lt;x2/&gt; to &lt;x3/&gt;:uv_async_send&lt;x4/&gt;, passing
&lt;x5/&gt;cond.handle&lt;x6/&gt; as the argument, taking care to avoid any allocations or other interactions with the
Julia runtime.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152633Z" creationid="hsugawa8651" creationdate="20181117T152633Z">
        <seg>Cに渡されるコールバックは、&lt;x1/&gt;`ccall'&lt;x2/&gt;を実行して、&lt;x3/&gt;:uv_async_send&lt;x4/&gt;を通過させるべきです。 &lt;x5/&gt;cond.handle&lt;x6/&gt;は引数として指定し、割り当てやその他の相互作用がないように注意してください。 Juliaランタイム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code to be called must be available as a shared library.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160547Z" creationid="hsugawa8651" creationdate="20181109T160547Z">
        <seg>呼び出されるコードは共有ライブラリとして使用できる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code to be called must be available as a shared library. Most C and Fortran libraries ship
compiled as shared libraries already, but if you are compiling the code yourself using GCC (or
Clang), you will need to use the &lt;x1/&gt;-shared&lt;x2/&gt; and &lt;x3/&gt;-fPIC&lt;x4/&gt; options. The machine instructions generated
by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same
as calling a library function from C code. (Non-library function calls in both C and Julia can
be inlined and thus may have even less overhead than calls to shared library functions. When both
libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations
that can even optimize across this boundary, but Julia does not yet support that. In the future,
however, it may do so, yielding even greater performance gains.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133708Z" creationid="hsugawa8651" creationdate="20181117T133708Z">
        <seg>呼び出されるコードは共有ライブラリとして使用可能である必要があります。ほとんどのCおよびFortranライブラリは、次のようになります。 はすでに共有ライブラリとしてコンパイルされていますが、GCCを使用して自分でコードをコンパイルする場合は Clang)は、&lt;x1/&gt;-共有&lt;x2/&gt;および&lt;x3/&gt;-fPIC&lt;x4/&gt;オプションを使用する必要があります。 JuliaのJITはネイティブのC呼び出しと同じであるため、結果として生じるオーバーヘッドは同じです。 Cコードからライブラリ関数を呼び出します(CとJuliaの両方での非ライブラリ関数呼び出しです)。 共有ライブラリ関数への呼び出しよりも、インライン化されるため、オーバーヘッドが少なくなります。両方とも ライブラリと実行可能ファイルはLLVMによって生成されるため、プログラム全体の最適化を実行することができます。 この境界を越えて最適化することもできますがジュリアはまだサポートしていません将来は しかし、それによってパフォーマンスが向上する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler will use it if convenient, but otherwise may choose to use the normal
implementation instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032417Z" creationid="hsugawa8651" creationdate="20181116T032417Z">
        <seg>コンパイラは、便利であればそれを使用しますが、そうでなければ通常のものを使用することを選択することができます。 代わりに実装する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The concatenation functions are used so often that they have special syntax:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154623Z" creationid="hsugawa8651" creationdate="20181109T154623Z">
        <seg>連結関数は、頻繁に使用されるため、特別な構文が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents and code at the cfunction pointer will be erased via a &lt;x7/&gt;`finalizer`&lt;x8/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152344Z" creationid="hsugawa8651" creationdate="20181117T152344Z">
        <seg>cfunctionポインタでの内容とコードは、&lt;x7/&gt;`ファイナライザー''&lt;x8/&gt;によって消去されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The core language imposes very little; the standard library is
written in Julia itself, including primitive operations like integer
arithmetic</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082055Z" creationid="hsugawa8651" creationdate="20181118T082002Z">
        <seg>言語のコア部分は最小限の機能しか提供しません。整数の四則演算のような初等演算を含む標準ライブラリはJulia自身で書かれています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default constructor
is equivalent to writing your own inner constructor method that takes all of the object's fields
as parameters (constrained to be of the correct type, if the corresponding field has a type),
and passes them to &lt;x1/&gt;new&lt;x2/&gt;, returning the resulting object:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155809Z" creationid="hsugawa8651" creationdate="20181117T155809Z">
        <seg>デフォルトのコンストラクタ は、すべてのオブジェクトのフィールドを取得する独自のインナー・コンストラクタ・メソッドを記述することと同じです。 パラメータとして指定します(対応するフィールドが型を持つ場合は、正しいタイプに制限されます)。 そして、それらを&lt;x1/&gt;新しい&lt;x2/&gt;に渡して、結果として得られるオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default mode used is always &lt;x1/&gt;`RoundNearest`&lt;x2/&gt;, which rounds to the nearest representable
value, with ties rounded towards the nearest value with an even least significant bit.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111339Z" creationid="hsugawa8651" creationdate="20181112T111339Z">
        <seg>使用されるデフォルト・モードは常に&lt;x1/&gt;`RoundNearest'&lt;x2/&gt;であり、これは最も近い表現可能なものに丸められます。 値は、最も近い値に対して、最も近い値に丸められ、最も重要なビットであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default precision (in number of bits of the significand) and rounding mode of &lt;x1/&gt;`BigFloat`&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111601Z" creationid="hsugawa8651" creationdate="20181112T111601Z">
        <seg>&lt;x1/&gt;'BigFloat&lt;x2/&gt;のデフォルト精度(ビット数のビット数)と丸めモード&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default sorting algorithms are chosen on the basis that they are fast and stable, or &lt;x1/&gt;appear&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064120Z" creationid="hsugawa8651" creationdate="20181114T064120Z">
        <seg>デフォルトのソートアルゴリズムは、高速で安定しているか、&lt;x1/&gt;が&lt;x2/&gt;であることに基づいて選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default type for an integer literal depends on whether the target system has a 32-bit architecture
or a 64-bit architecture:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110320Z" creationid="hsugawa8651" creationdate="20181112T110320Z">
        <seg>整数リテラルのデフォルト・タイプは、ターゲット・システムに32ビット・アーキテクチャーがあるかどうかによって異なります。 64ビットのアーキテクチャ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitive guide to floating point arithmetic is the &lt;x1/&gt;IEEE 754-2008 Standard&lt;x2/&gt;;
however, it is not available for free online.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111446Z" creationid="hsugawa8651" creationdate="20181112T111446Z">
        <seg>浮動小数点演算の最終的なガイドは、&lt;x1/&gt;IEEE754-2008標準&lt;x2/&gt;です。 ただし、無料のオンラインでは利用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The destructuring feature can also be used within a function argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101537Z" creationid="hsugawa8651" creationdate="20181112T101537Z">
        <seg>デストラクチャリング機能は、関数引数内で使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The display functions for &lt;x11/&gt;D&lt;x12/&gt; can then be called directly, but they can also be invoked
automatically from &lt;x13/&gt;`display(x)`&lt;x14/&gt; simply by pushing a new display onto the display-backend stack
with:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043339Z" creationid="hsugawa8651" creationdate="20181112T043339Z">
        <seg>&lt;x11/&gt;D&lt;x12/&gt;の表示関数は直接呼び出すことができますが、呼び出されることもあります。 display(x)`&lt;x14/&gt;display(x)`&lt;x14/&gt;単に新しいディスプレイをディスプレイのバックエンド・スタックにプッシュすることによって、自動的に&lt;x13/&gt;`display(x)`&lt;x14/&gt;から :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The distance between two adjacent representable floating-point numbers is not constant, but is
smaller for smaller values and larger for larger values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111227Z" creationid="hsugawa8651" creationdate="20181112T111227Z">
        <seg>2つの隣接する表現可能浮動小数点数の間の距離は一定ではありませんが 小さい値では小さくなり、大きい値ほど大きい値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to learn and experiment with Julia is by starting an
interactive session (also known as a read-eval-print loop or “repl”)
by double-clicking the Julia executable or running &lt;c0&gt;&lt;s1&gt;julia&lt;/s1&gt;&lt;/c0&gt; from the
command line:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083810Z" creationid="hsugawa8651" creationdate="20181118T083810Z">
        <seg>Juliaを学んだり試したりする一番簡単な方法は、インタラクティブ・セッション（read-eval-print loop、もしくは”repl”とも呼ばれるものです）を使ったものです。セッションを起動するには、Juliaの実行ファイルをダブルクリックするか、コマンドラインから&lt;c0&gt;&lt;s1&gt;julia&lt;/s1&gt;&lt;/c0&gt; を実行します。

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to learn and experiment with Julia is by starting an interactive session (also
known as a read-eval-print loop or "REPL") by double-clicking the Julia executable or running
&lt;x1/&gt;julia&lt;x2/&gt; from the command line:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091013Z" creationid="hsugawa8651" creationdate="20181109T224254Z">
        <seg>Juliaを学んだり試したりする一番簡単な方法は、インタラクティブ・セッション（read-eval-print loop、もしくは”repl”とも呼ばれるものです）を使ったものです。セッションを起動するには、Juliaの実行ファイルをダブルクリックするか、コマンドラインから&lt;x1/&gt;julia&lt;x2/&gt;を実行します。

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to understand this behavior is to see an example.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230103Z" creationid="hsugawa8651" creationdate="20181109T230103Z">
        <seg>この動作を理解する最も簡単な方法は、例を見ることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect of &lt;x15/&gt;import X&lt;x16/&gt; depends on two questions:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152813Z" creationid="hsugawa8651" creationdate="20181117T152813Z">
        <seg>&lt;x15/&gt;インポートX&lt;x16/&gt;の効果は、次の2つの質問に依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The element type of the tuple must be an instance of &lt;x1/&gt;VecElement{T}&lt;x2/&gt; where &lt;x3/&gt;T&lt;x4/&gt; is a primitive type that
is 1, 2, 4 or 8 bytes.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151316Z" creationid="hsugawa8651" creationdate="20181117T151316Z">
        <seg>タプルの要素タイプは、&lt;x1/&gt;VecElement{T}&lt;x2/&gt;のインスタンスでなければならない。ここで、&lt;x3/&gt;T&lt;x4/&gt;はプリミティブ型である。 は、1 2 4バイトまたは8バイトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;x4/&gt;include("source.jl")&lt;x5/&gt; causes the contents of the file &lt;x6/&gt;source.jl&lt;x7/&gt; to be evaluated in the global scope of the module where the &lt;x8/&gt;include&lt;x9/&gt; call occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152713Z" creationid="hsugawa8651" creationdate="20181117T152713Z">
        <seg>&lt;x4/&gt;の表現は、&lt;x8/&gt;が&lt;x9/&gt;のコールが発生するモジュールのグローバルスコープで、ファイル&lt;x6/&gt;ソース.jl&lt;x7/&gt;の内容を評価することを意味します。&lt;x4/&gt;は、&lt;x8/&gt;の内容を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fallback definition is</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131316Z" creationid="hsugawa8651" creationdate="20181113T131316Z">
        <seg>フォールバック定義は、次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final argument
&lt;x1/&gt;bc&lt;x2/&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;x3/&gt;Broadcasted&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131331Z" creationid="hsugawa8651" creationdate="20181113T131331Z">
        <seg>最後の引数 &lt;x1/&gt;bc&lt;x2/&gt;は(潜在的に融合された)ブロードキャスト動作の遅延表現であり、&lt;x3/&gt;ブロードキャストされた&lt;x4/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final call to &lt;x1/&gt;qsort&lt;x2/&gt; looks like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150536Z" creationid="hsugawa8651" creationdate="20181117T150536Z">
        <seg>&lt;x1/&gt;qsort&lt;x2/&gt;の最終的な呼び出しは、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final problem which has still not been addressed is construction of self-referential objects,
or more generally, recursive data structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155838Z" creationid="hsugawa8651" creationdate="20181117T155838Z">
        <seg>まだ取り組まれていない最後の問題は、自己参照オブジェクトの構築です。 より一般的には、再帰データ構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument to &lt;x1/&gt;`@cfunction`&lt;x2/&gt; can be marked with a &lt;x3/&gt;$&lt;x4/&gt;, in which case
the return value will instead be a &lt;x5/&gt;struct CFunction&lt;x6/&gt; which closes over the argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152340Z" creationid="hsugawa8651" creationdate="20181117T152340Z">
        <seg>&lt;x1/&gt;`@cfunction`&lt;x2/&gt;の最初の引数は、&lt;x3/&gt;$&lt;x4/&gt;でマークすることができます。この場合は 戻り値は、引数の上で閉じる&lt;x5/&gt;構造体CFunction&lt;x6/&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument to &lt;x1/&gt;`ccall`&lt;x2/&gt; can also be an expression evaluated at run time.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152323Z" creationid="hsugawa8651" creationdate="20181117T152323Z">
        <seg>&lt;x1/&gt;`ccall'&lt;x2/&gt;への最初の引数は、実行時に評価された式でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first construct is used when you need the value, but not index, of each element.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155843Z" creationid="hsugawa8651" creationdate="20181109T155843Z">
        <seg>最初の構成は、各要素の値が必要な場合に使用されますが、インデックスでは使用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first construct is used when you need the value, but not index, of each element. In the second
construct, &lt;x1/&gt;i&lt;x2/&gt; will be an &lt;x3/&gt;Int&lt;x4/&gt; if &lt;x5/&gt;A&lt;x6/&gt; is an array type with fast linear indexing; otherwise,
it will be a &lt;x7/&gt;CartesianIndex&lt;x8/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135123Z" creationid="hsugawa8651" creationdate="20181117T135123Z">
        <seg>最初の構成は、各要素の値が必要な場合に使用されますが、インデックスではありません。2番目の構成は、次のように使用されます。 構成,&lt;x1/&gt;i&lt;x2/&gt;は&lt;x5/&gt;Int&lt;x6/&gt;であり,&lt;x5/&gt;A&lt;x6/&gt;が高速線形インデックスを用いたアレイ型である場合は,それ以外の値である。 &lt;x7/&gt;CartesianIndex&lt;x8/&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first five control flow mechanisms are standard to high-level programming languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225741Z" creationid="hsugawa8651" creationdate="20181109T225741Z">
        <seg>最初の5つの制御フローメカニズムは、高レベルプログラミング言語に対して標準的なものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first index</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113023Z" creationid="hsugawa8651" creationdate="20181112T113012Z">
        <seg>最初のインデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The floating-point literal expression &lt;x1/&gt;1e10&lt;x2/&gt; could be interpreted as the numeric literal &lt;x3/&gt;1&lt;x4/&gt; multiplied
by the variable &lt;x5/&gt;e10&lt;x6/&gt;, and similarly with the equivalent &lt;x7/&gt;E&lt;x8/&gt; form.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111928Z" creationid="hsugawa8651" creationdate="20181112T111928Z">
        <seg>浮動小数点リテラル式&lt;x1/&gt;1e10&lt;x2/&gt;は、数値リテラル&lt;x3/&gt;1&lt;x4/&gt;を乗算したものと解釈することができます。 変数&lt;x5/&gt;E10&lt;x6/&gt;であり、同様に等価な&lt;x7/&gt;E&lt;x8/&gt;の形式である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following &lt;x1/&gt;arithmetic operators&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131935Z" creationid="hsugawa8651" creationdate="20181113T131935Z">
        <seg>以下の演算子&lt;x1/&gt;演算子&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following &lt;x1/&gt;bitwise operators&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132228Z" creationid="hsugawa8651" creationdate="20181113T132228Z">
        <seg>以下の&lt;x1/&gt;ビット演算子&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following Julia code calls &lt;x1/&gt;dist&lt;x2/&gt; using &lt;x3/&gt;ccall&lt;x4/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151323Z" creationid="hsugawa8651" creationdate="20181117T151323Z">
        <seg>次のJuliaコードは、&lt;x3/&gt;ccall&lt;x4/&gt;を使用して&lt;x1/&gt;dist&lt;x2/&gt;を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are Julia's primitive numeric types:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225110Z" creationid="hsugawa8651" creationdate="20181109T225110Z">
        <seg>Juliaのプリミティブな数値型は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following arguments, if any, are the actual argument values passed to the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224007Z" creationid="hsugawa8651" creationdate="20181109T224007Z">
        <seg>次の引数は、関数に渡された実際の引数の値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example computes a dot product using a BLAS function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151846Z" creationid="hsugawa8651" creationdate="20181117T151846Z">
        <seg>次の例では、BLAS関数を使用してドット製品を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example computes a weighted average of the current element and its left and right
neighbor along a 1-d grid.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154818Z" creationid="hsugawa8651" creationdate="20181109T154818Z">
        <seg>次の例では、現在の要素とその左側と右側の加重平均を計算しています。 1Dグリッドに沿った隣接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example computes a weighted average of the current element and its left and right
neighbor along a 1-d grid. :</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134801Z" creationid="hsugawa8651" creationdate="20181117T134801Z">
        <seg>次の例では、現在の要素とその左側と右側の加重平均を計算しています。 1Dグリッドに沿った隣接するもの:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example computes the QR decomposition of a small section of a larger array, without
creating any temporaries, and by calling the appropriate LAPACK function with the right leading
dimension size and stride parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160522Z" creationid="hsugawa8651" creationdate="20181109T160522Z">
        <seg>次の例は、大きな配列の小さいセクションのQR分解を計算します。 一時的なものを作成すること、そして適切なLAPACK関数を使って適切な関数を呼び出すこと 寸法のサイズと歩幅のパラメータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following examples show the different forms.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031056Z" creationid="hsugawa8651" creationdate="20181114T031056Z">
        <seg>次の例は、さまざまな形式を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following methods and types in &lt;x1/&gt;Base.StackTraces&lt;x2/&gt; are not exported and need to be called e.g.
as &lt;x3/&gt;StackTraces.lookup(ptr)&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064304Z" creationid="hsugawa8651" creationdate="20181114T064304Z">
        <seg>&lt;x1/&gt;ベース.StackTraces&lt;x2/&gt;では、次のメソッドとタイプはエクスポートされず、呼び出される必要があります。 &lt;x3/&gt;StackTraces.lookup(ptr)&lt;x4/&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following methods are described as "unsafe" because a bad pointer or type declaration can
cause Julia to terminate abruptly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152524Z" creationid="hsugawa8651" creationdate="20181117T152524Z">
        <seg>次のメソッドは、不正なポインタまたはタイプ宣言は、「安全でない」と記述されています。 ジュリアが突然終了する原因です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following operators are supported for arrays:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161207Z" creationid="hsugawa8651" creationdate="20181114T161207Z">
        <seg>配列では、次の演算子がサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following two types are equivalent -- one with a default constructor,
the other with an explicit constructor:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155817Z" creationid="hsugawa8651" creationdate="20181117T155817Z">
        <seg>次の2つのタイプは、デフォルトコンストラクタを使用した場合と同じです。 もう一つは明示的なコンストラクタである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following two-word sequences are reserved:
&lt;x1/&gt;abstract type&lt;x2/&gt;, &lt;x3/&gt;mutable struct&lt;x4/&gt;, &lt;x5/&gt;primitive type&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041755Z" creationid="hsugawa8651" creationdate="20181110T041755Z">
        <seg>次の2語のシーケンスが予約されています。 &lt;x1/&gt;抽象型&lt;x2/&gt;,&lt;x3/&gt;mutable構造体&lt;x4/&gt;,&lt;x5/&gt;プリミティブ型&lt;x6/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The garbage collector does not guarantee any order of finalization.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152248Z" creationid="hsugawa8651" creationdate="20181117T152248Z">
        <seg>ガーベジ・コレクターは、最終化の順序を保証しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general &lt;x3/&gt;for&lt;x4/&gt; loop:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042052Z" creationid="hsugawa8651" creationdate="20181110T042052Z">
        <seg>&lt;x4/&gt;ループの一般的な&lt;x3/&gt;は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general syntax for assigning values in an n-dimensional array A is:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155333Z" creationid="hsugawa8651" creationdate="20181109T155333Z">
        <seg>n次元配列Aの値を代入する一般的な構文は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general syntax for indexing into an n-dimensional array A is:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155109Z" creationid="hsugawa8651" creationdate="20181109T155109Z">
        <seg>n次元配列Aへの索引付けの一般的な構文は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hexadecimal integer literal expression &lt;x1/&gt;0xff&lt;x2/&gt; could be interpreted as the numeric literal
&lt;x3/&gt;0&lt;x4/&gt; multiplied by the variable &lt;x5/&gt;xff&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111924Z" creationid="hsugawa8651" creationdate="20181112T111924Z">
        <seg>16進数の整数リテラル式&lt;x1/&gt;0xff&lt;x2/&gt;は、数値リテラルとして解釈することができます。 &lt;x3/&gt;0&lt;x4/&gt;は、変数&lt;x5/&gt;xff&lt;x6/&gt;で乗算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The host machine must have the requisite SIMD registers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151333Z" creationid="hsugawa8651" creationdate="20181117T151333Z">
        <seg>ホストマシンは、必要なSIMDレジスタを持っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The import mechanism allows you to load a package—i.e. an independent, reusable collection of Julia code, wrapped in a module—and makes the resulting module available by the name &lt;x6/&gt;X&lt;x7/&gt; inside of the importing module.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152737Z" creationid="hsugawa8651" creationdate="20181117T152737Z">
        <seg>インポート機構を使用すると、モジュールにラップされたJulia codeの独立した再利用可能なコレクションをロードできます。また、インポートモジュールの内部では、そのモジュールを&lt;x6/&gt;x7/&gt;x&lt;x7/&gt;の名前で使用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The included path, &lt;x14/&gt;source.jl&lt;x15/&gt;, is interpreted relative to the file where the &lt;x16/&gt;include&lt;x17/&gt; call occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152708Z" creationid="hsugawa8651" creationdate="20181117T152708Z">
        <seg>インクルードパス&lt;x14/&gt;ソース.jl&lt;x15/&gt;は、&lt;x16/&gt;が&lt;x17/&gt;コールが発生するファイルに対して相対的に解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The index argument is optional (default
is 1), and follows the Julia-convention of 1-based indexing.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152529Z" creationid="hsugawa8651" creationdate="20181117T152529Z">
        <seg>index引数はオプションです(デフォルトです)。 は1)で、1ベースのインデックス作成のJulia条約に従っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inner constructor method can then use the incomplete
object, finishing its initialization before returning it.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155859Z" creationid="hsugawa8651" creationdate="20181117T155859Z">
        <seg>内部コンストラクタメソッドは、不完全な オブジェクトは初期化を終了してから戻す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The input &lt;x1/&gt;n&lt;x2/&gt; is passed by value, and so the function's input signature is
simply declared as &lt;x3/&gt;(Csize_t,)&lt;x4/&gt; without any &lt;x5/&gt;Ref&lt;x6/&gt; or &lt;x7/&gt;Ptr&lt;x8/&gt; necessary.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152051Z" creationid="hsugawa8651" creationdate="20181117T152051Z">
        <seg>入力&lt;x1/&gt;n&lt;x2/&gt;は値によって渡されるので、関数の入力シグネチャは次のようになります。 &lt;x3/&gt;(Csize_t,)&lt;x4/&gt;は、必要な&lt;x5/&gt;Ref&lt;x6/&gt;&lt;x7/&gt;Ptr&lt;x8/&gt;Ptr&lt;x8/&gt;を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The input types must be written as a literal tuple, not a tuple-valued
variable or expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223955Z" creationid="hsugawa8651" creationdate="20181109T223955Z">
        <seg>入力タイプは、タプルではなく、リテラルタプルとして記述する必要があります。 変数または式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lack of type declarations in most dynamic
languages, however, means that one cannot instruct the compiler about
the types of values, and often cannot explicitly talk about types at
all.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082237Z" creationid="hsugawa8651" creationdate="20181118T082237Z">
        <seg>多くの動的言語における型宣言の欠落は、コンパイラに対して値の型を伝えられない、または型について何ら触れることができないということを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last index, used in &lt;x1/&gt;X[end]&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113029Z" creationid="hsugawa8651" creationdate="20181112T113029Z">
        <seg>最後のインデックスで、&lt;x1/&gt;X[end]&lt;x2/&gt;で使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last point is potentially surprising and thus worth noting:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030511Z" creationid="hsugawa8651" creationdate="20181114T030511Z">
        <seg>最後の点は潜在的に驚くべきものであり、注目すべきことである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The location &lt;x1/&gt;(i_1, i_2, i_3, ..., i_{n+1})&lt;x2/&gt; contains the value at &lt;x3/&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160844Z" creationid="hsugawa8651" creationdate="20181114T160844Z">
        <seg>位置&lt;x1/&gt;(i_1,i_2,i_3,.…i_{n+1})&lt;x2/&gt;は、&lt;x3/&gt;A[I_1[i_1,i_2],I_2[i_3],.…I_n[i_{n+1}]]&lt;x4/&gt;の値を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The location &lt;x1/&gt;(i_1, i_2, i_3, ..., i_{n+1})&lt;x2/&gt; contains the value at &lt;x3/&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;x4/&gt;.
All dimensions indexed with scalars are dropped. For example, the result of &lt;x5/&gt;A[2, I, 3]&lt;x6/&gt; is an
array with size &lt;x7/&gt;size(I)&lt;x8/&gt;. Its &lt;x9/&gt;i&lt;x10/&gt;th element is populated by &lt;x11/&gt;A[2, I[i], 3]&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134838Z" creationid="hsugawa8651" creationdate="20181117T134838Z">
        <seg>位置&lt;x1/&gt;(i_1,i_2,i_3,.…i_{n+1})&lt;x2/&gt;は、&lt;x3/&gt;A[I_1[i_1,i_2],I_2[i_3],.…I_n[i_{n+1}]]&lt;x4/&gt;の値を含む。 スカラーでインデックス付けされたすべての次元は削除されます。たとえば、&lt;x5/&gt;A[2,I,3]&lt;x6/&gt;の結果は size&lt;x7/&gt;サイズ(I)&lt;x8/&gt;の配列。&lt;x9/&gt;i&lt;x10/&gt;th要素は&lt;x11/&gt;A[2,I[I],3]&lt;x12/&gt;で占められる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The machine instructions generated
by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same
as calling a library function from C code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160553Z" creationid="hsugawa8651" creationdate="20181109T160553Z">
        <seg>生成されたマシン命令 JuliaのJITはネイティブのC呼び出しと同じであるため、結果として生じるオーバーヘッドは同じです。 は、Cコードからライブラリ関数を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The machines defined in &lt;c14&gt;&lt;s15&gt;file&lt;/s15&gt;&lt;/c14&gt; must be accessible via a
passwordless &lt;c16&gt;&lt;s17&gt;ssh&lt;/s17&gt;&lt;/c16&gt; login, with Julia installed at the same location as the
current host.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085355Z" creationid="hsugawa8651" creationdate="20181118T084922Z">
        <seg>&lt;c14&gt;&lt;s15&gt;file&lt;/s15&gt;&lt;/c14&gt; で定義されたマシンは、パスワード無しで &lt;c16&gt;&lt;s17&gt;ssh&lt;/s17&gt;&lt;/c16&gt;s17 アクセスでき、現在のホストと同じ場所にJuliaがインストールされている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The machines defined in &lt;x6/&gt;file&lt;x7/&gt; must be accessible via a password-less
&lt;x8/&gt;ssh&lt;x9/&gt; login, with Julia installed at the same location as the current host.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092400Z" creationid="hsugawa8651" creationdate="20181109T224421Z">
        <seg>&lt;x6/&gt;file&lt;x7/&gt; で定義されたマシンは、パスワード無しで &lt;x8&gt;ssh&lt;x9/&gt; アクセスでき、現在のホストと同じ場所にJuliaがインストールされている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The macro &lt;x1/&gt;`@cfunction`&lt;x2/&gt; generates the C-compatible function pointer for a call to a
Julia function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153931Z" creationid="hsugawa8651" creationdate="20181109T153931Z">
        <seg>マクロ&lt;x1/&gt;`@cfunction`&lt;x2/&gt;は、コールのC互換関数ポインタを生成します。 Julia関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The macro &lt;x1/&gt;`@cfunction`&lt;x2/&gt; generates the C-compatible function pointer for a call to a
Julia function. Arguments to &lt;x3/&gt;`@cfunction`&lt;x4/&gt; are as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133859Z" creationid="hsugawa8651" creationdate="20181117T133859Z">
        <seg>マクロ&lt;x1/&gt;`@cfunction`&lt;x2/&gt;は、コールのC互換関数ポインタを生成します。 Julia関数。&lt;x3/&gt;`@cfunction`&lt;x4/&gt;への引数は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152921Z" creationid="hsugawa8651" creationdate="20181117T152921Z">
        <seg>マニフェスト・ファイルが存在する場合、すべての依存関係、依存関係の正確なバージョン、適切なバージョンを検索してロードするための十分な情報など、すべての依存関係を含む完全な依存関係グラフが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The matrix adds a dimension.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160902Z" creationid="hsugawa8651" creationdate="20181114T160902Z">
        <seg>マトリックスは寸法を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of &lt;x9/&gt;X&lt;x10/&gt; in &lt;x11/&gt;import X&lt;x12/&gt; is context-dependent: which &lt;x13/&gt;X&lt;x14/&gt; package is loaded depends on what code the statement occurs in.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152810Z" creationid="hsugawa8651" creationdate="20181117T152810Z">
        <seg>&lt;x11/&gt;インポートX&lt;x12/&gt;における&lt;x9/&gt;x10/&gt;の意味はコンテキスト依存であり、&lt;x13/&gt;X&lt;x14/&gt;パッケージは、文がどのコードによって生成されるかによって異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of prefix &lt;x1/&gt;&amp;&lt;x2/&gt; is not quite the same as in C. In particular, any changes to the referenced
variables will not be visible in Julia unless the type is mutable (declared via &lt;x3/&gt;mutable struct&lt;x4/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151853Z" creationid="hsugawa8651" creationdate="20181117T151853Z">
        <seg>プレフィックス&lt;x1/&gt;&amp;&lt;x2/&gt;の意味は、Cとまったく同じではありません。特に、参照されているものの変更はありません。 変数は、そのタイプがmutable(&lt;x3/&gt;mutable構造体&lt;x4/&gt;によって宣言されている)でない限り、Juliaでは表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of this form is that &lt;x1/&gt;F(x,y,...)&lt;x2/&gt; is evaluated with the variables &lt;x3/&gt;x&lt;x4/&gt;, &lt;x5/&gt;y&lt;x6/&gt;, etc. taking
on each value in their given list of values.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154807Z" creationid="hsugawa8651" creationdate="20181109T154807Z">
        <seg>この形式の意味は、&lt;x1/&gt;F(x,y,...)&lt;x2/&gt;は、変数&lt;x3/&gt;x4&lt;x4/&gt;、&lt;x5/&gt;y&lt;x6/&gt;の変数を用いて評価されることである。 指定された値リストの各値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of this form is that &lt;x1/&gt;F(x,y,...)&lt;x2/&gt; is evaluated with the variables &lt;x3/&gt;x&lt;x4/&gt;, &lt;x5/&gt;y&lt;x6/&gt;, etc. taking
on each value in their given list of values. Values can be specified as any iterable object, but
will commonly be ranges like &lt;x7/&gt;1:n&lt;x8/&gt; or &lt;x9/&gt;2:(n-1)&lt;x10/&gt;, or explicit arrays of values like &lt;x11/&gt;[1.2, 3.4, 5.7]&lt;x12/&gt;.
The result is an N-d dense array with dimensions that are the concatenation of the dimensions
of the variable ranges &lt;x13/&gt;rx&lt;x14/&gt;, &lt;x15/&gt;ry&lt;x16/&gt;, etc. and each &lt;x17/&gt;F(x,y,...)&lt;x18/&gt; evaluation returns a scalar.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134758Z" creationid="hsugawa8651" creationdate="20181117T134758Z">
        <seg>この形式の意味は、&lt;x1/&gt;F(x,y,...)&lt;x2/&gt;は、変数&lt;x3/&gt;x4&lt;x4/&gt;、&lt;x5/&gt;y&lt;x6/&gt;の変数を用いて評価されることである。 指定された値リストの各値を指定します。値は、任意のオブジェクトとして指定することができますが は一般的に&lt;x7/&gt;1:n&lt;x8/&gt;または&lt;x9/&gt;2:(n-1)&lt;x10/&gt;、または&lt;x11/&gt;[1.2、3.4、5.7]&lt;x12/&gt;のような明示的な値の配列である。 結果は、次元の連結である次元を持つN次元の密配列です。 変数範囲&lt;x13/&gt;rx&lt;x14/&gt;、&lt;x15/&gt;ry&lt;x16/&gt;など、各&lt;x17/&gt;F(x,y,...)&lt;x18/&gt;評価はスカラーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism by which Julia picks default sorting algorithms is implemented via the &lt;x1/&gt;Base.Sort.defalg&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064226Z" creationid="hsugawa8651" creationdate="20181114T064226Z">
        <seg>Juliaがデフォルトのソートアルゴリズムを選択するメカニズムは、&lt;x1/&gt;Base.Sort.デフォルグ&lt;x2/&gt;を介して実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memory is managed by Julia and the &lt;x2/&gt;Ref&lt;x3/&gt; signature alerts Julia's
garbage collector to keep managing the memory for &lt;x4/&gt;result_array&lt;x5/&gt; while the &lt;x6/&gt;`ccall`&lt;x7/&gt; executes.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152212Z" creationid="hsugawa8651" creationdate="20181117T152212Z">
        <seg>メモリはJuliaによって管理され、&lt;x2/&gt;Ref&lt;x3/&gt;&lt;x3/&gt;のシグニチャアラートが表示されます。 &lt;x6/&gt;のccall&lt;x7/&gt;が実行されている間に、&lt;x4/&gt;result_array&lt;x5/&gt;のメモリを管理するためのガーベッジ・コレクタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memory will be released the next time the garbage collector runs; you can force
this to happen with &lt;x5/&gt;&lt;x6/&gt;&lt;x7/&gt;(@ref Base.GC.gc).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024659Z" creationid="hsugawa8651" creationdate="20181110T024659Z">
        <seg>次にガーベッジ・コレクターが実行されるとメモリーが解放され、次のように強制的に実行されます。 これは&lt;x5/&gt;&lt;x6/&gt;&lt;x7/&gt;(@ref Base.GC.gc)で起こる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The middle expression is only evaluated once, rather than twice as it would be if the expression
were written as &lt;x1/&gt;v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030745Z" creationid="hsugawa8651" creationdate="20181114T030745Z">
        <seg>中間表現は、式が1回だけ評価されるのではなく、1回だけ評価されます。 &lt;x1/&gt;v(1)&lt;v(2)&amp;v(2)&lt;=v(3)&lt;x2/&gt;と記述されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most significant departures of Julia from typical dynamic languages
are:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081945Z" creationid="hsugawa8651" creationdate="20181118T081945Z">
        <seg>一般の動的言語と比べてJuliaが特に優れている点としては以下のようなものが挙げられます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152318Z" creationid="hsugawa8651" creationdate="20181117T152318Z">
        <seg>次のセクションでは、間接呼び出しを使用して同様の効果を効率的に達成する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next two steps (selecting the output array and implementation) are dependent upon
determining a single answer for a given set of arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131106Z" creationid="hsugawa8651" creationdate="20181113T131106Z">
        <seg>次の2つのステップ(出力配列と実装を選択)は、次のように依存します。 指定された引数の集合に対する単一の応答を決定することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notation &lt;x1/&gt;T(x)&lt;x2/&gt; or &lt;x3/&gt;convert(T,x)&lt;x4/&gt; converts &lt;x5/&gt;x&lt;x6/&gt; to a value of type &lt;x7/&gt;T&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031031Z" creationid="hsugawa8651" creationdate="20181114T031031Z">
        <seg>&lt;x1/&gt;T(x)&lt;x2/&gt;または&lt;x3/&gt;変換(T,x)&lt;x4/&gt;は、&lt;x5/&gt;x&lt;x6/&gt;を&lt;x7/&gt;T&lt;x8/&gt;型の値に変換する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of items in each dimension, if known</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094113Z" creationid="hsugawa8651" creationdate="20181118T094113Z">
        <seg>各次元のアイテム数(既知の場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of items, if known</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112228Z" creationid="hsugawa8651" creationdate="20181112T112228Z">
        <seg>品目数(既知の場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only solution is to allow creating an incompletely initialized instance
of &lt;x3/&gt;SelfReferential&lt;x4/&gt; with an unassigned &lt;x5/&gt;obj&lt;x6/&gt; field, and using that incomplete instance as a valid
value for the &lt;x7/&gt;obj&lt;x8/&gt; field of another instance, such as, for example, itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155854Z" creationid="hsugawa8651" creationdate="20181117T155854Z">
        <seg>唯一の解決策は、不完全に初期化されたインスタンスを作成することです。 &lt;x3/&gt;SelfReferential&lt;x4/&gt;のうち、未割り当ての&lt;x6/&gt;obj&lt;x6/&gt;&lt;x6/&gt;フィールドを指定し、その不完全なインスタンスを有効にして使用します。 他のインスタンスの&lt;x7/&gt;obj&lt;x8/&gt;フィールドの値(例えば、それ自体)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;c27&gt;&lt;s28&gt;bind-to&lt;/s28&gt; &lt;s29&gt;bind_addr[:port]&lt;/s29&gt;&lt;/c27&gt;
specifies the ip-address and port that other workers should use to
connect to this worker.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085144Z" creationid="hsugawa8651" creationdate="20181118T085022Z">
        <seg>&lt;c27&gt;&lt;s28&gt;bind-to&lt;/s28&gt; &lt;s29&gt;bind_addr[:port]&lt;/s29&gt;&lt;/c27&gt; オプションを指定すると、他のワーカーがそのワーカーと接続する際に使うIPアドレスとポートを設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;x18/&gt;bind-to bind_addr[:port]&lt;x19/&gt; specifies the IP address and port that other workers
should use to connect to this worker.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092621Z" creationid="hsugawa8651" creationdate="20181109T224449Z">
        <seg>&lt;x18/&gt;bind-to bind_addr[:port]&lt;x19/&gt; オプションを指定すると、他のワーカーがそのワーカーと接続する際に使うIPアドレスとポートを設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original three-way
example requires chaining multiple uses of the ternary operator together:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230140Z" creationid="hsugawa8651" creationdate="20181109T230140Z">
        <seg>オリジナルの3ウェイ 例では、三元演算子の複数の使用を一緒に連鎖する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence of numeric literal coefficients is slightly lower than that of
unary operators such as negation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111745Z" creationid="hsugawa8651" creationdate="20181112T111745Z">
        <seg>数値リテラル係数の優先順位は、次の値よりもわずかに低くなります。 否定のような単項演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence rules are defined by binary &lt;x1/&gt;BroadcastStyle&lt;x2/&gt; calls:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131737Z" creationid="hsugawa8651" creationdate="20181113T131737Z">
        <seg>優先順位ルールは、バイナリ&lt;x1/&gt;BroadcastStyle&lt;x2/&gt;コールによって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The project file determines what the names and identities of the direct dependencies of a project are.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152919Z" creationid="hsugawa8651" creationdate="20181117T152919Z">
        <seg>プロジェクトファイルは、プロジェクトの直接的な依存関係の名前と識別情報を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The question &lt;x3/&gt;"what is `X`?"&lt;x4/&gt; is answered by determining the UUID of &lt;x5/&gt;X&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152844Z" creationid="hsugawa8651" creationdate="20181117T152844Z">
        <seg>&lt;x3/&gt;"what is"X"と"は、&lt;x5/&gt;X&lt;x6/&gt;のUUIDを決定することによって答えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reasoning is that &lt;x1/&gt;a &amp;&amp; b&lt;x2/&gt; must be &lt;x3/&gt;false&lt;x4/&gt; if &lt;x5/&gt;a&lt;x6/&gt; is &lt;x7/&gt;false&lt;x8/&gt;, regardless of the value of
&lt;x9/&gt;b&lt;x10/&gt;, and likewise, the value of &lt;x11/&gt;a || b&lt;x12/&gt; must be true if &lt;x13/&gt;a&lt;x14/&gt; is &lt;x15/&gt;true&lt;x16/&gt;, regardless of the value
of &lt;x17/&gt;b&lt;x18/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230241Z" creationid="hsugawa8651" creationdate="20181109T230241Z">
        <seg>&lt;x1/&gt;a&amp;b&lt;x2/&gt;は、&lt;x5/&gt;&lt;x6/&gt;が&lt;x7/&gt;であれば&lt;x4/&gt;でなければならない。 &lt;x9/&gt;b&lt;x10/&gt;は、&lt;x13/&gt;a&lt;x12/&gt;が&lt;x15/&gt;真&lt;x16/&gt;である場合、値に関係なく真でなければなりません。&lt;x13/&gt;&lt;x16/&gt; &lt;x17/&gt;b&lt;x18/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The recommended ways to iterate over a whole array are</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161138Z" creationid="hsugawa8651" creationdate="20181114T161138Z">
        <seg>配列全体を繰り返し処理するには、次のような方法が推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The referenced memory can safely be freed or released.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152535Z" creationid="hsugawa8651" creationdate="20181117T152535Z">
        <seg>参照メモリは、安全に解放されたり解放されたりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remainder and modulus functions (&lt;x7/&gt;rem&lt;x8/&gt; and &lt;x9/&gt;mod&lt;x10/&gt;) throw a &lt;x11/&gt;`DivideError`&lt;x12/&gt; when their
second argument is zero.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110536Z" creationid="hsugawa8651" creationdate="20181112T110536Z">
        <seg>残りと弾性関数(&lt;x7/&gt;rem&lt;x8/&gt;および&lt;x9/&gt;mod&lt;x10/&gt;)は、それらの関数を用いた場合、&lt;x11/&gt;'DivideError&lt;x12/&gt;をスローする。 2番目の引数は0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result
of &lt;x4/&gt;`view`&lt;x5/&gt; looks the same as the result of &lt;x6/&gt;`getindex`&lt;x7/&gt;, except the
data is left in place.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160436Z" creationid="hsugawa8651" creationdate="20181109T160436Z">
        <seg>結果 &lt;x4/&gt;'view'&lt;x5/&gt;は、&lt;x6/&gt;'getindex'&lt;x7/&gt;の結果と同じであるが データが残されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a pointer giving the address of the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152516Z" creationid="hsugawa8651" creationdate="20181117T152516Z">
        <seg>その結果、値のアドレスを示すポインタが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is an N-d dense array with dimensions that are the concatenation of the dimensions
of the variable ranges &lt;x13/&gt;rx&lt;x14/&gt;, &lt;x15/&gt;ry&lt;x16/&gt;, etc. and each &lt;x17/&gt;F(x,y,...)&lt;x18/&gt; evaluation returns a scalar.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154815Z" creationid="hsugawa8651" creationdate="20181109T154815Z">
        <seg>結果は、次元の連結である次元を持つN次元の密配列です。 変数範囲&lt;x13/&gt;rx&lt;x14/&gt;、&lt;x15/&gt;ry&lt;x16/&gt;など、各&lt;x17/&gt;F(x,y,...)&lt;x18/&gt;評価はスカラーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of indexing an &lt;x1/&gt;AbstractArray&lt;x2/&gt; can itself be an array (for instance when indexing by
an &lt;x3/&gt;AbstractRange&lt;x4/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083307Z" creationid="hsugawa8651" creationdate="20181113T083307Z">
        <seg>&lt;x1/&gt;AbstractArray&lt;x2/&gt;のインデックス作成の結果は、それ自体が配列(例えば、インデックス作成の際に)であることができます。 &lt;x3/&gt;AbstractRange&lt;x4/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting array type depends on the types of the computed elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150425Z" creationid="hsugawa8651" creationdate="20181117T150425Z">
        <seg>結果として得られる配列タイプは、計算された要素の種類によって異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting array type depends on the types of the computed elements. In order to control the
type explicitly, a type can be prepended to the comprehension. For example, we could have requested
the result in single precision by writing:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134806Z" creationid="hsugawa8651" creationdate="20181117T134806Z">
        <seg>結果の配列タイプは、計算された要素のタイプに依存します。 明示的にタイプを指定することができます。たとえば、次のように入力することができます。 以下のように記述することによって、単精度での結果が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type of the &lt;x4/&gt;`ccall`&lt;x5/&gt; is declared as &lt;x6/&gt;Ptr{gsl_permutation}&lt;x7/&gt;, since
the memory allocated and pointed to by &lt;x8/&gt;output_ptr&lt;x9/&gt; is controlled by C (and not Julia).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152048Z" creationid="hsugawa8651" creationdate="20181117T152048Z">
        <seg>&lt;x4/&gt;'ccall'&lt;x5/&gt;の戻り型は、&lt;x6/&gt;Ptr{gsl_mutation}&lt;x7/&gt;として宣言されている。 &lt;x8/&gt;出力ptr&lt;x9/&gt;によって割り当てられ、指示されたメモリーは、C(およびジュリアではない)によって制御されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type should either be &lt;x3/&gt;Cvoid&lt;x4/&gt; for
Fortran subroutines, or a &lt;x5/&gt;T&lt;x6/&gt; for Fortran functions returning the type &lt;x7/&gt;T&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151455Z" creationid="hsugawa8651" creationdate="20181117T151455Z">
        <seg>戻り値のタイプは、&lt;x3/&gt;Cvoid&lt;x4/&gt;である必要があります。 Fortranのサブルーチン、または&lt;x8/&gt;T&lt;x6/&gt;のFortran関数では、&lt;x7/&gt;T&lt;x8/&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value from iterate
is always either a tuple of a value and a state, or &lt;x3/&gt;nothing&lt;x4/&gt; if no elements remain.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112400Z" creationid="hsugawa8651" creationdate="20181112T112400Z">
        <seg>反復からの戻り値 は常に値と状態のタプルであるか、あるいは&lt;x3/&gt;何もない場合は&lt;x3/&gt;何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value will be a new object initialized to contain a copy of the contents of the referenced
memory.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152533Z" creationid="hsugawa8651" creationdate="20181117T152533Z">
        <seg>戻り値は、参照される内容のコピーを含むように初期化された新しいオブジェクトになります。 メモリー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reverse (passing an object
allocated in Julia to be freed by an external library) is equally invalid.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151434Z" creationid="hsugawa8651" creationdate="20181117T151434Z">
        <seg>逆(オブジェクトを渡すこと) 外部ライブラリによって解放されるためにJuliaに割り当てられていることは、同じように無効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reverse operation (writing data to a &lt;x1/&gt;Ptr{T}&lt;x2/&gt;), can be performed using &lt;x3/&gt;`unsafe_store!(ptr, value, [index])`&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152559Z" creationid="hsugawa8651" creationdate="20181117T152559Z">
        <seg>逆の操作(&lt;x1/&gt;Ptr{T}&lt;x2/&gt;への書き込み)は、&lt;x3/&gt;"unsafe_store!(ptr,value,[index])`&lt;x4/&gt;を使って実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same holds for &lt;x8/&gt;`setindex!`&lt;x9/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083157Z" creationid="hsugawa8651" creationdate="20181113T083157Z">
        <seg>同じことが&lt;x8/&gt;`setindex!`&lt;x9/&gt;に対しても当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same relationship holds for &lt;x8/&gt;min.(a,b)&lt;x9/&gt; and &lt;x10/&gt;minimum(a)&lt;x11/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160036Z" creationid="hsugawa8651" creationdate="20181109T160036Z">
        <seg>&lt;x8/&gt;min(a,b)&lt;x9/&gt;と&lt;x10/&gt;最小(a)&lt;x11/&gt;と同じ関係が成り立つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second and third arguments are both optional, defaulting to the element type and dimensions of &lt;x3/&gt;A&lt;x4/&gt; if omitted.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154442Z" creationid="hsugawa8651" creationdate="20181109T154442Z">
        <seg>2番目と3番目の引数は両方とも省略可能です。デフォルトでは、&lt;x3/&gt;A&lt;x4/&gt;&lt;x/&gt;の要素タイプと次元は省略されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second argument to &lt;x1/&gt;`ccall`&lt;x2/&gt; can optionally be a calling convention specifier (immediately
preceding return type).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152426Z" creationid="hsugawa8651" creationdate="20181117T152426Z">
        <seg>&lt;x1/&gt;`ccall'&lt;x2/&gt;への2番目の引数は、オプションとして、呼び出し規約指定子(即時に)とすることができます。 先行する戻り値のタイプ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The short function syntax is accordingly quite idiomatic, considerably reducing
both typing and visual noise.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025621Z" creationid="hsugawa8651" creationdate="20181110T025621Z">
        <seg>したがって、短い関数構文は非常に奇妙なものになり、大幅に減少します。 タイプとビジュアルノイズの両方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The size
of the binary data item is the minimal needed size, if the leading digit of the literal is not
&lt;x1/&gt;0&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225415Z" creationid="hsugawa8651" creationdate="20181109T225415Z">
        <seg>サイズ リテラルの先頭桁が必要ない場合は、バイナリ・データ項目の最小サイズが2進数データ項目となります。 &lt;x1/&gt;0&lt;x2/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The size of the unsigned value is
determined by the number of hex digits used:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110409Z" creationid="hsugawa8651" creationdate="20181112T110409Z">
        <seg>符号なし値のサイズは 使用される16進数の数によって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The so-called "ternary operator", &lt;x1/&gt;?:&lt;x2/&gt;, is closely related to the &lt;x3/&gt;if&lt;x4/&gt;-&lt;x5/&gt;elseif&lt;x6/&gt;-&lt;x7/&gt;else&lt;x8/&gt; syntax,
but is used where a conditional choice between single expression values is required, as opposed
to conditional execution of longer blocks of code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230045Z" creationid="hsugawa8651" creationdate="20181109T230045Z">
        <seg>いわゆる「三元演算子」&lt;x1/&gt;?&lt;x2/&gt;は、&lt;x4/&gt;-&lt;x5/&gt;elseif&lt;x6/&gt;-&lt;x7/&gt;else&lt;x8/&gt;の場合、&lt;x4/&gt;と密接に関係している。 しかし、単一の表現値間の条件付き選択が必要とされる場合に使用されます。 より長いブロックを条件付きで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special &lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt; object represents a scalar index that behaves
like an &lt;x3/&gt;N&lt;x4/&gt;-tuple of integers spanning multiple dimensions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160948Z" creationid="hsugawa8651" creationdate="20181114T160948Z">
        <seg>特殊な&lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt;オブジェクトは、スカラーインデックスを表します。 &lt;x3/&gt;N&lt;x4/&gt;のように、複数の次元にまたがる整数の&lt;x/&gt;N&lt;x4/&gt;のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special &lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt; object represents a scalar index that behaves
like an &lt;x3/&gt;N&lt;x4/&gt;-tuple of integers spanning multiple dimensions.  For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135016Z" creationid="hsugawa8651" creationdate="20181117T135016Z">
        <seg>特殊な&lt;x1/&gt;CartesianIndex{N}&lt;x2/&gt;オブジェクトは、スカラーインデックスを表します。 たとえば、複数の次元にまたがる整数の&lt;x3/&gt;N&lt;x4/&gt;-タプルのようになります。次に例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stability
property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify
your preferred algorithm, e.g. &lt;x2/&gt;sort!(v, alg=QuickSort)&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064159Z" creationid="hsugawa8651" creationdate="20181114T064159Z">
        <seg>安定性 プロパティーは無視できないコストで発生するため、必要がない場合は、明示的に指定する必要があります。 たとえば、&lt;x2/&gt;ソート!(v,alg=QuickSort)&lt;x3/&gt;のような優先アルゴリズムを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state object will be passed back to the iterate function on the next iteration
and is generally considered an implementation detail private to the iterable object.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112403Z" creationid="hsugawa8651" creationdate="20181112T112403Z">
        <seg>状態オブジェクトは、次の反復の繰り返し関数に渡されます。 一般的には、iterableオブジェクトに対してプライベートな実装の詳細と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The static parameters of the function may be used as type parameters in the call signature,
as long as they don't affect the layout of the type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151235Z" creationid="hsugawa8651" creationdate="20181117T151235Z">
        <seg>関数の静的パラメータは、呼び出しシグネチャのタイプパラメータとして使用できます。 タイプのレイアウトに影響を与えない限りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax &lt;x1/&gt;[A, B, C, ...]&lt;x2/&gt; constructs a 1-d array (i.e., a vector) of its arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154518Z" creationid="hsugawa8651" creationdate="20181109T154518Z">
        <seg>構文&lt;x1/&gt;[A,B,C,…]&lt;x2/&gt;は、その引数の1次元配列(すなわち、ベクトル)を構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax &lt;x1/&gt;[A, B, C, ...]&lt;x2/&gt; constructs a 1-d array (i.e., a vector) of its arguments. If all
arguments have a common &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref conversion-and-promotion) then they get
converted to that type using &lt;x6/&gt;`convert`&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134526Z" creationid="hsugawa8651" creationdate="20181117T134526Z">
        <seg>構文&lt;x1/&gt;[A,B,C,.]&lt;x2/&gt;は、引数の1d配列(ベクトル)を構成します。すべての引数を指定します。 引数には共通の&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref変換とプロモーション)があります。 &lt;x6/&gt;'convert`&lt;x7/&gt;を使用して、そのタイプに変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The traditional function
declaration syntax demonstrated above is equivalent to the following compact "assignment form":</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025506Z" creationid="hsugawa8651" creationdate="20181110T025506Z">
        <seg>従来の機能 上記の宣言構文は、次のコンパクトな「割り当てフォーム」に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tuple must be the same size as the SIMD type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151257Z" creationid="hsugawa8651" creationdate="20181117T151257Z">
        <seg>タプルはSIMD型と同じサイズである必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two uses of the &lt;x1/&gt;...&lt;x2/&gt; operator: slurping and splatting</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025224Z" creationid="hsugawa8651" creationdate="20181110T025224Z">
        <seg>&lt;x1/&gt;.…&lt;x2/&gt;演算子の2つの用途:slingingとspliting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type arguments to &lt;x1/&gt;ccall&lt;x2/&gt; and &lt;x3/&gt;@cfunction&lt;x4/&gt; are evaluated statically,
when the method containing the usage is defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151222Z" creationid="hsugawa8651" creationdate="20181117T151222Z">
        <seg>&lt;x1/&gt;ccall&lt;x2/&gt;および&lt;x3/&gt;@cfunction&lt;x4/&gt;のタイプ引数は静的に評価されます。 使用されているメソッドが定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type is defined as:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063642Z" creationid="hsugawa8651" creationdate="20181114T063642Z">
        <seg>タイプは次のように定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the first entry of the tuple returned by &lt;x1/&gt;iterate()&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112213Z" creationid="hsugawa8651" creationdate="20181112T112213Z">
        <seg>&lt;x1/&gt;によって返されるタプルの最初のエントリのタイプは()&lt;x2/&gt;で返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type parameters of a leaf type must be fully defined (no &lt;x1/&gt;TypeVars&lt;x2/&gt; are allowed) in order for the instance to be constructed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150621Z" creationid="hsugawa8651" creationdate="20181117T150621Z">
        <seg>インスタンスを構築するには、リーフタイプのタイプパラメータを完全に定義する必要があります(&lt;x1/&gt;TypeVars&lt;x2/&gt;は許可されません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type system is described in &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-types) and defining a function
in terms of methods chosen by multiple dispatch on run-time argument types is described in &lt;x4/&gt;Methods&lt;x5/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T105942Z" creationid="hsugawa8651" creationdate="20181112T105939Z">
        <seg>タイプシステムは&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref manタイプ)で記述され、関数を定義します。 ランタイム引数の種類に対する複数のディスパッチによって選択されるメソッドについては、&lt;x4/&gt;メソッド&lt;x5/&gt;で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unary variant states
that you intend to implement specific broadcasting behavior and/or output type, and do not wish to
rely on the default fallback &lt;x2/&gt;`Broadcast.DefaultArrayStyle`&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131129Z" creationid="hsugawa8651" creationdate="20181113T131129Z">
        <seg>単項変異体の状態 特定のブロードキャスト動作や出力タイプを実装することを意図しており デフォルトのフォールバック&lt;x2/&gt;`ブロードキャスト.DefaultArrayStyle'&lt;x3/&gt;に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underscore &lt;x1/&gt;_&lt;x2/&gt; can be used as digit separator:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093626Z" creationid="hsugawa8651" creationdate="20181118T093626Z">
        <seg>アンダースコア&lt;x1/&gt;_&lt;x2/&gt;は、桁区切り記号として使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The updating version of the binary operator is formed
by placing a &lt;x1/&gt;=&lt;x2/&gt; immediately after the operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132348Z" creationid="hsugawa8651" creationdate="20181113T132348Z">
        <seg>バイナリ演算子の更新バージョンが形成されます。 演算子の直後に&lt;x1/&gt;=&lt;x2/&gt;を配置します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The updating versions of all the binary arithmetic and bitwise operators are:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132411Z" creationid="hsugawa8651" creationdate="20181113T132411Z">
        <seg>すべてのバイナリ算術演算子とビット演算子の更新バージョンは次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value can be manipulated through
this pointer using &lt;x1/&gt;`unsafe_load`&lt;x2/&gt; and &lt;x3/&gt;`unsafe_store!`&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152518Z" creationid="hsugawa8651" creationdate="20181117T152518Z">
        <seg>この値は、以下のように操作して操作することができます。 このポインタは、&lt;x1/&gt;`unsafe_load'&lt;x2/&gt;と、&lt;x3/&gt;"unsafe_store!"&lt;x4/&gt;を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value in location &lt;x5/&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155412Z" creationid="hsugawa8651" creationdate="20181109T155412Z">
        <seg>location&lt;x5/&gt;I_1[i_1]の値、I_2[i_2]、.…、I_n[i_n]&lt;x6/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of both compound expression constructs
is that of the last subexpression.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225759Z" creationid="hsugawa8651" creationdate="20181109T225759Z">
        <seg>複合式の両方の構成要素の値 は最後のサブ式のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned by a function is the value of the last expression evaluated, which, by default,
is the last expression in the body of the function definition.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025723Z" creationid="hsugawa8651" creationdate="20181110T025723Z">
        <seg>関数によって返される値は、評価された最後の式の値です。これは、デフォルトでは次の値です。 は、関数定義の本文で最後の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values returned by &lt;x1/&gt;`typemin`&lt;x2/&gt; and &lt;x3/&gt;`typemax`&lt;x4/&gt; are always of the given argument
type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225538Z" creationid="hsugawa8651" creationdate="20181109T225538Z">
        <seg>The values returned by &lt;x1/&gt;`typemin`&lt;x2/&gt; and &lt;x3/&gt;`typemax`&lt;x4/&gt; are always of the given argument
type.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable
&lt;c12&gt;&lt;s13&gt;ans&lt;/s13&gt;&lt;/c12&gt; is bound to the value of the last evaluated expression whether
it is shown or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084224Z" creationid="hsugawa8651" creationdate="20181118T083955Z">
        <seg>&lt;c12&gt;&lt;s13&gt;ans&lt;/s13&gt;&lt;/c12&gt; という変数は、最後に評価された式の値（それが表示されたか否かに関わらず）に束縛されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable &lt;x1/&gt;Sys.KERNEL&lt;x2/&gt; can be used to handle such
cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093240Z" creationid="hsugawa8651" creationdate="20181109T224825Z">
        <seg>変数&lt;x1/&gt;Sys.KERNEL&lt;x2/&gt;は、そのような場合を扱うために使用することができます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable &lt;x1/&gt;relation&lt;x2/&gt; is declared inside the &lt;x3/&gt;if&lt;x4/&gt; block, but used outside.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225941Z" creationid="hsugawa8651" creationdate="20181109T225941Z">
        <seg>The variable &lt;x1/&gt;relation&lt;x2/&gt; is declared inside the &lt;x3/&gt;if&lt;x4/&gt; block, but used outside.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable &lt;x13/&gt;ans&lt;x14/&gt; is bound to the
value of the last evaluated expression whether it is shown or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091528Z" creationid="hsugawa8651" creationdate="20181114T031359Z">
        <seg>&lt;x13/&gt;ans&lt;x14/&gt; という変数は、最後に評価された式の値（それが表示されたか否かに関わらず）に束縛されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, for each MIME type (&lt;x5/&gt;mime&lt;x6/&gt; string) that can be displayed on &lt;x7/&gt;D&lt;x8/&gt;, one should
define a function &lt;x9/&gt;display(d::D, ::MIME"mime", x) = ...&lt;x10/&gt; that displays &lt;x11/&gt;x&lt;x12/&gt; as that MIME type,
usually by calling &lt;x13/&gt;`show(io, mime, x)`&lt;x14/&gt; or &lt;x15/&gt;`repr(io, mime, x)`&lt;x16/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043318Z" creationid="hsugawa8651" creationdate="20181112T043318Z">
        <seg>次に、&lt;x7/&gt;D&lt;x8/&gt;上に表示できるMIMEタイプ(&lt;x5/&gt;mime&lt;x6/&gt;ストリング)ごとに、次のいずれかを実行する必要があります。 関数&lt;x9/&gt;ディスプレイ(d::D,:MIME"mime",x)=&lt;x10/&gt;x12/&gt;を定義します。&lt;x11/&gt;x12/&gt;は、MIMEタイプとして&lt;x11/&gt;x&lt;x12/&gt;を表示します。 通常は、&lt;x13/&gt;`show(io,mime,x)`&lt;x14/&gt;または&lt;x15/&gt;`repr(io,mime,x)`&lt;x16/&gt;を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are
many other operations that will simply corrupt the runtime system without notification, usually
in subtle ways not obviously connected to the bad definition.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032219Z" creationid="hsugawa8651" creationdate="20181116T032219Z">
        <seg>その他 通知なしでランタイム・システムを単純に破壊する他の多くの操作 明らかに悪い定義とは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few more methods we can extend to give Julia more information about this iterable
collection.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112544Z" creationid="hsugawa8651" creationdate="20181112T112527Z">
        <seg>その他にも、Juliaにこの問題に関する情報を提供する方法がいくつかある。 のリストを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are currently four sorting algorithms available in base Julia:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064002Z" creationid="hsugawa8651" creationdate="20181114T064002Z">
        <seg>現在、基本的なJuliaには4つのソートアルゴリズムが用意されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several functions in the &lt;x3/&gt;Sys&lt;x4/&gt; module intended to make this easier:
&lt;x5/&gt;isunix&lt;x6/&gt;, &lt;x7/&gt;islinux&lt;x8/&gt;, &lt;x9/&gt;isapple&lt;x10/&gt;, &lt;x11/&gt;isbsd&lt;x12/&gt;, and &lt;x13/&gt;iswindows&lt;x14/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093424Z" creationid="hsugawa8651" creationdate="20181109T224828Z">
        <seg>&lt;x3/&gt;Sys&lt;x4/&gt;モジュールには、これをより容易にすることを目的とした、いくつかの関数があります。&lt;x5/&gt;isunix&lt;x6/&gt;, &lt;x7/&gt;islinux&lt;x8/&gt;, &lt;x9/&gt;isapple&lt;x10/&gt;, &lt;x11/&gt;isbsd&lt;x12/&gt;, and &lt;x13/&gt;iswindows&lt;x14/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several special types to be aware of, as no other type can be defined to behave the
same:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134404Z" creationid="hsugawa8651" creationdate="20181117T134404Z">
        <seg>他のタイプが定義されていないため、以下のように注意すべき特殊なタイプがいくつかあります。 同じ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two Julia constructs
that accomplish this: &lt;x1/&gt;begin&lt;x2/&gt; blocks and &lt;x3/&gt;(;)&lt;x4/&gt; chains.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225757Z" creationid="hsugawa8651" creationdate="20181109T225757Z">
        <seg>ジュリアの構成が2あります これは、&lt;x1/&gt;が&lt;x2/&gt;ブロックと&lt;x3/&gt;(;)&lt;x4/&gt;鎖を形成することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two constructs for repeated evaluation of expressions: the &lt;x1/&gt;while&lt;x2/&gt; loop and the &lt;x3/&gt;for&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230950Z" creationid="hsugawa8651" creationdate="20181109T230950Z">
        <seg>反復評価には2つの構成があります。&lt;x1/&gt;while&lt;x2/&gt;loop and the&lt;x3/&gt;for&lt;x4/&gt;&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two main
ways of doing so:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131717Z" creationid="hsugawa8651" creationdate="20181113T131717Z">
        <seg>主に2つの その方法は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are various ways to run Julia code and provide options, similar to
those available for the &lt;c0&gt;&lt;s1&gt;perl&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;ruby&lt;/s3&gt;&lt;/c2&gt; programs:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T085612Z" creationid="hsugawa8651" creationdate="20181118T085526Z">
        <seg>他の言語（&lt;c0&gt;&lt;s1&gt;perl&lt;/s1&gt;&lt;/c0&gt; や &lt;c2&gt;&lt;s3&gt;ruby&lt;/s3&gt;&lt;/c2&gt; など）のように、Juliaを実行するには様々な方法やオプションがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are various ways to run Julia code and provide options, similar to those available for the
&lt;x1/&gt;perl&lt;x2/&gt; and &lt;x3/&gt;ruby&lt;x4/&gt; programs:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092737Z" creationid="hsugawa8651" creationdate="20181109T224520Z">
        <seg>他の言語（&lt;x1/&gt;perl&lt;x2/&gt; や &lt;x3/&gt;ruby&lt;x4/&gt; など）のように、Juliaを実行するには様々な方法やオプションがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a second, more terse syntax for defining a function in Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025503Z" creationid="hsugawa8651" creationdate="20181110T025503Z">
        <seg>Juliaで関数を定義するには、2番目のより簡潔な構文があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a
&lt;x7/&gt;`broadcast!`&lt;x8/&gt; function to specify an explicit destination (which can also
be accessed in a fusing fashion by &lt;x9/&gt;.=&lt;x10/&gt; assignment).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161307Z" creationid="hsugawa8651" creationdate="20181114T161307Z">
        <seg>また &lt;x7/&gt;'ブロードキャスト!&lt;x8/&gt;関数は明示的な宛先を指定することができます(これは &lt;x9/&gt;.=&lt;x10/&gt;割り当てにより、融合方式でアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is one additional special calling convention &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref Base.llvmcall),
which allows inserting calls to LLVM intrinsics directly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152448Z" creationid="hsugawa8651" creationdate="20181117T152448Z">
        <seg>さらに特別な呼び出し規則が一つあります&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref Base.リウムカル)。 ではLLVM組み込みへの呼び出しを直接挿入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore this syntax is disallowed, and spaces must be used around
the operator in such cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132651Z" creationid="hsugawa8651" creationdate="20181113T132651Z">
        <seg>したがって、この構文は使用できません。また、スペースを使用してスペースを使用する必要があります。 この場合の演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, if an &lt;x1/&gt;Array&lt;x2/&gt; contains data in the wrong format, it will have to be explicitly converted
using a call such as &lt;x3/&gt;trunc(Int32, a)&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T140857Z" creationid="hsugawa8651" creationdate="20181117T134507Z">
        <seg>したがって、&lt;x1/&gt;配列&lt;x2/&gt;が誤った形式でデータを含む場合は、明示的に変換する必要があります。 &lt;x3/&gt;trunc(Int32,a)&lt;x4/&gt;のようなコールを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the &lt;x15/&gt;Ref{gsl_permutation}&lt;x16/&gt; declaration allows pointers managed by C or
Julia to be used.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152140Z" creationid="hsugawa8651" creationdate="20181117T152140Z">
        <seg>したがって、&lt;x15/&gt;Ref{gsl_mutation}&lt;x16/&gt;宣言は、Cによって管理されるポインタを許可する。 ジュリアは使用される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the rest of this chapter focuses on the behavior and mechanics of package loading.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152750Z" creationid="hsugawa8651" creationdate="20181117T152750Z">
        <seg>したがって、この章の残りはパッケージロードの動作とメカニズムに焦点を当てています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, when you next upgrade &lt;x17/&gt;Pub&lt;x18/&gt; to get the latest bug fixes and features, &lt;x19/&gt;App&lt;x20/&gt; will end up—through no action of yours other than upgrading—depending on two different packages named &lt;x21/&gt;Priv&lt;x22/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152900Z" creationid="hsugawa8651" creationdate="20181117T152900Z">
        <seg>したがって、&lt;x17/&gt;Pub&lt;x18/&gt;をアップグレードして最新のバグ修正と機能を取得する場合、&lt;x19/&gt;App&lt;x20/&gt;は、&lt;X21/&gt;Priv&lt;x22/&gt;という名前の2つの異なるパッケージに依存してアップグレードする以外の操作は行いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are
normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230459Z" creationid="hsugawa8651" creationdate="20181109T230459Z">
        <seg>これらは 通常の関数は、インフィックス演算子の構文をサポートしていますが、常にその引数を評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These examples are hopefully helpful to illustrate how generated functions work, both in the definition
end and at the call site; however, &lt;x1/&gt;don't copy them&lt;x2/&gt;, for the following reasons:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032054Z" creationid="hsugawa8651" creationdate="20181116T032054Z">
        <seg>これらの例は、定義された関数がどのように機能するかを説明するために役立つことが望まれます。 ただし、次の理由により、&lt;x1/&gt;はコピーされません。&lt;x/&gt;:&lt;x1/&gt;&lt;x2/&gt;&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions are useful in &lt;x1/&gt;Numeric Comparisons&lt;x2/&gt; to avoid overhead from unnecessary
&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref conversion-and-promotion).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112023Z" creationid="hsugawa8651" creationdate="20181112T112023Z">
        <seg>これらの関数は、不要なオーバーヘッドを回避するために&lt;x1/&gt;数値比較&lt;x2/&gt;で役立ちます。 &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref変換とプロモーション)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These map
directly onto numeric types and operations that are natively supported on modern computers, thus
allowing Julia to take full advantage of computational resources.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225049Z" creationid="hsugawa8651" creationdate="20181109T225049Z">
        <seg>これらのマップ 現代のコンピューターでネイティブにサポートされている数値型や操作に直接 ジュリアが計算資源を最大限に活用できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These mathematical
operations are defined over as broad a class of numerical values as permit sensible definitions,
including integers, floating-point numbers, rationals, and complex numbers,
wherever such definitions make sense.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030759Z" creationid="hsugawa8651" creationdate="20181114T030759Z">
        <seg>これらの数学的な 操作は、許容可能な定義として、数値の幅広いクラスにわたって定義されます。 整数、浮動小数点数、理数、複素数などを含みます。 このような定義が意味を持つのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These may be used as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224831Z" creationid="hsugawa8651" creationdate="20181109T224831Z">
        <seg>これらは次のように使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations
generally work correctly as a fallback for any specific array implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160310Z" creationid="hsugawa8651" creationdate="20181109T160310Z">
        <seg>これらの操作 一般的には、特定のアレイ実装のフォールバックとして正しく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules allow broadcasting to keep the sparse representation for operations that result
in one or two dimensional outputs, but produce an &lt;x7/&gt;Array&lt;x8/&gt; for any other dimensionality.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131914Z" creationid="hsugawa8651" creationdate="20181113T131914Z">
        <seg>これらのルールにより、ブロードキャストを実行して、操作のスパース表現を維持することができます。 1次元または2次元の出力では、他の次元に対して&lt;x7/&gt;配列&lt;x8/&gt;を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules indicate that the combination of a &lt;x1/&gt;SparseVecStyle&lt;x2/&gt; with 0- or 1-dimensional arrays
yields another &lt;x3/&gt;SparseVecStyle&lt;x4/&gt;, that its combination with a 2-dimensional array
yields a &lt;x5/&gt;SparseMatStyle&lt;x6/&gt;, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131922Z" creationid="hsugawa8651" creationdate="20181113T131922Z">
        <seg>これらの規則は、&lt;x1/&gt;SparseVecStyle&lt;x2/&gt;と0次元あるいは1次元の配列との組み合わせを示している。 2次元配列との組合せにより、別の&lt;x3/&gt;SparseVecStyle&lt;x4/&gt;を生成する。 は、&lt;x5/&gt;SparseMatStyle&lt;x6/&gt;を生成し、高い次元のすべては、密な任意の次元フレームワークに戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These statements also make the module named &lt;x7/&gt;X&lt;x8/&gt;, which results from loading the package code, available within the module where the import statement occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152809Z" creationid="hsugawa8651" creationdate="20181117T152809Z">
        <seg>これらのステートメントは、インポート・ステートメントが発生するモジュール内で使用可能なパッケージ・コードをロードした結果として、&lt;x7/&gt;X&lt;x8/&gt;という名前のモジュールを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These three kinds of environment each serve a different purpose:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152934Z" creationid="hsugawa8651" creationdate="20181117T152934Z">
        <seg>これら3種類の環境は、それぞれ異なる目的で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two modalities are identified by Julia as &lt;x5/&gt;IndexLinear()&lt;x6/&gt; and &lt;x7/&gt;IndexCartesian()&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022712Z" creationid="hsugawa8651" creationdate="20181113T022712Z">
        <seg>これらの2つの方法は、Juliaによって&lt;x5/&gt;IndexLinear()&lt;x6/&gt;および&lt;x7/&gt;IndexCartesian()&lt;x8/&gt;と同定されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are &lt;x1/&gt;2.0^-23&lt;x2/&gt; and &lt;x3/&gt;2.0^-52&lt;x4/&gt; as &lt;x5/&gt;`Float32`&lt;x6/&gt; and &lt;x7/&gt;`Float64`&lt;x8/&gt; values,
respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111157Z" creationid="hsugawa8651" creationdate="20181112T111157Z">
        <seg>これらの値は&lt;x1/&gt;2.0^-23&lt;x2/&gt;と&lt;x2.0/&gt;52&lt;x6/&gt;であり、&lt;x5/&gt;"Floating32"&lt;x6/&gt;および&lt;x7/&gt;'Float64'&lt;x8/&gt;の値である。 それぞれ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are equal to each other but have different binary representations, as
can be seen using the &lt;x3/&gt;`bitstring`&lt;x4/&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110747Z" creationid="hsugawa8651" creationdate="20181112T110747Z">
        <seg>これらは互いに等しいが、バイナリ表現は異なっている。 は、&lt;x3/&gt;`bitstring'&lt;x4/&gt;関数を使用して表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be used similarly to &lt;x2/&gt;Array{Bool}&lt;x3/&gt; arrays (which store one byte per boolean value),
and can be converted to/from the latter via &lt;x4/&gt;Array(bitarray)&lt;x5/&gt; and &lt;x6/&gt;BitArray(array)&lt;x7/&gt;, respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160451Z" creationid="hsugawa8651" creationdate="20181109T160451Z">
        <seg>これらは、&lt;x2/&gt;Array{Bool}&lt;x3/&gt;配列(ブール値ごとに1バイトを格納する)と同様に使用できます。 また、&lt;x4/&gt;アレイ(bitarray)&lt;x5/&gt;および&lt;x6/&gt;BitArray(配列)&lt;x7/&gt;を介して、後者との間で変換を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They produce an unsigned integer of the same size as the unsigned literal
would do, with the two's complement of the value:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225518Z" creationid="hsugawa8651" creationdate="20181109T225518Z">
        <seg>これらは符号なしのリテラルと同じサイズの符号なし整数を生成します。 2年代の価値を補完することができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They represent a collection
of scalar indices that each span &lt;x3/&gt;N&lt;x4/&gt; dimensions, enabling a form of indexing
that is sometimes referred to as pointwise indexing.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155651Z" creationid="hsugawa8651" creationdate="20181109T155651Z">
        <seg>コレクションを表します。 各スパン&lt;x3/&gt;N&lt;x4/&gt;の各次元を使用可能にするスカラー指数のことで、索引の形式が可能になります。 ポイントワイズインデックスと呼ばれることもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They therefore must take the form of a literal tuple, not a variable,
and cannot reference local variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151224Z" creationid="hsugawa8651" creationdate="20181117T151224Z">
        <seg>したがって、それらは変数ではなく、リテラル・タプルの形をとる必要があります。 ローカル変数を参照できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150455Z" creationid="hsugawa8651" creationdate="20181117T150455Z">
        <seg>Third"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
is because &lt;x5/&gt;(Cstring)&lt;x6/&gt; is just the expression &lt;x7/&gt;Cstring&lt;x8/&gt; surrounded by parentheses, rather than
a 1-tuple containing &lt;x9/&gt;Cstring&lt;x10/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224100Z" creationid="hsugawa8651" creationdate="20181109T224100Z">
        <seg>これ &lt;x5/&gt;(Cstring)&lt;x6/&gt;は、&lt;x7/&gt;Cstring&lt;x8/&gt;で囲まれた括弧で囲まれた表現であり &lt;x9/&gt;Cstring&lt;x10/&gt;:を含む1組のタプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
separation is typically quite natural.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155835Z" creationid="hsugawa8651" creationdate="20181117T155835Z">
        <seg>これ 分離は、典型的には非常に自然なものである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
will construct a 1-d array with element type &lt;x3/&gt;T&lt;x4/&gt;, initialized to contain elements &lt;x5/&gt;A&lt;x6/&gt;, &lt;x7/&gt;B&lt;x8/&gt;, &lt;x9/&gt;C&lt;x10/&gt;,
etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154702Z" creationid="hsugawa8651" creationdate="20181109T154702Z">
        <seg>これ 要素タイプ&lt;x3/&gt;T&lt;x4/&gt;を持つ1dアレイを構築し、要素&lt;x5/&gt;A&lt;x6/&gt;、&lt;x7/&gt;B&lt;x8/&gt;、&lt;x9/&gt;C&lt;x10/&gt;を含むように初期化します。 その他。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;x4/&gt;Squares&lt;x5/&gt; sequence is starting to look
more and more like a vector as we've added behaviors to it.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113152Z" creationid="hsugawa8651" creationdate="20181112T113152Z">
        <seg>この&lt;x4/&gt;Squares&lt;x5/&gt;シーケンスが開始され始めています。 これは、ビヘイビアを追加したときのベクトルに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows custom array implementations to
provide their own &lt;x23/&gt;copyto!&lt;x24/&gt; specialization to customize and
optimize broadcasting.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131547Z" creationid="hsugawa8651" creationdate="20181113T131547Z">
        <seg>これにより、カスタム・アレイの実装が可能になります。 独自の&lt;x23/&gt;copyto!&lt;x24/&gt;特殊化を提供してカスタマイズし 放送を最適化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows, for example, passing an &lt;x2/&gt;argv&lt;x3/&gt; pointer array of type
&lt;x4/&gt;Vector{String}&lt;x5/&gt; to an argument of type &lt;x6/&gt;Ptr{Ptr{Cchar}}&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150834Z" creationid="hsugawa8651" creationdate="20181117T150834Z">
        <seg>これにより、例えば、&lt;x2/&gt;argv&lt;x3/&gt;ポインタ配列を通過させることができる。 &lt;x4/&gt;Vector{String}&lt;x5/&gt;は、&lt;x6/&gt;Ptr{Ptr{Cchar}}&lt;x7/&gt;の型を引数にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This applies not only to
arrays and other mutable objects which are normally heap-allocated, but also to
scalar values such as integers and floats which are normally stack-allocated and
commonly passed in registers when using C or Julia calling conventions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223829Z" creationid="hsugawa8651" creationdate="20181109T223829Z">
        <seg>これは 通常はヒープ割り当てされた配列やその他のmutableオブジェクトですが 通常スタック割り当てされた整数や浮動小数点のようなスカラー値 一般的には、CまたはJuliaの呼び出し規約を使用するときにレジスタで渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This argument will be evaluated at compile-time, when the containing method is defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223844Z" creationid="hsugawa8651" creationdate="20181109T223844Z">
        <seg>この引数は、containingメソッドが定義された時にコンパイル時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This basic framework is extensible in three major ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131021Z" creationid="hsugawa8651" creationdate="20181113T131021Z">
        <seg>この基本的なフレームワークは、次の3つの主要な方法で拡張できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is based on the observation that when one uses unsigned hex literals for integer
values, one typically is using them to represent a fixed numeric byte sequence, rather than just
an integer value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225343Z" creationid="hsugawa8651" creationdate="20181109T225343Z">
        <seg>この動作は、整数に対して符号なしの16進数のリテラルを使用する場合の観察結果に基づいています。 値は通常、固定された数値バイトシーケンスを表すために使用されます。 整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is frequently used in Julia to form an alternative to very short &lt;x1/&gt;if&lt;x2/&gt; statements.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230359Z" creationid="hsugawa8651" creationdate="20181109T230359Z">
        <seg>この動作は、&lt;x2/&gt;ステートメントの場合、非常に短い&lt;x1/&gt;の代替を形成するために、Juliaで頻繁に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior occurs when the first &lt;x5/&gt;`ccall`&lt;x6/&gt; argument contains references
to non-constants, such as local variables, function arguments, or non-constant globals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152327Z" creationid="hsugawa8651" creationdate="20181117T152327Z">
        <seg>この振る舞いは、最初の&lt;x5/&gt;`ccall'&lt;x6/&gt;引数が参照を含んでいるときに発生します。 ローカル変数、関数引数、非定数グローバルなどの非定数に指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This call will attempt to infer type information from the
keys and values (i.e. this example creates a &lt;x2/&gt;Dict{String, Int64}&lt;x3/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032114Z" creationid="hsugawa8651" creationdate="20181114T032114Z">
        <seg>この呼び出しは、以下のようなタイプ情報を推測しようとします。 キーと値(すなわち、この例では、&lt;x2/&gt;Dict{String,Int64}&lt;x3/&gt;を作成します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be especially useful when targeting unusual platforms such as GPGPUs.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152449Z" creationid="hsugawa8651" creationdate="20181117T152449Z">
        <seg>これは、GPGPUsなどの特殊なプラットフォームをターゲットにする場合に特に役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be expressed much more simply with &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-vectorized)
and by combining it with a normal integer index (instead of extracting the
first &lt;x4/&gt;page&lt;x5/&gt; from &lt;x6/&gt;A&lt;x7/&gt; as a separate step).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161052Z" creationid="hsugawa8651" creationdate="20181114T161052Z">
        <seg>これは、&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref manベクトル化)ではるかに簡単に表現することができます。 そして、それを通常の整数インデックスと組み合わせることで( 最初の&lt;x4/&gt;ページ&lt;x6/&gt;&lt;x6/&gt;から個別のステップとして&lt;x7/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be expressed much more simply with &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-vectorized)
and by combining it with a normal integer index (instead of extracting the
first &lt;x4/&gt;page&lt;x5/&gt; from &lt;x6/&gt;A&lt;x7/&gt; as a separate step). It can even be combined with a &lt;x8/&gt;:&lt;x9/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135028Z" creationid="hsugawa8651" creationdate="20181117T135028Z">
        <seg>これは、&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref manベクトル化)ではるかに簡単に表現することができます。 そして、それを通常の整数インデックスと組み合わせることで( 最初の&lt;x4/&gt;ページ&lt;x6/&gt;&lt;x6/&gt;から別のステップとして&lt;x7/&gt;。また、&lt;x8/&gt;:&lt;x9/&gt;と組み合わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code will be common to both versions, and is run-time code in both versions
(it will be quoted and returned as an expression from the generated version).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032411Z" creationid="hsugawa8651" creationdate="20181116T032411Z">
        <seg>このコードは両方のバージョンに共通で、両方のバージョンで実行されるランタイム・コードです。 (これは、生成されたバージョンからの式として引用され、返されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This condition
is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032238Z" creationid="hsugawa8651" creationdate="20181116T032238Z">
        <seg>この状態 は、モジュール内の任意の関数を呼び出し可能にするために、段階的にロードされたプリコンパイル済みモジュールに対して、リラックスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This could be written more concisely using the ternary operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230116Z" creationid="hsugawa8651" creationdate="20181109T230116Z">
        <seg>これは、三元演算子を使用してより簡潔に書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This declaration has the same effect as the earlier definition of the &lt;x1/&gt;Foo&lt;x2/&gt; type without an explicit
inner constructor method.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155814Z" creationid="hsugawa8651" creationdate="20181117T155814Z">
        <seg>この宣言は、明示的には&lt;x1/&gt;Foo&lt;x2/&gt;タイプの以前の定義と同じ効果を持っています。 インナーコンストラクタメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction determines which scalar indexing methods the type must define.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094519Z" creationid="hsugawa8651" creationdate="20181118T094519Z">
        <seg>この区別によって、タイプが定義するスカラー・インデックス・メソッドが決まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not occur when Julia code is run in other ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225348Z" creationid="hsugawa8651" creationdate="20181109T225348Z">
        <seg>これは、Juliaコードが他の方法で実行されている場合には発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This error indicates that the conditional was of the wrong type: &lt;x1/&gt;`Int64`&lt;x2/&gt; rather
than the required &lt;x3/&gt;`Bool`&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230041Z" creationid="hsugawa8651" creationdate="20181109T230041Z">
        <seg>このエラーは、条件が間違ったタイプであることを示しています:&lt;x1/&gt;`Int64`&lt;x2/&gt;。 必要な&lt;x3/&gt;`Bool'&lt;x4/&gt;よりも多くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example first allocates an array of bytes, then calls the C library function &lt;x1/&gt;gethostname&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133842Z" creationid="hsugawa8651" creationdate="20181117T133842Z">
        <seg>この例ではまず、バイトの配列を割り当て、次にCライブラリ関数&lt;x1/&gt;gethostname&lt;x2/&gt;を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This experimental interface supports Julia's multi-threading capabilities.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032154Z" creationid="hsugawa8651" creationdate="20181114T032154Z">
        <seg>この実験インターフェースは、Juliaのマルチスレッド機能をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This expression constructs a name using &lt;x1/&gt;string&lt;x2/&gt;, then substitutes this name into a new &lt;x3/&gt;`ccall`&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152307Z" creationid="hsugawa8651" creationdate="20181117T152307Z">
        <seg>この表現は&lt;x1/&gt;ストリング&lt;x2/&gt;を使用して名前を作成し、次にこの名前を新しい&lt;x3/&gt;`ccall'&lt;x4/&gt;に置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form can be used to call C library
functions, functions in the Julia runtime, or functions in an application linked to Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223802Z" creationid="hsugawa8651" creationdate="20181109T223802Z">
        <seg>このフォームを使用してCライブラリを呼び出すことができます。 関数、Juliaランタイム内の関数、またはJuliaにリンクされたアプリケーションの関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is intentionally similar
to the behavior of &lt;x7/&gt;`getindex`&lt;x8/&gt; and &lt;x9/&gt;`setindex!`&lt;x10/&gt; (e.g. &lt;x11/&gt;[]&lt;x12/&gt; access syntax).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152531Z" creationid="hsugawa8651" creationdate="20181117T152531Z">
        <seg>この関数は意図的に似ています &lt;x7/&gt;`getindex'&lt;x8/&gt;および&lt;x9/&gt;`setindex!`&lt;x10/&gt;(例:&lt;x11/&gt;[]&lt;x12/&gt;アクセス構文)の動作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This guarantees that all objects of the declared type must come into
existence by a call to one of the inner constructor methods provided with the type, thereby giving
some degree of enforcement of a type's invariants.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155804Z" creationid="hsugawa8651" creationdate="20181117T155804Z">
        <seg>これにより、宣言されたタイプのすべてのオブジェクトが、次のように指定されることが保証されます。 型で提供される内部コンストラクタメソッドの一つを呼び出して存在することによって タイプの不変度のある程度の強制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the exact same effect as the previous definition of &lt;x1/&gt;foo&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101533Z" creationid="hsugawa8651" creationdate="20181112T101533Z">
        <seg>これは、&lt;x1/&gt;foo&lt;x2/&gt;の前の定義とまったく同じ効果を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes
&lt;x6/&gt;`Colon`&lt;x7/&gt; (&lt;x8/&gt;:&lt;x9/&gt;) to select all indices within the entire dimension,
ranges of the form &lt;x10/&gt;a:c&lt;x11/&gt; or &lt;x12/&gt;a:b:c&lt;x13/&gt; to select contiguous or strided
subsections, and arrays of booleans to select elements at their &lt;x14/&gt;true&lt;x15/&gt; indices.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155120Z" creationid="hsugawa8651" creationdate="20181109T155120Z">
        <seg>これには &lt;x6/&gt;「コロン」&lt;x7/&gt;(&lt;x8/&gt;:&lt;x9/&gt;)は、次元全体のすべてのインデックスを選択するために使用されます。 &lt;x10/&gt;a:c&lt;x11/&gt;または&lt;x12/&gt;a:b:c&lt;x13/&gt;to select連続またはストライドされたものを選択するための範囲 サブセクションは、&lt;x14/&gt;真の&lt;x15/&gt;インデックスで選択要素を選択するためのブール演算の配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155518Z" creationid="hsugawa8651" creationdate="20181109T155518Z">
        <seg>これには次のものが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is
invisible to users as it is immediately realized through a call to &lt;x11/&gt;copy&lt;x12/&gt;, but it is this container
that provides the basis for broadcast's extensibility for authors of custom types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131523Z" creationid="hsugawa8651" creationdate="20181113T131523Z">
        <seg>これは &lt;x11/&gt;コピー&lt;x12/&gt;の呼び出しによってすぐに実現されるため、ユーザには見えませんが、このコンテナはこのコンテナです。 は、カスタム・タイプの作成者にとって、ブロードキャストの拡張性の基礎を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a powerful construct: both exception handling and
cooperative multitasking are implemented in Julia using tasks.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225749Z" creationid="hsugawa8651" creationdate="20181109T225749Z">
        <seg>これは強力な構成であり、例外処理とも呼ばれます。 タスクを使用して、Juliaで協調的マルチタスクを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a very common pattern throughout Julia Base: a small set of required methods
define an informal interface that enable many fancier behaviors.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112840Z" creationid="hsugawa8651" creationdate="20181112T112840Z">
        <seg>これは、Julia Base全体で非常に一般的なパターンです。必要なメソッドの集合です。 多くのファン的な振る舞いを可能にするインフォーマルなインターフェースを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is accomplished just by making an appropriate call with
&lt;x1/&gt;`ccall`&lt;x2/&gt; syntax, which looks like an ordinary function call.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160544Z" creationid="hsugawa8651" creationdate="20181109T160544Z">
        <seg>これは、適切な呼び出しを行うことによって実現されます。 &lt;x1/&gt;`ccall'&lt;x2/&gt;構文は、通常の関数呼び出しのように見えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is again determined by the computed broadcast style.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131550Z" creationid="hsugawa8651" creationdate="20181113T131550Z">
        <seg>これは、計算されたブロードキャスト・スタイルによって再度決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because argument parsing in shebang
is platform-dependent and not well-specified.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024923Z" creationid="hsugawa8651" creationdate="20181110T024923Z">
        <seg>これは、シェバンの引数の構文解析が はプラットフォーム依存であり、よく指定されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is such
an important part of the operation that it is stored as the first type parameter of the
&lt;x25/&gt;Broadcasted&lt;x26/&gt; type, allowing for dispatch and specialization.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131554Z" creationid="hsugawa8651" creationdate="20181113T131554Z">
        <seg>これは の最初のタイプパラメータとして格納される操作の重要な部分です。 &lt;x25/&gt;ブロードキャストされた&lt;x26/&gt;タイプで、ディスパッチと特殊化を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the list of reserved keywords in Julia:
&lt;x1/&gt;baremodule&lt;x2/&gt;, &lt;x3/&gt;begin&lt;x4/&gt;, &lt;x5/&gt;break&lt;x6/&gt;, &lt;x7/&gt;catch&lt;x8/&gt;, &lt;x9/&gt;const&lt;x10/&gt;, &lt;x11/&gt;continue&lt;x12/&gt;, &lt;x13/&gt;do&lt;x14/&gt;,
&lt;x15/&gt;else&lt;x16/&gt;, &lt;x17/&gt;elseif&lt;x18/&gt;, &lt;x19/&gt;end&lt;x20/&gt;, &lt;x21/&gt;export&lt;x22/&gt;, &lt;x23/&gt;false&lt;x24/&gt;, &lt;x25/&gt;finally&lt;x26/&gt;, &lt;x27/&gt;for&lt;x28/&gt;, &lt;x29/&gt;function&lt;x30/&gt;,
&lt;x31/&gt;global&lt;x32/&gt;, &lt;x33/&gt;if&lt;x34/&gt;, &lt;x35/&gt;import&lt;x36/&gt;, &lt;x37/&gt;let&lt;x38/&gt;, &lt;x39/&gt;local&lt;x40/&gt;, &lt;x41/&gt;macro&lt;x42/&gt;, &lt;x43/&gt;module&lt;x44/&gt;, &lt;x45/&gt;quote&lt;x46/&gt;,
&lt;x47/&gt;return&lt;x48/&gt;, &lt;x49/&gt;struct&lt;x50/&gt;, &lt;x51/&gt;true&lt;x52/&gt;, &lt;x53/&gt;try&lt;x54/&gt;, &lt;x55/&gt;using&lt;x56/&gt;, &lt;x57/&gt;while&lt;x58/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041738Z" creationid="hsugawa8651" creationdate="20181110T041738Z">
        <seg>This is the list of reserved keywords in Julia:
&lt;x1/&gt;baremodule&lt;x2/&gt;, &lt;x3/&gt;begin&lt;x4/&gt;, &lt;x5/&gt;break&lt;x6/&gt;, &lt;x7/&gt;catch&lt;x8/&gt;, &lt;x9/&gt;const&lt;x10/&gt;, &lt;x11/&gt;continue&lt;x12/&gt;, &lt;x13/&gt;do&lt;x14/&gt;,
&lt;x15/&gt;else&lt;x16/&gt;, &lt;x17/&gt;elseif&lt;x18/&gt;, &lt;x19/&gt;end&lt;x20/&gt;, &lt;x21/&gt;export&lt;x22/&gt;, &lt;x23/&gt;false&lt;x24/&gt;, &lt;x25/&gt;finally&lt;x26/&gt;, &lt;x27/&gt;for&lt;x28/&gt;, &lt;x29/&gt;function&lt;x30/&gt;,
&lt;x31/&gt;global&lt;x32/&gt;, &lt;x33/&gt;if&lt;x34/&gt;, &lt;x35/&gt;import&lt;x36/&gt;, &lt;x37/&gt;let&lt;x38/&gt;, &lt;x39/&gt;local&lt;x40/&gt;, &lt;x41/&gt;macro&lt;x42/&gt;, &lt;x43/&gt;module&lt;x44/&gt;, &lt;x45/&gt;quote&lt;x46/&gt;,
&lt;x47/&gt;return&lt;x48/&gt;, &lt;x49/&gt;struct&lt;x50/&gt;, &lt;x51/&gt;true&lt;x52/&gt;, &lt;x53/&gt;try&lt;x54/&gt;, &lt;x55/&gt;using&lt;x56/&gt;, &lt;x57/&gt;while&lt;x58/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the same behavior found in Scheme, most Lisps,
Python, Ruby and Perl, among other dynamic languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025715Z" creationid="hsugawa8651" creationdate="20181110T025715Z">
        <seg>これはSchemeで見られる動作と同じです。ほとんどのLispです。 Python、Ruby、Perlは、その他の動的言語の中でもとりわけ優れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful to
hide a stacktrace (which contains non-permanent references to lines
of julia code) when the doctest shows that an exception is thrown,
for example:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020038Z" creationid="hsugawa8651" creationdate="20181116T020038Z">
        <seg>This is useful to
hide a stacktrace (which contains non-permanent references to lines
of julia code) when the doctest shows that an exception is thrown,
for example:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is wasteful when dimensions get large, so Julia provides &lt;x1/&gt;`broadcast`&lt;x2/&gt;, which expands
singleton dimensions in array arguments to match the corresponding dimension in the other array
without using extra memory, and applies the given function elementwise:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161257Z" creationid="hsugawa8651" creationdate="20181114T161257Z">
        <seg>次元が大きくなると無駄になります。したがって、Juliaは&lt;x1/&gt;'ブロードキャスト''&lt;x2/&gt;を提供します。これは拡張されます。 配列引数内の単一の次元を、他の配列内の対応する次元に一致させます。 は、余分なメモリを使用せず、指定された関数要素を適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of environment was the only kind that existed in Julia 0.6 and earlier.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152925Z" creationid="hsugawa8651" creationdate="20181117T152925Z">
        <seg>この種の環境は、ジュリア0.6以前に存在していた唯一の種であった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This leverages a fallback implementation of &lt;x1/&gt;copyto!&lt;x2/&gt; that converts the wrapper into a
&lt;x3/&gt;Broadcasted{Nothing}&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131702Z" creationid="hsugawa8651" creationdate="20181113T131702Z">
        <seg>これは、ラッパーを変換する&lt;x1/&gt;copyto!&lt;x2/&gt;のフォールバック実装を活用します。 &lt;x3/&gt;ブロードキャスト{なし}&lt;x4/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it simple to relocate a subtree of source files.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152720Z" creationid="hsugawa8651" creationdate="20181117T152720Z">
        <seg>これによって、ソースファイルのサブツリーを簡単に再配置することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes writing polynomial expressions
much cleaner:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111727Z" creationid="hsugawa8651" creationdate="20181112T111727Z">
        <seg>これにより、多項式式が作成されます。 よりクリーンです</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may sound like a strange restriction,
but remember that since C is not a dynamic language like Julia,
its functions can only accept argument types with a statically-known, fixed signature.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151227Z" creationid="hsugawa8651" creationdate="20181117T151227Z">
        <seg>これは奇妙な制限のように聞こえるかもしれませんが でもCはジュリアのようなダイナミックな言語ではないので その関数は、静的に既知の固定署名を持つ引数型の引数型のみを受け入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that
&lt;x1/&gt;@cfunction&lt;x2/&gt;-generated pointers cannot be used in calls where WINAPI expects &lt;x3/&gt;stdcall&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153957Z" creationid="hsugawa8651" creationdate="20181109T153957Z">
        <seg>つまり &lt;x1/&gt;@cfunction&lt;x2/&gt;-生成されたポインタは、WINAPIが&lt;x3/&gt;stdcall&lt;x4/&gt;を想定している呼び出しでは使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that multiple independent parties can maintain both public and private packages and registries of them, and that projects can depend on a mix of public and private packages from different registries.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152823Z" creationid="hsugawa8651" creationdate="20181117T152823Z">
        <seg>これは、複数の独立した当事者が、パブリック・パッケージとプライベート・パッケージの両方を維持することができること、およびプロジェクトが異なるレジストリーからのパブリック・パッケージとプライベート・パッケージの混在に依存することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that new variables
defined inside the &lt;x2/&gt;if&lt;x3/&gt; clauses can be used after the &lt;x4/&gt;if&lt;x5/&gt; block, even if they weren't defined
before.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225918Z" creationid="hsugawa8651" creationdate="20181109T225918Z">
        <seg>つまり、新しい変数は &lt;x4/&gt;の場合は&lt;x/&gt;の範囲内で、&lt;x4/&gt;の場合は&lt;x4/&gt;の範囲内で定義されていても、定義されていない場合でも定義されます。 の前にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that programs making heavy use of generated functions might be impossible to
statically compile.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032346Z" creationid="hsugawa8651" creationdate="20181116T032346Z">
        <seg>つまり、生成された関数を大量に使用するプログラムは不可能である可能性があります。 静的にコンパイルします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means we must also define a corresponding &lt;x1/&gt;similar&lt;x2/&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131420Z" creationid="hsugawa8651" creationdate="20181113T131420Z">
        <seg>これはまた、対応する&lt;x1/&gt;類似の&lt;x2/&gt;の方法を定義する必要があることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means, for example, that
&lt;x9/&gt;1 / 2im&lt;x10/&gt; equals &lt;x11/&gt;-0.5im&lt;x12/&gt; and &lt;x13/&gt;6 // 2(2 + 1)&lt;x14/&gt; equals &lt;x15/&gt;1 // 1&lt;x16/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111830Z" creationid="hsugawa8651" creationdate="20181112T111830Z">
        <seg>これは例えば &lt;x9/&gt;1/2im&lt;x10/&gt;=&lt;x11/&gt;-0.5im&lt;x12/&gt;6//2(2 + 1)&lt;x14/&gt;=&lt;x15/&gt;=&lt;x15/&gt;1//1&lt;x16/&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This model is a
good fit for mathematical programming, where it is unnatural for the
first argument to “own” an operation as in traditional object-oriented
dispatch.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082414Z" creationid="hsugawa8651" creationdate="20181118T082414Z">
        <seg>このモデルは数値計算にとても適しています。 従来のオブジェクト指向ディスパッチのように、第一引数が演算子を「所有」するのは不自然です。 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This much was already mentioned briefly when
composite types were introduced.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155626Z" creationid="hsugawa8651" creationdate="20181117T155626Z">
        <seg>このことは、すでに簡単に述べた。 複合型が導入されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This object can be iterated to produce values on demand, instead of allocating
an array and storing them in advance (see &lt;x1/&gt;Iteration&lt;x2/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154927Z" creationid="hsugawa8651" creationdate="20181109T154927Z">
        <seg>このオブジェクトを反復して、必要に応じて必要に応じて値を生成することができます。 配列とそれを事前に格納する(&lt;x1/&gt;Iteration&lt;x2/&gt;を参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This possibility is unavoidable since these entities do not coordinate and may not even know about each other.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152835Z" creationid="hsugawa8651" creationdate="20181117T152835Z">
        <seg>この可能性は、これらのエンティティが調整されておらず、互いに認識されていない可能性があるため、避けられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This reflects the characteristics of the underlying arithmetic of integers as implemented on modern
computers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110518Z" creationid="hsugawa8651" creationdate="20181112T110518Z">
        <seg>これは、近現代で実装されている整数の基礎となる算術の特性を反映しています。 コンピューター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting will cause &lt;x1/&gt;eachindex&lt;x2/&gt; iteration over a &lt;x3/&gt;MyArray&lt;x4/&gt; to use integers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161200Z" creationid="hsugawa8651" creationdate="20181114T161200Z">
        <seg>この設定により、&lt;x3/&gt;MyArray&lt;x4/&gt;では&lt;x1/&gt;エアチンデス&lt;x2/&gt;反復が行われ、整数を使用することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting will cause &lt;x1/&gt;eachindex&lt;x2/&gt; iteration over a &lt;x3/&gt;MyArray&lt;x4/&gt; to use integers. If you don't
specify this trait, the default value &lt;x5/&gt;IndexCartesian()&lt;x6/&gt; is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135132Z" creationid="hsugawa8651" creationdate="20181117T135132Z">
        <seg>この設定により、&lt;x1/&gt;MyArray&lt;x4/&gt;では&lt;x1/&gt;エアチンデス&lt;x2/&gt;の繰り返しが行われ、整数を使用することはできません。 この特性を指定します。デフォルト値&lt;x5/&gt;IndexCartesian()&lt;x6/&gt;は使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This sort of eager operation is directly supported by a bit
of indirection; instead of directly constructing &lt;x5/&gt;Broadcasted&lt;x6/&gt; objects, Julia lowers the
fused expression &lt;x7/&gt;x .* (x .+ 1)&lt;x8/&gt; to &lt;x9/&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;x10/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131609Z" creationid="hsugawa8651" creationdate="20181113T131609Z">
        <seg>この種の意欲的な操作は、直接的にサポートされています。 indirection;&lt;x5/&gt;ブロードキャスト&lt;x6/&gt;オブジェクトを直接構築するのではなく、Juliaは次のように説明します。 融合式&lt;x7/&gt;x.*(x .+ 1)&lt;x8/&gt;から&lt;x9/&gt;ブロードキャスト放送(*,x,ブロードキャスト.ブロードキャスト(+, x, 1))&lt;x10/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This style is preferred, since it allows the compiler to make more decisions and compile
programs in more ways, and since normal code is more readable than code-generating code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032419Z" creationid="hsugawa8651" creationdate="20181116T032419Z">
        <seg>このスタイルは、コンパイラーがより多くの決定とコンパイルを行うことができるので、このスタイルは好ましいです。 プログラムはより多くの方法で実行され、通常のコードはコード生成コードよりも読みやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax is particularly useful with the terse single-line function definition form introduced
in &lt;x1/&gt;Functions&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225818Z" creationid="hsugawa8651" creationdate="20181109T225818Z">
        <seg>この構文は、簡潔な単一行関数定義フォームが導入された場合に特に有用です。 &lt;x1/&gt;の関数&lt;x2/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type may appear innocuous enough, until one considers how to construct an instance of it.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155845Z" creationid="hsugawa8651" creationdate="20181117T155845Z">
        <seg>このタイプは、インスタンスの作成方法を考慮するまでは、十分に無害である可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This use of &lt;x3/&gt;...&lt;x4/&gt; for combining many different arguments into a single
argument is called slurping:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025239Z" creationid="hsugawa8651" creationdate="20181110T025239Z">
        <seg>&lt;x3/&gt;.&lt;x4/&gt;を使用して、さまざまな引数を一つに組み合わせて使用します。 引数はsluffingと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value is simply the return value of the last executed statement in the branch that was chosen,
so</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230023Z" creationid="hsugawa8651" creationdate="20181109T230023Z">
        <seg>この値は、選択された分岐内の最後に実行された文の戻り値です。 だから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value represents invalid operators and not
operators of lowest precedence.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031014Z" creationid="hsugawa8651" creationdate="20181114T031014Z">
        <seg>この値は無効な演算子を表しています。 優先順位の低い演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variable can only be used
with corresponding input type declaration &lt;x3/&gt;Ref{Cdouble}&lt;x4/&gt;, since its memory is allocated and managed
by Julia, not C. The implicit call to &lt;x5/&gt;`Base.cconvert(Ref{Cdouble}, result_array)`&lt;x6/&gt; unpacks
the Julia pointer to a Julia array data structure into a form understandable by C.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152159Z" creationid="hsugawa8651" creationdate="20181117T152159Z">
        <seg>この変数は 対応する入力タイプ宣言&lt;x3/&gt;Ref{Cdouble}&lt;x4/&gt;であり、そのメモリは割り当てられ、管理されているため &lt;x5/&gt;'Base.チコンベルト(Ref{Cdouble},result_array)`&lt;x6/&gt;unpacksを暗黙的に呼び出すことはできません。 Juliaの配列データ構造体へのJuliaポインタで、Cによって理解可能な形式に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, the address values obtained from pointer arithmetic do not depend
on the element types of pointers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152619Z" creationid="hsugawa8651" creationdate="20181117T152619Z">
        <seg>このようにして、ポインタ演算から得られたアドレス値は依存しない。 ポインタのエレメント・タイプを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent
environment variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224133Z" creationid="hsugawa8651" creationdate="20181109T224133Z">
        <seg>このラッパーは、呼び出し者が存在しないことを示す問題を明確に示す例外をスローします。 環境変数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those arguments may themselves be more nested
&lt;x3/&gt;Broadcasted&lt;x4/&gt; containers, forming a large expression tree to be evaluated.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131508Z" creationid="hsugawa8651" creationdate="20181113T131508Z">
        <seg>これらの引数自体がネストされている可能性があります。 &lt;x3/&gt;ブロードキャスト&lt;x4/&gt;コンテナで、評価対象となる大きな表現ツリーを形成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those keywords are not allowed to be used as variable names.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041751Z" creationid="hsugawa8651" creationdate="20181110T041742Z">
        <seg>これらのキーワードは、変数名として使用することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical
computing already written in C and Fortran.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160533Z" creationid="hsugawa8651" creationdate="20181109T160533Z">
        <seg>ほとんどのコードはJuliaで書くことができますが、多くの場合、高品質で成熟したライブラリがあります。 CとFortranではすでに作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical
computing already written in C and Fortran. To allow easy use of this existing code, Julia makes
it simple and efficient to call C and Fortran functions. Julia has a "no boilerplate" philosophy:
functions can be called directly from Julia without any "glue" code, code generation, or compilation
-- even from the interactive prompt. This is accomplished just by making an appropriate call with
&lt;x1/&gt;`ccall`&lt;x2/&gt; syntax, which looks like an ordinary function call.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133701Z" creationid="hsugawa8651" creationdate="20181117T133701Z">
        <seg>ほとんどのコードはJuliaで書くことができますが、多くの場合、高品質で成熟したライブラリがあります。 この既存のコードを簡単に使用できるようにするために、JuliaはCとFortranに既に記述されています。 CとFortranの関数を呼び出すことは簡単で効率的です。Juliaは「ボイラープレートなし」の哲学を持っています。 関数は、"glue"コード、コード生成、コンパイルなしで、Juliaから直接呼び出すことができます。 --対話型プロンプトからでも、適切な呼び出しを行うことで &lt;x1/&gt;`ccall'&lt;x2/&gt;構文は、通常の関数呼び出しのように見えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread-safety</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152621Z" creationid="hsugawa8651" creationdate="20181117T152621Z">
        <seg>スレッドセーフ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, arithmetic with Julia integers is actually a form of &lt;x1/&gt;modular arithmetic&lt;x2/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110521Z" creationid="hsugawa8651" creationdate="20181112T110521Z">
        <seg>したがって、Julia整数による算術は実際には&lt;x1/&gt;モジュラ算術&lt;x2/&gt;の形式である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, in both of these
cases, an error occurs since the left-hand value is not a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111854Z" creationid="hsugawa8651" creationdate="20181112T111854Z">
        <seg>これらの両方で 左側の値は関数ではないため、エラーが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance,
we use generated functions to manually unroll the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032314Z" creationid="hsugawa8651" creationdate="20181116T032314Z">
        <seg>このように、生成された関数を利用して反復をコンパイル時に移動させることができます。コンパイラの文法では 生成された関数を使用してループを手動でアンロールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, we only loop &lt;x1/&gt;once per type&lt;x2/&gt;, in this case
once per &lt;x3/&gt;N&lt;x4/&gt; (except in edge cases where the function is generated more than once - see disclaimer
above).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032339Z" creationid="hsugawa8651" creationdate="20181116T032339Z">
        <seg>したがって、我々は、&lt;x2/&gt;のタイプごとに&lt;x1/&gt;をループするだけである。この場合には &lt;x3/&gt;N&lt;x4/&gt;(関数が生成される関数が複数回生成されるエッジを除く)&lt;x3/&gt;で一度1回指定します。 )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To
achieve this, Julia builds upon the lineage of
mathematical programming languages, but also borrows much from popular
dynamic languages, including &lt;a2&gt;Lisp&lt;/a2&gt;, &lt;a3&gt;Perl&lt;/a3&gt;, &lt;a4&gt;Python&lt;/a4&gt;, &lt;a5&gt;Lua&lt;/a5&gt;, and &lt;a6&gt;Ruby&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081924Z" creationid="hsugawa8651" creationdate="20181118T081727Z">
        <seg>このことを実現するために、Juliaは数値計算言語の系譜を踏まえつつも、 &lt;a2&gt;Lisp&lt;/a2&gt; 、 &lt;a3&gt;Perl&lt;/a3&gt; 、 &lt;a4&gt;Python&lt;/a4&gt; 、 &lt;a5&gt;Lua&lt;/a5&gt; 、そして &lt;a6&gt;Ruby&lt;/a6&gt; などの広く使われている動的言語からも多くのアイデアを得ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To accomplish this within a &lt;x1/&gt;`ccall`&lt;x2/&gt;, you need to first
encapsulate the value inside a &lt;x3/&gt;`Ref{T}`&lt;x4/&gt; of the appropriate type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151827Z" creationid="hsugawa8651" creationdate="20181117T151827Z">
        <seg>&lt;x1/&gt;'ccall'&lt;x2/&gt;の中でこれを達成するためには、まず 該当するタイプの&lt;x3/&gt;'Ref{T}&lt;x4/&gt;の内部に値をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To actually support
reverse-order iteration, however, an iterator
type &lt;x2/&gt;T&lt;x3/&gt; needs to implement &lt;x4/&gt;iterate&lt;x5/&gt; for &lt;x6/&gt;Iterators.Reverse{T}&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112942Z" creationid="hsugawa8651" creationdate="20181112T112942Z">
        <seg>実際にサポートするには 逆の順序で反復される反復 &lt;x2/&gt;T&lt;x3/&gt;は&lt;x6/&gt;反復子に&lt;x4/&gt;反復&lt;x5/&gt;を実装する必要があります。逆{T}&lt;x7/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps
the &lt;x1/&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;x2/&gt; and the &lt;x3/&gt;GNU MPFR Library&lt;x4/&gt;,
respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111540Z" creationid="hsugawa8651" creationdate="20181112T111540Z">
        <seg>任意精度の整数と浮動小数点数を使用して計算を可能にするには、Juliaラップを使用します。 &lt;x1/&gt;GNU Multi-Precision Library(GMP)&lt;x2/&gt;および&lt;x3/&gt;GNU MPFRライブラリ&lt;x4/&gt; それぞれ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow easy use of this existing code, Julia makes
it simple and efficient to call C and Fortran functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160536Z" creationid="hsugawa8651" creationdate="20181109T160536Z">
        <seg>この既存のコードを簡単に利用できるようにするために、Juliaは CとFortranの関数を呼び出すことは簡単で効率的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow for the creation of incompletely initialized objects, Julia allows the &lt;x1/&gt;`new`&lt;x2/&gt; function
to be called with fewer than the number of fields that the type has, returning an object with
the unspecified fields uninitialized.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155857Z" creationid="hsugawa8651" creationdate="20181117T155857Z">
        <seg>不完全に初期化されたオブジェクトを作成できるようにするために、Juliaは&lt;x1/&gt;"new`&lt;x2/&gt;関数を許可します。 は、型が持つフィールド数よりも少ない数で呼び出され、オブジェクトを使用してオブジェクトを返します。 未指定のフィールドが初期化されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, create an &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref Base.AsyncCondition) object and &lt;x6/&gt;`wait`&lt;x7/&gt; on it:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152628Z" creationid="hsugawa8651" creationdate="20181117T152628Z">
        <seg>これを行うには、&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref Base.AsyncCondition)オブジェクトを作成し、&lt;x6/&gt;`wait`&lt;x7/&gt;を次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable convenient vectorization of mathematical and other operations,
Julia &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-vectorized) &lt;x4/&gt;f.(args...)&lt;x5/&gt;, e.g. &lt;x6/&gt;sin.(x)&lt;x7/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155933Z" creationid="hsugawa8651" creationdate="20181109T155933Z">
        <seg>数学的およびその他の操作を便利にベクトル化することを可能にするために Julia&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man vectorized)&lt;x4/&gt;f.(args.…)&lt;x6/&gt;sin.(x)&lt;x7/&gt;sin.(x)&lt;x7/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To evaluate expressions written in a source file &lt;c0&gt;&lt;s1&gt;file.jl&lt;/s1&gt;&lt;/c0&gt;, write
&lt;c2&gt;&lt;s3&gt;include("file.jl")&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084142Z" creationid="hsugawa8651" creationdate="20181118T084017Z">
        <seg>&lt;c0&gt;&lt;s1&gt;file.jl&lt;/s1&gt;&lt;/c0&gt; というソースファイルに書かれた式を評価するには、&lt;c2&gt;&lt;s3&gt; include("file.jl")&lt;/s3&gt;&lt;/c2&gt; と書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To evaluate expressions written in a source file &lt;x1/&gt;file.jl&lt;x2/&gt;, write &lt;x3/&gt;include("file.jl")&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091641Z" creationid="hsugawa8651" creationdate="20181114T031403Z">
        <seg>&lt;x1/&gt;file.jl&lt;x2/&gt;というソースファイルに書かれた式を評価するには、&lt;x3/&gt; include("file.jl")&lt;x4/&gt; と書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To exit the interactive session, type &lt;c0&gt;&lt;s1&gt;^D&lt;/s1&gt;&lt;/c0&gt; — the control key
together with the &lt;c2&gt;&lt;s3&gt;d&lt;/s3&gt;&lt;/c2&gt; key or type &lt;c4&gt;&lt;s5&gt;quit()&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084437Z" creationid="hsugawa8651" creationdate="20181118T083847Z">
        <seg>インタラクティブ・セッションを終了するには、&lt;c0&gt;&lt;s1&gt;^D&lt;/s1&gt;&lt;/c0&gt; — コントロールキーと &lt;c2&gt;&lt;s3&gt;d&lt;/s3&gt;&lt;/c2&gt; キーを同時に押す — もしくは、 &lt;c4&gt;&lt;s5&gt;quit()&lt;/s5&gt;&lt;/c4&gt; と入力してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To exit the interactive session, type &lt;x1/&gt;CTRL-D&lt;x2/&gt; (press the Control/&lt;x3/&gt;^&lt;x4/&gt; key together with the &lt;x5/&gt;d&lt;x6/&gt; key), or type
&lt;x7/&gt;exit()&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091430Z" creationid="hsugawa8651" creationdate="20181109T224304Z">
        <seg>インタラクティブ・セッションを終了するには、&lt;x1/&gt;^D&lt;x2/&gt; — コントロールキー&lt;x3/&gt;^&lt;x4/&gt;と &lt;x5/&gt;d&lt;x6/&gt; キーを同時に押す — もしくは、 &lt;x7/&gt;quit()&lt;s8/&gt; と入力してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To explicitly specify types
use the syntax &lt;x4/&gt;Dict{KeyType,ValueType}(...)&lt;x5/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041745Z" creationid="hsugawa8651" creationdate="20181112T041745Z">
        <seg>タイプを明示的に指定するには 構文&lt;x4/&gt;Dict{KeyType,ValueType}(...)&lt;x5/&gt;を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To facilitate chaining, the operator associates from right to left.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230200Z" creationid="hsugawa8651" creationdate="20181109T230200Z">
        <seg>連鎖を容易にするために、オペレータは右から左へと関連する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make common numeric formulae and expressions clearer, Julia allows variables to be immediately
preceded by a numeric literal, implying multiplication.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111730Z" creationid="hsugawa8651" creationdate="20181112T111730Z">
        <seg>一般的な数式や式をより明確にするために、Juliaは変数をすぐに使用できるようにします。 先行する数値リテラルは、乗算を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To opt into this behavior, &lt;x7/&gt;Squares&lt;x8/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113053Z" creationid="hsugawa8651" creationdate="20181112T113053Z">
        <seg>この動作を選択するには、&lt;x7/&gt;Squares&lt;x8/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To override these defaults, you can define a custom &lt;x1/&gt;BroadcastStyle&lt;x2/&gt; for your object:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131132Z" creationid="hsugawa8651" creationdate="20181113T131132Z">
        <seg>これらの既定値をオーバーライドするには、オブジェクトに対してカスタム&lt;x1/&gt;BroadcastStyle&lt;x2/&gt;を定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To pass an array &lt;x1/&gt;A&lt;x2/&gt; as a pointer of a different type &lt;x3/&gt;without&lt;x4/&gt; converting the data beforehand
(for example, to pass a &lt;x5/&gt;Float64&lt;x6/&gt; array to a function that operates on uninterpreted bytes), you
can declare the argument as &lt;x7/&gt;Ptr{Cvoid}&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T140855Z" creationid="hsugawa8651" creationdate="20181117T140855Z">
        <seg>データを事前に変換することなく、異なるタイプ&lt;x3/&gt;のポインタとして配列&lt;x1/&gt;A&lt;x2/&gt;を通過させること。 (例えば、&lt;x5/&gt;Float64&lt;x6/&gt;アレイを、解釈されていないバイトで動作する関数に渡すために) は、引数を&lt;x7/&gt;Ptr{Cvoid}&lt;x8/&gt;として宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run a certain code before terminating a Julia script,
which may or may not be caused by CTRL-C, use &lt;x5/&gt;`atexit`&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024910Z" creationid="hsugawa8651" creationdate="20181110T024910Z">
        <seg>Juliaスクリプトを終了する前に特定のコードを実行するには、次の手順を実行します。 これは、CTRL-Cによって引き起こされることもないこともあれば、引き起こされることもないことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run code in a file non-interactively, you can give it as the first
argument to the &lt;c0&gt;&lt;s1&gt;julia&lt;/s1&gt;&lt;/c0&gt; command:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084022Z" creationid="hsugawa8651" creationdate="20181118T084022Z">
        <seg>ファイルに書かれたコードをインタラクティブではない方法で実行するには、以下のようにファイル名をjuliaコマンドの第1引数とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run code in a file non-interactively, you can give it as the first argument to the &lt;x1/&gt;julia&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091703Z" creationid="hsugawa8651" creationdate="20181109T224323Z">
        <seg>ファイルに書かれたコードをインタラクティブではない方法で実行するには、以下のようにファイル名を&lt;x1/&gt;julia&lt;x2/&gt;コマンドの第1引数とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see the various ways we can pass dimensions to these constructors, consider the following examples:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154524Z" creationid="hsugawa8651" creationdate="20181109T154524Z">
        <seg>これらのコンストラクタに次元を渡すことができるさまざまな方法を確認するには、次の例を考慮してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To solve this problem, the language provides syntax for writing normal, non-generated
alternative implementations of generated functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032351Z" creationid="hsugawa8651" creationdate="20181116T032351Z">
        <seg>この問題を解決するために、言語は、生成されていない通常の言語を記述するための構文を提供します。 生成された関数の代替実装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To sort an array in-place, use the "bang" version of the sort function:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063731Z" creationid="hsugawa8651" creationdate="20181112T044840Z">
        <seg>配列をインプレイスにソートするには、ソート関数の「bang」バージョンを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use module functions, use &lt;x1/&gt;import Module&lt;x2/&gt; to import the module, and &lt;x3/&gt;Module.fn(x)&lt;x4/&gt; to use the
functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041713Z" creationid="hsugawa8651" creationdate="20181110T041659Z">
        <seg>モジュール関数を使用するには、&lt;x1/&gt;インポートモジュール&lt;x2/&gt;を使用してモジュールをインポートし、&lt;x3/&gt;モジュール.fn(x)&lt;x4/&gt;を使用して 関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041603Z" creationid="hsugawa8651" creationdate="20181112T041603Z">
        <seg>Tuple&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type &lt;x1/&gt;VecElement{T}&lt;x2/&gt; is intended for building libraries of SIMD operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063637Z" creationid="hsugawa8651" creationdate="20181114T063637Z">
        <seg>タイプ&lt;x1/&gt;VecElement{T}&lt;x2/&gt;はSIMD演算のライブラリを構築することを目的としている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Correspondences:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150612Z" creationid="hsugawa8651" creationdate="20181117T150612Z">
        <seg>タイプ対応:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151219Z" creationid="hsugawa8651" creationdate="20181117T151219Z">
        <seg>タイプパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type and position of these arguments in the list are compiler
specific, where compiler vendors usually default to using &lt;x5/&gt;Csize_t&lt;x6/&gt; as type and append the hidden
arguments at the end of the argument list.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151047Z" creationid="hsugawa8651" creationdate="20181117T151047Z">
        <seg>リストにこれらの引数を入力して配置するには、コンパイラを使用します。 特定の場合、コンパイラ・ベンダーは通常、&lt;x5/&gt;Csize_t&lt;x6/&gt;をタイプとして使用し、非表示を追加します。 引数リストの最後にある引数を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type relations</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041840Z" creationid="hsugawa8651" creationdate="20181110T041840Z">
        <seg>Type relations</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typed array initializers</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134637Z" creationid="hsugawa8651" creationdate="20181117T134637Z">
        <seg>型化された配列初期化装置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types and functions
described here might (and likely will) change in the future.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032156Z" creationid="hsugawa8651" creationdate="20181114T032156Z">
        <seg>タイプと機能 ここで説明することは将来的に変化する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, Julia is able to compile "generic" versions of functions that will work for any
arguments, but with generated functions this is impossible.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032348Z" creationid="hsugawa8651" creationdate="20181116T032348Z">
        <seg>一般的に、Juliaは、すべての関数の「汎用」バージョンをコンパイルできます。 引数は生成されますが、生成された関数を使用することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T{ }&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063131Z" creationid="hsugawa8651" creationdate="20181114T063131Z">
        <seg>T{ }&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T{A}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150639Z" creationid="hsugawa8651" creationdate="20181117T150639Z">
        <seg>T{A}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UInt8&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150904Z" creationid="hsugawa8651" creationdate="20181117T150904Z">
        <seg>UInt8&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary arithmetic -- &lt;x1/&gt;-&lt;x2/&gt;, &lt;x3/&gt;+&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161212Z" creationid="hsugawa8651" creationdate="20181114T161212Z">
        <seg>単項算術--&lt;x1/&gt;-&lt;x2/&gt;,&lt;x3/&gt;+&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Understanding how Julia answers these questions is key to understanding package loading.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152818Z" creationid="hsugawa8651" creationdate="20181117T152818Z">
        <seg>Juliaがこれらの質問に答えることを理解することは、パッケージのロードを理解する上で重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;x1/&gt;E&lt;x2/&gt;, which is equivalent to &lt;x3/&gt;e&lt;x4/&gt; in numeric literals for historical reasons, &lt;x5/&gt;F&lt;x6/&gt; is just another
letter and does not behave like &lt;x7/&gt;f&lt;x8/&gt; in numeric literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111951Z" creationid="hsugawa8651" creationdate="20181112T111951Z">
        <seg>歴史的理由から、数値リテラルで&lt;x3/&gt;e&lt;x4/&gt;と等価な&lt;x1/&gt;E&lt;x2/&gt;とは異なり、&lt;x5/&gt;F&lt;x6/&gt;は単に別個のものである。 文字は数値リテラルで&lt;x7/&gt;f&lt;x8/&gt;のように動作しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C, MATLAB, Perl, Python, and Ruby -- but like Java, and a few other stricter, typed languages
-- it is an error if the value of a conditional expression is anything but &lt;x1/&gt;true&lt;x2/&gt; or &lt;x3/&gt;false&lt;x4/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230035Z" creationid="hsugawa8651" creationdate="20181109T230035Z">
        <seg>Cとは異なり、MATLAB、Perl、Python、Rubyなどですが、Javaと同様に、さらに厳密なタイプの言語もあります。 --条件式の値が&lt;x1/&gt;真&lt;x2/&gt;または&lt;x3/&gt;false&lt;x4/&gt;以外の値である場合はエラーになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike most languages, with the &lt;x1/&gt;notable exception of Python&lt;x2/&gt;,
comparisons can be arbitrarily chained:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030712Z" creationid="hsugawa8651" creationdate="20181114T030712Z">
        <seg>ほとんどの言語とは異なり、&lt;x1/&gt;はPython&lt;x2/&gt;の例外的な例外です。 比較は任意に連鎖させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unnamed structs
are not possible in the translation to Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151146Z" creationid="hsugawa8651" creationdate="20181117T151146Z">
        <seg>名前のない構造体 ジュリアへの翻訳では不可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unobtrusive yet powerful type system</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082831Z" creationid="hsugawa8651" creationdate="20181118T082831Z">
        <seg>控えめかつ強力な型システム
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsigned integers are input and output using the &lt;x1/&gt;0x&lt;x2/&gt; prefix and hexadecimal (base 16) digits
&lt;x3/&gt;0-9a-f&lt;x4/&gt; (the capitalized digits &lt;x5/&gt;A-F&lt;x6/&gt; also work for input).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225306Z" creationid="hsugawa8651" creationdate="20181109T225306Z">
        <seg>符号なし整数は、&lt;x1/&gt;0x&lt;x2/&gt;プレフィックスおよび16進数(base16)桁を使用して入力および出力されます。 &lt;x3/&gt;0 9a f&lt;x4/&gt;(大文字の数字&lt;x5/&gt;A-F&lt;x6/&gt;も入力に有効です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon return, the contents of &lt;x1/&gt;width&lt;x2/&gt; and &lt;x3/&gt;range&lt;x4/&gt; can be retrieved (if they were changed by &lt;x5/&gt;foo&lt;x6/&gt;)
by &lt;x7/&gt;width[]&lt;x8/&gt; and &lt;x9/&gt;range[]&lt;x10/&gt;; that is, they act like zero-dimensional arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151836Z" creationid="hsugawa8651" creationdate="20181117T151836Z">
        <seg>返されると、&lt;x1/&gt;の幅&lt;x2/&gt;と&lt;x3/&gt;の範囲&lt;x4/&gt;の内容が検索される(&lt;x5/&gt;foo&lt;x6/&gt;によって変更された場合)。 &lt;x7/&gt;幅[]&lt;x8/&gt;と&lt;x9/&gt;の範囲[]&lt;x10/&gt;;すなわち、それらは0次元配列のように作用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use dot operators like &lt;x3/&gt;.==&lt;x4/&gt; for elementwise comparisons.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160015Z" creationid="hsugawa8651" creationdate="20181109T160015Z">
        <seg>&lt;x3/&gt;.==&lt;x4/&gt;のようなドット演算子を、要素的比較のために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use native code from system image if available</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224652Z" creationid="hsugawa8651" creationdate="20181109T224652Z">
        <seg>使用可能な場合は、システムイメージからネイティブコードを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined types are as fast and compact as built-ins</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082721Z" creationid="hsugawa8651" creationdate="20181118T082639Z">
        <seg>コンパクトで組み込み型と同等の速度を持つユーザー定義型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a non-boolean value anywhere except
for the last entry in a conditional chain is an error:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230812Z" creationid="hsugawa8651" creationdate="20181109T230812Z">
        <seg>非ブール値を使用する場合は 条件付きチェーンの最後のエントリはエラーになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Utility Collections</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043134Z" creationid="hsugawa8651" creationdate="20181112T043134Z">
        <seg>Utility Collections</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value returned by &lt;x1/&gt;IteratorEltype(IterType)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112335Z" creationid="hsugawa8651" creationdate="20181112T112335Z">
        <seg>&lt;x1/&gt;IteratorEltypeによって返される値&lt;x/&gt;(IterType)&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value returned by &lt;x1/&gt;IteratorSize(IterType)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112254Z" creationid="hsugawa8651" creationdate="20181112T112254Z">
        <seg>&lt;x1/&gt;IteratorSizeによって返される値&lt;x/&gt;(IterType)&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values can be specified as any iterable object, but
will commonly be ranges like &lt;x7/&gt;1:n&lt;x8/&gt; or &lt;x9/&gt;2:(n-1)&lt;x10/&gt;, or explicit arrays of values like &lt;x11/&gt;[1.2, 3.4, 5.7]&lt;x12/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154811Z" creationid="hsugawa8651" creationdate="20181109T154811Z">
        <seg>値は、任意のオブジェクトとして指定することができますが は一般的に&lt;x7/&gt;1:n&lt;x8/&gt;または&lt;x9/&gt;2:(n-1)&lt;x10/&gt;、または&lt;x11/&gt;[1.2、3.4、5.7]&lt;x12/&gt;のような明示的な値の配列である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values which cannot be stored in &lt;x5/&gt;UInt128&lt;x6/&gt; cannot be written as such literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225510Z" creationid="hsugawa8651" creationdate="20181109T225510Z">
        <seg>&lt;x5/&gt;UInt128&lt;x6/&gt;に格納できない値は、そのようなリテラルとは書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vector&lt;x1/&gt; (a.k.a.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063243Z" creationid="hsugawa8651" creationdate="20181114T063243Z">
        <seg>Vector&lt;x1/&gt; (a.k.a.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vectors and multidimensional arrays of integers</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155522Z" creationid="hsugawa8651" creationdate="20181109T155522Z">
        <seg>整数のベクトルおよび多次元配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vector{Int}&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150643Z" creationid="hsugawa8651" creationdate="20181117T150643Z">
        <seg>Vector{Int}&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vector{T} = Array{T,1}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022032Z" creationid="hsugawa8651" creationdate="20181116T022032Z">
        <seg>Vector{T} = Array{T,1}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Versioning</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150115Z" creationid="hsugawa8651" creationdate="20181117T150115Z">
        <seg>Versioning</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Very few operations are implemented specifically for &lt;x15/&gt;Array&lt;x16/&gt; beyond those that are required
for all &lt;x17/&gt;AbstractArray&lt;x18/&gt;s; much of the array library is implemented in a generic
manner that allows all custom arrays to behave similarly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160424Z" creationid="hsugawa8651" creationdate="20181109T160424Z">
        <seg>&lt;x15/&gt;アレイ&lt;x16/&gt;に対しては、必要な動作を超えて実装されているオペレーションはほとんどありません。 すべての&lt;x17/&gt;AbstractArray&lt;x18/&gt;;アレイライブラリの多くは一般的に実装されています。 すべてのカスタム・アレイが同じように動作するようにする方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warning: do not implement these methods if the underlying storage is not actually strided, as it
may lead to incorrect results or segmentation faults.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083508Z" creationid="hsugawa8651" creationdate="20181113T083508Z">
        <seg>警告:基礎となるストレージが実際にはストライドされていない場合は、これらのメソッドを実装しないでください。 誤った結果やセグメント化の障害につながる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also know the number of elements in our sequence, so
we can extend &lt;x7/&gt;`length`&lt;x8/&gt;, too:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094310Z" creationid="hsugawa8651" creationdate="20181118T094310Z">
        <seg>また、シーケンス内のエレメント数も知っています。 &lt;x7/&gt;の長さ&lt;x8/&gt;を拡張することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We believe there are many good reasons to prefer dynamic
languages for these applications, and we do not expect their use to
diminish.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T081351Z" creationid="hsugawa8651" creationdate="20181118T081351Z">
        <seg> 私達はこの分野で動的言語を用いることにたくさんの利点があることを理解していますし、動的言語が使われないようにしたいわけでもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can expose this as an indexing expression &lt;x5/&gt;S[i]&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113049Z" creationid="hsugawa8651" creationdate="20181112T113049Z">
        <seg>これは、インデックス表現&lt;x5/&gt;S[i]&lt;x6/&gt;として公開することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can iterate over all the elements:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112506Z" creationid="hsugawa8651" creationdate="20181112T112506Z">
        <seg>すべての要素を繰り返し処理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can use many of the builtin methods that work with iterables,
like &lt;x1/&gt;`in`&lt;x2/&gt;, or &lt;x3/&gt;`mean`&lt;x4/&gt; and &lt;x5/&gt;`std`&lt;x6/&gt; from the
&lt;x7/&gt;Statistics&lt;x8/&gt; standard library module:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094125Z" creationid="hsugawa8651" creationdate="20181118T094125Z">
        <seg>iterablesで動作する組み込みメソッドの多くを使うことができます。 &lt;x2/&gt;の&lt;x1/&gt;、&lt;x/&gt;、&lt;x3/&gt;、&lt;x4/&gt;、&lt;x6/&gt;'のように &lt;x7/&gt;統計情報&lt;x8/&gt;標準ライブラリモジュール:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can verify that this constructor works and constructs objects that are, in fact, self-referential:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155908Z" creationid="hsugawa8651" creationdate="20181117T155908Z">
        <seg>このコンストラクタが動作し、実際には自己参照であるオブジェクトを構成していることを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We know that the elements in a &lt;x1/&gt;Squares&lt;x2/&gt; sequence will always be &lt;x3/&gt;Int&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112536Z" creationid="hsugawa8651" creationdate="20181112T112536Z">
        <seg>&lt;x1/&gt;2乗&lt;x2/&gt;の配列内の要素は常に&lt;x3/&gt;Int&lt;x4/&gt;であることがわかる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We should mention here that this is far from a complete picture of defining functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T105929Z" creationid="hsugawa8651" creationdate="20181112T105929Z">
        <seg>ここでは、関数を定義する完全な全体像とは程遠いことを説明しておきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What&lt;x1/&gt; package is &lt;x2/&gt;X&lt;x3/&gt; in this context?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152815Z" creationid="hsugawa8651" creationdate="20181117T152815Z">
        <seg>この文脈では&lt;x1/&gt;パッケージは&lt;x2/&gt;X&lt;x3/&gt;であるか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a file is run as the main script using &lt;x1/&gt;julia file.jl&lt;x2/&gt; one might want to activate extra
functionality like command line argument handling.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024843Z" creationid="hsugawa8651" creationdate="20181110T024843Z">
        <seg>&lt;x1/&gt;juliaファイルを使用して、ファイルがメイン・スクリプトとして実行される場合、&lt;x1/&gt;juliaファイル.jl&lt;x2/&gt;を使用して追加のファイルをアクティブ化する必要があります コマンドライン引数の処理などの機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a scalar value is passed with &lt;x1/&gt;&amp;&lt;x2/&gt; as an argument of type &lt;x3/&gt;Ptr{T}&lt;x4/&gt;, the value will first be
converted to type &lt;x5/&gt;T&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151905Z" creationid="hsugawa8651" creationdate="20181117T151905Z">
        <seg>&lt;x3/&gt;Ptr{T}&lt;x4/&gt;の引数として&lt;x1/&gt;&amp;&lt;x2/&gt;とスカラー値を渡すと、まず値が次のようになります。 &lt;x5/&gt;T&lt;x6/&gt;に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an array is passed to C as a &lt;x1/&gt;Ptr{T}&lt;x2/&gt; argument, it is not reinterpret-cast: Julia requires
that the element type of the array matches &lt;x3/&gt;T&lt;x4/&gt;, and the address of the first element is passed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134502Z" creationid="hsugawa8651" creationdate="20181117T134502Z">
        <seg>配列が&lt;x1/&gt;Ptr{T}&lt;x2/&gt;引数としてCに渡されるとき、キャストは再解釈されません:Juliaが必要とする 配列のエレメント・タイプが&lt;x3/&gt;T&lt;x4/&gt;と一致し、最初のエレメントのアドレスが渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When both
libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations
that can even optimize across this boundary, but Julia does not yet support that.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160558Z" creationid="hsugawa8651" creationdate="20181109T160558Z">
        <seg>両方 ライブラリと実行可能ファイルはLLVMによって生成されるため、プログラム全体の最適化を実行することができます。 この境界にわたって最適化することもできますが、ジュリアはまだサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When chaining conditionals (including &lt;x1/&gt;if&lt;x2/&gt;/&lt;x3/&gt;elseif&lt;x4/&gt;/&lt;x5/&gt;end&lt;x6/&gt;), the &lt;x7/&gt;@static&lt;x8/&gt; must be repeated for
each level (parentheses optional, but recommended for readability):</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225006Z" creationid="hsugawa8651" creationdate="20181109T225006Z">
        <seg>&lt;x2/&gt;/&lt;x3/&gt;&lt;x6/&gt;/&lt;x5/&gt;の場合は、&lt;x7/&gt;@static&lt;x8/&gt;を繰り返す必要があります。&lt;x x/&gt;&lt;x8/&gt;&lt;x8/&gt;&lt;x6/&gt;&lt;x8/&gt;は 各レベル(オプションではありますが、読みやすさには推奨されます):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When combined with other indexing forms and iterators
that yield &lt;x3/&gt;CartesianIndex&lt;x4/&gt;es, however, this can produce very elegant
and efficient code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155632Z" creationid="hsugawa8651" creationdate="20181109T155632Z">
        <seg>他のインデックス作成フォームおよびイテレータと組み合わされた場合 しかし、それは&lt;x3/&gt;CartesianIndex&lt;x4/&gt;の収量をもたらすが、これは非常にエレガントなものである。 効率的なコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When mirroring a struct used by-value inside another struct in C, it is imperative
that you do not attempt to manually copy the fields over, as this will not preserve the correct
field alignment.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151142Z" creationid="hsugawa8651" creationdate="20181117T151142Z">
        <seg>Cの別の構造体内の値で使用される構造体をミラーリングする場合は、それは必須です。 フィールドを手動でコピーしないようにします。これは、正しいフィールドを保持しないためです。 フィールドの位置合わせ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When passing data to a &lt;x1/&gt;`ccall`&lt;x2/&gt;, it is best to avoid using the &lt;x3/&gt;`pointer`&lt;x4/&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152227Z" creationid="hsugawa8651" creationdate="20181117T152227Z">
        <seg>&lt;x1/&gt;"ccall"&lt;x2/&gt;"にデータを渡す場合は、&lt;x3/&gt;'ポインタ''&lt;x4/&gt;関数を使用しないことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When run in interactive
mode, &lt;c6&gt;&lt;s7&gt;julia&lt;/s7&gt;&lt;/c6&gt; displays a banner and prompts the user for input.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T084338Z" creationid="hsugawa8651" creationdate="20181118T083908Z">
        <seg>インタラクティブ・モードで起動すると、 &lt;c6&gt;&lt;s7&gt;julia&lt;/s7&gt;&lt;/c6&gt; のバナーが表示され、プロンプトがユーザーの入力を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When run in interactive mode, &lt;x9/&gt;julia&lt;x10/&gt; displays a banner and prompts the user for input.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T091404Z" creationid="hsugawa8651" creationdate="20181109T224306Z">
        <seg>インタラクティブ・モードで起動すると、 &lt;x9/&gt;julia&lt;x10/&gt; のバナーが表示され、プロンプトがユーザーの入力を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the array is subsequently
indexed with a multidimensional set of indices, the fallback &lt;x2/&gt;getindex(A::AbstractArray, I...)()&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083148Z" creationid="hsugawa8651" creationdate="20181113T083148Z">
        <seg>アレイが次に 索引の多次元集合でインデックスを作成します。フォールバック&lt;x2/&gt;getindex(A::AbstractArray, I...)()&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When to use T, Ptr{T} and Ref{T}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151437Z" creationid="hsugawa8651" creationdate="20181117T151437Z">
        <seg>Tを使用する場合は、Ptr{T}およびRef{T}を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When translating your fields to Julia, declare
the Julia field to be only of that type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151152Z" creationid="hsugawa8651" creationdate="20181117T151152Z">
        <seg>フィールドをジュリアに変換するときは、次のように宣言します。 Juliaフィールドはそのタイプのみであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as a
function it has two possible forms, unary (single-argument) and binary.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131120Z" creationid="hsugawa8651" creationdate="20181113T131120Z">
        <seg>使用する場合 関数は、単項(単一引数)とバイナリの2つの可能な形式を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used recursively, &lt;x1/&gt;isbits&lt;x2/&gt; types are stored inline.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151137Z" creationid="hsugawa8651" creationdate="20181117T151137Z">
        <seg>再帰的に使用される場合、&lt;x1/&gt;イスビトス&lt;x2/&gt;タイプはインラインに格納される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing a generator expression with multiple dimensions inside an argument list, parentheses
are needed to separate the generator from subsequent arguments:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154940Z" creationid="hsugawa8651" creationdate="20181109T154940Z">
        <seg>引数リスト内に複数の次元を持つジェネレータ式を記述する場合は、括弧を使用します。 ジェネレータを次の引数から分離する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing cross-platform applications or libraries, it is often necessary to allow for
differences between operating systems.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093219Z" creationid="hsugawa8651" creationdate="20181109T224823Z">
        <seg>クロスプラットフォームアプリケーションやライブラリを記述する場合は、 オペレーティング・システム間の違いを許す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you created &lt;x11/&gt;Priv&lt;x12/&gt;, there was no public package by that name.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152852Z" creationid="hsugawa8651" creationdate="20181117T152852Z">
        <seg>&lt;x11/&gt;Priv&lt;x12/&gt;を作成すると、その名前ではパブリックパッケージは作成されませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you pass this &lt;x5/&gt;Ref&lt;x6/&gt; object
as an argument, Julia will automatically pass a C pointer to the encapsulated data:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151830Z" creationid="hsugawa8651" creationdate="20181117T151830Z">
        <seg>この&lt;x5/&gt;Ref&lt;x6/&gt;オブジェクトを渡すと 引数として、Juliaは自動的にCポインタをカプセル化されたデータに渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When your broadcast operation involves several arguments, individual argument styles get
combined to determine a single &lt;x1/&gt;DestStyle&lt;x2/&gt; that controls the type of the output container.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131249Z" creationid="hsugawa8651" creationdate="20181113T131249Z">
        <seg>ブロードキャスト操作に複数の引数が含まれる場合、個々の引数スタイルは次のようになります。 結合して、出力コンテナのタイプを制御する単一の&lt;x1/&gt;DestStyle&lt;x2/&gt;を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you have created a pointer to Julia data, you must ensure the original data exists until
you are done with using the pointer.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152241Z" creationid="hsugawa8651" creationdate="20181117T152241Z">
        <seg>Juliaデータへのポインタを作成したときは必ず、元のデータが存在することを確認する必要があります。 ポインタを使用して終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you subtype &lt;x1/&gt;AbstractArrayStyle&lt;x2/&gt;, you also need to define rules for combining
dimensionalities, by creating a constructor for your style that takes a &lt;x3/&gt;Val(N)&lt;x4/&gt; argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131857Z" creationid="hsugawa8651" creationdate="20181113T131857Z">
        <seg>&lt;x1/&gt;AbstractArrayStyle&lt;x2/&gt;をサブタイプ化する場合は必ず、結合するルールを定義する必要があります。 &lt;x3/&gt;Val(N)&lt;x4/&gt;引数を取るスタイルのコンストラクタを作成することによって、次元性を実現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where&lt;x1/&gt; can that &lt;x2/&gt;X&lt;x3/&gt; package be found?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152817Z" creationid="hsugawa8651" creationdate="20181117T152817Z">
        <seg>&lt;x1/&gt;は&lt;x2/&gt;X&lt;x3/&gt;パッケージが存在する可能性がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While outer constructor methods succeed in addressing the problem of providing additional convenience
methods for constructing objects, they fail to address the other two use cases mentioned in the
introduction of this chapter: enforcing invariants, and allowing construction of self-referential
objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155732Z" creationid="hsugawa8651" creationdate="20181117T155732Z">
        <seg>外部コンストラクタのメソッドは、追加の利便性を提供する問題に対処することに成功しています。 オブジェクトを構築するためのメソッドです。これらのメソッドは、次の2つのユースケースに対応しています。 この章の導入:インバリアントの適用、自己参照の可能化 オブジェクトを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the casual programmer need not explicitly use types or multiple
dispatch, they are the core unifying features of Julia: functions are
defined on different combinations of argument types, and applied by
dispatching to the most specific matching definition.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T082337Z" creationid="hsugawa8651" creationdate="20181118T082337Z">
        <seg>カジュアルプログラマは型や多重ディスパッチを明示的に使う必要はありませんが、これらはJuliaの基礎となる機能です。 関数はさまざまな引数の組み合わせに対して定義され、実行時には最も当てはまる定義が適用されます。 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this behaviour is fixed for some compilers (GNU),
others &lt;x7/&gt;optionally&lt;x8/&gt; permit placing hidden arguments directly after the character argument (Intel,PGI).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151051Z" creationid="hsugawa8651" creationdate="20181117T151051Z">
        <seg>この動作は、いくつかのコンパイラ(GNU)では修正されています。 他の&lt;x7/&gt;オプション&lt;x8/&gt;は、文字引数(インテル、PGI)の直後に、非表示の引数を直接配置することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this can be inconvenient when you are developing new code, there's an excellent workaround.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024734Z" creationid="hsugawa8651" creationdate="20181110T024734Z">
        <seg>これは、新しいコードを開発する際に不便な場合がありますが、優れた回避策があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this is starting to support more of the &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-array-indexing),
there's still quite a number of behaviors missing.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094342Z" creationid="hsugawa8651" creationdate="20181118T094342Z">
        <seg>これは、&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man array indexing)のより多くのサポートを開始しています。 まだ多くの行動が失われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we can rely upon generic implementations, we can also extend specific methods where we know
there is a simpler algorithm.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112745Z" creationid="hsugawa8651" creationdate="20181112T112745Z">
        <seg>一般的な実装に依存することもできますが、特定の方法を拡張することもできます。 より単純なアルゴリズムがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>William Kahan&lt;x1/&gt;, commonly known as the "Father
of Floating-Point".</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111531Z" creationid="hsugawa8651" creationdate="20181112T111531Z">
        <seg>ウィリアム・カハン&lt;x1/&gt;、通称「父」 浮動小数点の値を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With only &lt;x1/&gt;`iterate`&lt;x2/&gt; definition, the &lt;x3/&gt;Squares&lt;x4/&gt; type is already pretty powerful.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112503Z" creationid="hsugawa8651" creationdate="20181112T112503Z">
        <seg>&lt;x1/&gt;'reiterate''&lt;x2/&gt;定義では、&lt;x3/&gt;Squares&lt;x4/&gt;タイプはすでにかなり強力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without any specifier, the platform-default C calling convention is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152420Z" creationid="hsugawa8651" creationdate="20181117T152420Z">
        <seg>指定されていない場合は、プラットフォームデフォルトのC呼び出し規約が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without parentheses, the expression &lt;x1/&gt;f&lt;x2/&gt; refers to the function object, and can be passed around
like any value:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025632Z" creationid="hsugawa8651" creationdate="20181110T025632Z">
        <seg>括弧なしでは、式&lt;x1/&gt;f&lt;x2/&gt;は関数オブジェクトを参照しており、この関数オブジェクトを渡すことができます。 どの値でも</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X = A[I_1, I_2, ..., I_n]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160712Z" creationid="hsugawa8651" creationdate="20181114T160712Z">
        <seg>X = A[I_1, I_2, ..., I_n]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X = getindex(A, I_1, I_2, ..., I_n)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155300Z" creationid="hsugawa8651" creationdate="20181109T155300Z">
        <seg>X = getindex(A, I_1, I_2, ..., I_n)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X = sin(cos(Y)) &lt;x2/&gt; equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030245Z" creationid="hsugawa8651" creationdate="20181110T030245Z">
        <seg>X = sin(cos(Y)) &lt;x2/&gt; equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X[i] = v&lt;x1/&gt;, indexed assignment</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113006Z" creationid="hsugawa8651" creationdate="20181112T113006Z">
        <seg>X[i] = v&lt;x1/&gt;, indexed assignment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X[i]&lt;x1/&gt;, indexed element access</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112959Z" creationid="hsugawa8651" creationdate="20181112T112959Z">
        <seg>X[i]&lt;x1/&gt;, indexed element access</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You (or someone else) can also provide additional outer constructor methods at any later point, but
once a type is declared, there is no way to add more inner constructor methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155800Z" creationid="hsugawa8651" creationdate="20181117T155800Z">
        <seg>また、別の時点で外部コンストラクタのメソッドを追加することもできます。 タイプが宣言されると、インナー・コンストラクタ・メソッドを追加する方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are responsible for implementing the
broadcasting shape rules yourself, but this may be helpful in limited situations.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131727Z" creationid="hsugawa8651" creationdate="20181113T131727Z">
        <seg>あなたは 放送の形状ルールは自分自身であるが、これは限られた状況では役に立つかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also combine dot operations with function chaining using &lt;x1/&gt;`|&gt;`&lt;x2/&gt;, as in this example:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T105918Z" creationid="hsugawa8651" creationdate="20181112T105918Z">
        <seg>また、次の例のように、ドット操作を&lt;x1/&gt;`&lt;x2/&gt;を使って関数連鎖と組み合わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also find the numerical precedence for any given operator via the built-in function &lt;x1/&gt;Base.operator_precedence&lt;x2/&gt;, where higher numbers take precedence:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030952Z" creationid="hsugawa8651" creationdate="20181114T030952Z">
        <seg>また、組み込み関数&lt;x1/&gt;Base.operator_precedence&lt;x2/&gt;を使用して、任意の演算子の優先順位を検索することもできます。ここでは、より高い数値が優先されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also return multiple values via an explicit usage of the &lt;x1/&gt;return&lt;x2/&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T101528Z" creationid="hsugawa8651" creationdate="20181112T101528Z">
        <seg>また、&lt;x1/&gt;return&lt;x2/&gt;キーワードを明示的に使用して、複数の値を返すこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can easily experiment in the same way with the associativity and precedence of various combinations
of &lt;x1/&gt;&amp;&amp;&lt;x2/&gt; and &lt;x3/&gt;||&lt;x4/&gt; operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230405Z" creationid="hsugawa8651" creationdate="20181109T230405Z">
        <seg>さまざまな組み合わせのアソシエティビティと優先順位によって、同じ方法で簡単に実験することができます。 &lt;x1/&gt;&amp;&amp;&lt;x2/&gt;および&lt;x3/&gt;&lt;x4/&gt;演算子のことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can easily sort in reverse order as well:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150310Z" creationid="hsugawa8651" creationdate="20181117T150310Z">
        <seg>逆順でも簡単にソートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get a near approximation of a &lt;x1/&gt;union&lt;x2/&gt; if you know, a priori, the field that will have
the greatest size (potentially including padding).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151150Z" creationid="hsugawa8651" creationdate="20181117T151150Z">
        <seg>&lt;x1/&gt;の近似を知ることができるのなら、それは&lt;x x/&gt;&lt;x2/&gt;の近似値を得ることができる。 最大サイズ(パディングを含む可能性があります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't import the type names into &lt;x1/&gt;Main&lt;x2/&gt; and then expect
to be able to redefine them there, but you can use the module name to resolve the scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024742Z" creationid="hsugawa8651" creationdate="20181110T024742Z">
        <seg>&lt;x1/&gt;メイン&lt;x2/&gt;にはタイプ名をインポートできないので、次のように入力することはできません。 で再定義することができますが、このモジュール名を使用してスコープを解決することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could also add a zero-argument &lt;x1/&gt;Foo&lt;x2/&gt; constructor method that supplies default values for both
of the &lt;x3/&gt;bar&lt;x4/&gt; and &lt;x5/&gt;baz&lt;x6/&gt; fields:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155715Z" creationid="hsugawa8651" creationdate="20181117T155715Z">
        <seg>また、0つの引数&lt;x1/&gt;Foo&lt;x2/&gt;コンストラクタメソッドを追加して、両方のデフォルト値を指定することもできます。 &lt;x3/&gt;bar&lt;x4/&gt;および&lt;x5/&gt;baz&lt;x6/&gt;の各フィールドのうち、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not need to write binary &lt;x1/&gt;BroadcastStyle&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131836Z" creationid="hsugawa8651" creationdate="20181113T131836Z">
        <seg>バイナリの&lt;x1/&gt;BroadcastStyle&lt;x2/&gt;を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might want broadcasting to preserve the &lt;x1/&gt;char&lt;x2/&gt; "metadata." First we define</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131414Z" creationid="hsugawa8651" creationdate="20181113T131414Z">
        <seg>&lt;x1/&gt;char&lt;x2/&gt;"メタデータを保存するためにブロードキャストを行うことができます。まず、次のように定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must be
careful in this case to ensure that the object was always visible to the garbage collector (pointers
do not count, but the new reference does) to ensure the memory is not prematurely freed.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152541Z" creationid="hsugawa8651" creationdate="20181117T152541Z">
        <seg>あなたは この場合は、オブジェクトが常にガーベッジ・コレクターに表示されるように注意する必要があります。 メモリが初期解放されていないことを確認するために、この新しい参照はカウントしませんが、新しい参照は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must ensure that this return object is kept alive until all uses of it are done.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152342Z" creationid="hsugawa8651" creationdate="20181117T152342Z">
        <seg>この戻りオブジェクトは、すべての使用が完了するまで生きていることを確認する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You refer to the
&lt;x5/&gt;Foo&lt;x6/&gt; symbols by their qualified names &lt;x7/&gt;Foo.bar&lt;x8/&gt; etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025154Z" creationid="hsugawa8651" creationdate="20181110T025154Z">
        <seg>ここでは &lt;x5/&gt;Foo&lt;x6/&gt;記号は、それらの修飾名&lt;x7/&gt;Foo.bar&lt;x8/&gt;などで表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should also specialize &lt;x3/&gt;`similar`&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094540Z" creationid="hsugawa8651" creationdate="20181118T094540Z">
        <seg>また、&lt;x3/&gt;`similar`&lt;x4/&gt;を特化する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll either need a new interactive session instance or a different variable
name to test this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T231201Z" creationid="hsugawa8651" creationdate="20181109T231201Z">
        <seg>新しい対話型セッション・インスタンスまたは別の変数が必要です。 テストする名前:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[    ]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063120Z" creationid="hsugawa8651" creationdate="20181114T063120Z">
        <seg>[    ]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[,]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063035Z" creationid="hsugawa8651" creationdate="20181114T063035Z">
        <seg>[,]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[;]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063106Z" creationid="hsugawa8651" creationdate="20181114T063106Z">
        <seg>[;]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[A B C ...]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025839Z" creationid="hsugawa8651" creationdate="20181110T025839Z">
        <seg>[A B C ...]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[A B; C D; ...]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025852Z" creationid="hsugawa8651" creationdate="20181110T025852Z">
        <seg>[A B; C D; ...]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[A; B; C; ...]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025846Z" creationid="hsugawa8651" creationdate="20181110T025846Z">
        <seg>[A; B; C; ...]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[[Priv]] &lt;x1/&gt; the private one
deps = ["Pub", "Zebra"]
uuid = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
path = "deps/Priv"

[[Priv]] &lt;x2/&gt; the public one
uuid = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
git-tree-sha1 = "1bf63d3be994fe83456a03b874b409cfd59a6373"
version = "0.1.5"

[[Pub]]
uuid = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"
git-tree-sha1 = "9ebd50e2b0dd1e110e842df3b433cb5869b0dd38"
version = "2.1.4"

  [Pub.deps]
  Priv = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
  Zebra = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"

[[Zebra]]
uuid = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"
git-tree-sha1 = "e808e36a5d7173974b90a15a353b564f3494092f"
version = "3.4.2"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015908Z" creationid="hsugawa8651" creationdate="20181116T015908Z">
        <seg>[[Priv]] &lt;x1/&gt; the private one
deps = ["Pub", "Zebra"]
uuid = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
path = "deps/Priv"

[[Priv]] &lt;x2/&gt; the public one
uuid = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
git-tree-sha1 = "1bf63d3be994fe83456a03b874b409cfd59a6373"
version = "0.1.5"

[[Pub]]
uuid = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"
git-tree-sha1 = "9ebd50e2b0dd1e110e842df3b433cb5869b0dd38"
version = "2.1.4"

  [Pub.deps]
  Priv = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
  Zebra = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"

[[Zebra]]
uuid = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"
git-tree-sha1 = "e808e36a5d7173974b90a15a353b564f3494092f"
version = "3.4.2"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063012Z" creationid="hsugawa8651" creationdate="20181114T063012Z">
        <seg>\&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\|&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032327Z" creationid="hsugawa8651" creationdate="20181114T032327Z">
        <seg>\|&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\|\|&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032330Z" creationid="hsugawa8651" creationdate="20181114T032330Z">
        <seg>\|\|&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032311Z" creationid="hsugawa8651" creationdate="20181114T032311Z">
        <seg>^&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>` ` &lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063522Z" creationid="hsugawa8651" creationdate="20181114T063522Z">
        <seg>` ` &lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`!=`&lt;x1/&gt;, &lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref !=)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132703Z" creationid="hsugawa8651" creationdate="20181113T132703Z">
        <seg>`!=`&lt;x1/&gt;, &lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref !=)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`&lt;=`&lt;x1/&gt;, &lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref &lt;=)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030437Z" creationid="hsugawa8651" creationdate="20181114T030437Z">
        <seg>`&lt;=`&lt;x1/&gt;, &lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref &lt;=)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`&lt;`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132713Z" creationid="hsugawa8651" creationdate="20181113T132713Z">
        <seg>`&lt;`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`==`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132659Z" creationid="hsugawa8651" creationdate="20181113T132659Z">
        <seg>`==`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`&gt;=`&lt;x1/&gt;, &lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref &gt;=)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030427Z" creationid="hsugawa8651" creationdate="20181114T030427Z">
        <seg>`&gt;=`&lt;x1/&gt;, &lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref &gt;=)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`&gt;`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030422Z" creationid="hsugawa8651" creationdate="20181114T030422Z">
        <seg>`&gt;`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`@cfunction`&lt;x1/&gt; requires three arguments: the Julia function (&lt;x2/&gt;mycompare&lt;x3/&gt;), the return type
(&lt;x4/&gt;Cint&lt;x5/&gt;), and a literal tuple of the input argument types, in this case to sort an array of &lt;x6/&gt;Cdouble&lt;x7/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T145915Z" creationid="hsugawa8651" creationdate="20181117T145915Z">
        <seg>`@cfunction&lt;x1/&gt;は3つの引数を必要とします:Julia関数(&lt;x2/&gt;ミコンパレ&lt;x3/&gt;)、戻り値のタイプ (&lt;x4/&gt;Cint&lt;x5/&gt;)と、入力引数型のリテラルタプルで、この場合は&lt;x6/&gt;Cdouble&lt;x7/&gt;の配列をソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`AbstractArray`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041605Z" creationid="hsugawa8651" creationdate="20181112T041605Z">
        <seg>`AbstractArray`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`AbstractRange`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041600Z" creationid="hsugawa8651" creationdate="20181112T041600Z">
        <seg>`AbstractRange`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Array`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041650Z" creationid="hsugawa8651" creationdate="20181112T041650Z">
        <seg>`Array`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Array{T}(undef, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064354Z" creationid="hsugawa8651" creationdate="20181114T064354Z">
        <seg>`Array{T}(undef, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Base.cconvert`&lt;x1/&gt; normally just calls &lt;x2/&gt;`convert`&lt;x3/&gt;, but can be defined to return an
arbitrary new object more appropriate for passing to C.
This should be used to perform all allocations of memory that will be accessed by the C code.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150605Z" creationid="hsugawa8651" creationdate="20181117T150605Z">
        <seg>'Base.チコンベルト'&lt;x1/&gt;は通常、&lt;x2/&gt;'convert`&lt;x3/&gt;を呼び出しますが、次のように定義することができます。 任意の新しいオブジェクトを渡すには、任意の新しいオブジェクトが必要です。 これは、Cコードによってアクセスされるメモリーのすべての割り当てを実行するために使用される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Base.cconvert`&lt;x1/&gt; normally just calls &lt;x2/&gt;`convert`&lt;x3/&gt;, but can be defined to return an
arbitrary new object more appropriate for passing to C.
This should be used to perform all allocations of memory that will be accessed by the C code.
For example, this is used to convert an &lt;x4/&gt;Array&lt;x5/&gt; of objects (e.g. strings) to an array of pointers.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134302Z" creationid="hsugawa8651" creationdate="20181117T134302Z">
        <seg>'Base.チコンベルト'&lt;x1/&gt;は通常、&lt;x2/&gt;'convert`&lt;x3/&gt;を呼び出しますが、次のように定義することができます。 任意の新しいオブジェクトを渡すには、任意の新しいオブジェクトが必要です。 これは、Cコードによってアクセスされるメモリーのすべての割り当てを実行するために使用される必要があります。 たとえば、これは、オブジェクトの&lt;x4/&gt;配列&lt;x5/&gt;をポインタの配列に変換するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Base.cconvert`&lt;x1/&gt; version.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150829Z" creationid="hsugawa8651" creationdate="20181117T150829Z">
        <seg>`Base.cconvert`&lt;x1/&gt; version.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Base.cconvert`&lt;x1/&gt; version. This allows, for example, passing an &lt;x2/&gt;argv&lt;x3/&gt; pointer array of type
&lt;x4/&gt;Vector{String}&lt;x5/&gt; to an argument of type &lt;x6/&gt;Ptr{Ptr{Cchar}}&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T140907Z" creationid="hsugawa8651" creationdate="20181117T140907Z">
        <seg>'Base.チコンベルト'&lt;x1/&gt;バージョン。これにより、例えば、&lt;x2/&gt;argv&lt;x3/&gt;ポインタ配列を渡すことができます。 &lt;x4/&gt;Vector{String}&lt;x5/&gt;は、&lt;x6/&gt;Ptr{Ptr{Cchar}}&lt;x7/&gt;の型を引数にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Base.unsafe_convert`&lt;x1/&gt; handles conversion to &lt;x2/&gt;`Ptr`&lt;x3/&gt; types.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150609Z" creationid="hsugawa8651" creationdate="20181117T150609Z">
        <seg>'Base.unsafe_convert'&lt;x1/&gt;は、&lt;x2/&gt;`Ptr'&lt;x3/&gt;型への変換を処理する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Base.unsafe_convert`&lt;x1/&gt; handles conversion to &lt;x2/&gt;`Ptr`&lt;x3/&gt; types. It is considered unsafe because
converting an object to a native pointer can hide the object from the garbage collector, causing
it to be freed prematurely.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134306Z" creationid="hsugawa8651" creationdate="20181117T134306Z">
        <seg>'Base.unsafe_convert'&lt;x1/&gt;は、&lt;x2/&gt;`Ptr'&lt;x3/&gt;型への変換を処理します。安全ではないと考えられます。 オブジェクトをネイティブ・ポインタに変換すると、ガーベッジ・コレクターからオブジェクトを非表示にすることができます。 早期に解放することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`BitArray`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041651Z" creationid="hsugawa8651" creationdate="20181112T041651Z">
        <seg>`BitArray`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`BitArray`&lt;x1/&gt;s are space-efficient "packed" boolean arrays, which store one bit per boolean value.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160448Z" creationid="hsugawa8651" creationdate="20181109T160448Z">
        <seg>「BitArray」&lt;x1/&gt;は、ブール値ごとに1ビットを格納するスペース効率の高い「パックされた」ブール演算配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`BitArray`&lt;x1/&gt;s are space-efficient "packed" boolean arrays, which store one bit per boolean value.
They can be used similarly to &lt;x2/&gt;Array{Bool}&lt;x3/&gt; arrays (which store one byte per boolean value),
and can be converted to/from the latter via &lt;x4/&gt;Array(bitarray)&lt;x5/&gt; and &lt;x6/&gt;BitArray(array)&lt;x7/&gt;, respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135407Z" creationid="hsugawa8651" creationdate="20181117T135407Z">
        <seg>「BitArray」&lt;x1/&gt;は、ブール値ごとに1ビットを格納するスペース効率の高い「パックされた」ブール演算配列です。 これらは、&lt;x2/&gt;Array{Bool}&lt;x3/&gt;配列(ブール値ごとに1バイトを格納する)と同様に使用できます。 また、&lt;x4/&gt;アレイ(bitarray)&lt;x5/&gt;および&lt;x6/&gt;BitArray(配列)&lt;x7/&gt;を介して、後者との間で変換を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`BitSet`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041606Z" creationid="hsugawa8651" creationdate="20181112T041606Z">
        <seg>`BitSet`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Bool`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110217Z" creationid="hsugawa8651" creationdate="20181112T110217Z">
        <seg>`Bool`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`CartesianIndex{N}`&lt;x1/&gt;s, which behave like an &lt;x2/&gt;N&lt;x3/&gt;-tuple of integers spanning multiple dimensions (see below for more details)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155514Z" creationid="hsugawa8651" creationdate="20181109T155514Z">
        <seg>「CartesianIndex{N}」&lt;x1/&gt;は、複数の次元を超える整数の&lt;x2/&gt;N&lt;x3/&gt;のように動作します(詳細については以下を参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Colon()`&lt;x1/&gt; (&lt;x2/&gt;:&lt;x3/&gt;), which represents all indices within an entire dimension or across the entire array</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155540Z" creationid="hsugawa8651" creationdate="20181109T155540Z">
        <seg>「コロン()」&lt;x1/&gt;(&lt;x2/&gt;:&lt;x3/&gt;)は、全次元または配列全体にわたってすべてのインデックスを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Dict`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041609Z" creationid="hsugawa8651" creationdate="20181112T041609Z">
        <seg>`Dict`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Dict`&lt;x1/&gt; is the standard dictionary.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041718Z" creationid="hsugawa8651" creationdate="20181112T041718Z">
        <seg>「Dict」&lt;x1/&gt;は標準辞書です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Dict`&lt;x1/&gt;s can be created by passing pair objects constructed with &lt;x2/&gt;=&gt;&lt;x3/&gt; to a &lt;x4/&gt;`Dict`&lt;x5/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041731Z" creationid="hsugawa8651" creationdate="20181112T041731Z">
        <seg>「Dict」&lt;x1/&gt;は、&lt;x2/&gt;=&gt;&lt;x3/&gt;で構成されたペアオブジェクトを、&lt;x4/&gt;'Dict'&lt;x5/&gt;に渡すことで作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ENDIAN_BOM`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043202Z" creationid="hsugawa8651" creationdate="20181112T043202Z">
        <seg>`ENDIAN_BOM`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ENV`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063251Z" creationid="hsugawa8651" creationdate="20181114T063251Z">
        <seg>`ENV`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Float16`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110230Z" creationid="hsugawa8651" creationdate="20181112T110230Z">
        <seg>`Float16`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Float32`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110233Z" creationid="hsugawa8651" creationdate="20181112T110233Z">
        <seg>`Float32`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Float64`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110237Z" creationid="hsugawa8651" creationdate="20181112T110237Z">
        <seg>`Float64`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`IdDict`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041608Z" creationid="hsugawa8651" creationdate="20181112T041608Z">
        <seg>`IdDict`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`IdDict`&lt;x1/&gt; is a special hash table where the keys are always object identities.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041725Z" creationid="hsugawa8651" creationdate="20181112T041725Z">
        <seg>「IdDict」&lt;x1/&gt;は、鍵が常にオブジェクト識別子である特殊なハッシュ表です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`InsertionSort`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064003Z" creationid="hsugawa8651" creationdate="20181114T064003Z">
        <seg>`InsertionSort`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Int128`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110206Z" creationid="hsugawa8651" creationdate="20181112T110206Z">
        <seg>`Int128`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Int16`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110129Z" creationid="hsugawa8651" creationdate="20181112T110129Z">
        <seg>`Int16`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Int64`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110156Z" creationid="hsugawa8651" creationdate="20181112T110156Z">
        <seg>`Int64`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Int8`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110036Z" creationid="hsugawa8651" creationdate="20181112T110036Z">
        <seg>`Int8`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Iterators.Pairs`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041819Z" creationid="hsugawa8651" creationdate="20181112T041819Z">
        <seg>`Iterators.Pairs`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Iterators.reverse(iterator)`&lt;x1/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112900Z" creationid="hsugawa8651" creationdate="20181112T112900Z">
        <seg>`Iterators.reverse(iterator)`&lt;x1/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Matrix{T}(I, m, n)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064433Z" creationid="hsugawa8651" creationdate="20181114T064433Z">
        <seg>`Matrix{T}(I, m, n)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`MergeSort`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064007Z" creationid="hsugawa8651" creationdate="20181114T064007Z">
        <seg>`MergeSort`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Meta.@dump`&lt;x1/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015121Z" creationid="hsugawa8651" creationdate="20181116T015121Z">
        <seg>`Meta.@dump`&lt;x1/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`NamedTuple`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041616Z" creationid="hsugawa8651" creationdate="20181112T041616Z">
        <seg>`NamedTuple`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Pair`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041615Z" creationid="hsugawa8651" creationdate="20181112T041615Z">
        <seg>`Pair`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`PartialQuickSort(k)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064006Z" creationid="hsugawa8651" creationdate="20181114T064006Z">
        <seg>`PartialQuickSort(k)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Ptr`&lt;x1/&gt;) as a "scalar".</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150452Z" creationid="hsugawa8651" creationdate="20181117T150450Z">
        <seg>「Ptr」&lt;x1/&gt;は「スカラー」である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`QuickSort`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064004Z" creationid="hsugawa8651" creationdate="20181114T064004Z">
        <seg>`QuickSort`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Set`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041614Z" creationid="hsugawa8651" creationdate="20181112T041614Z">
        <seg>`Set`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`UInt128`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110212Z" creationid="hsugawa8651" creationdate="20181112T110212Z">
        <seg>`UInt128`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`UInt16`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110135Z" creationid="hsugawa8651" creationdate="20181112T110135Z">
        <seg>`UInt16`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`UInt32`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110152Z" creationid="hsugawa8651" creationdate="20181112T110152Z">
        <seg>`UInt32`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`UInt64`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110202Z" creationid="hsugawa8651" creationdate="20181112T110202Z">
        <seg>`UInt64`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`UInt8`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110124Z" creationid="hsugawa8651" creationdate="20181112T110124Z">
        <seg>`UInt8`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`UnitRange`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041602Z" creationid="hsugawa8651" creationdate="20181112T041602Z">
        <seg>`UnitRange`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`WeakKeyDict`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041610Z" creationid="hsugawa8651" creationdate="20181112T041610Z">
        <seg>`WeakKeyDict`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`WeakKeyDict`&lt;x1/&gt; is a hash table implementation where the keys are weak references to objects, and
thus may be garbage collected even when referenced in a hash table.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032106Z" creationid="hsugawa8651" creationdate="20181114T032106Z">
        <seg>「WeakKeyDict」&lt;x1/&gt;はハッシュ表の実装で、鍵はオブジェクトへの弱い参照であり したがって、ハッシュ・テーブルで参照されている場合でも、ガーベッジ・コレクションを収集することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>```jldoctest
julia&gt; div(1, 0)
ERROR: DivideError: integer division error
[...]
```</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020035Z" creationid="hsugawa8651" creationdate="20181116T020035Z">
        <seg>```jldoctest
julia&gt; div(1, 0)
ERROR: DivideError: integer division error
[...]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`adjoint`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025903Z" creationid="hsugawa8651" creationdate="20181110T025903Z">
        <seg>`adjoint`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`axes(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153250Z" creationid="hsugawa8651" creationdate="20181109T153250Z">
        <seg>`axes(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`axes(A,n)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153255Z" creationid="hsugawa8651" creationdate="20181109T153255Z">
        <seg>`axes(A,n)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`cat(A...; dims=k)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064509Z" creationid="hsugawa8651" creationdate="20181114T064509Z">
        <seg>`cat(A...; dims=k)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ccall`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152234Z" creationid="hsugawa8651" creationdate="20181117T152234Z">
        <seg>`ccall`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ceil(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031212Z" creationid="hsugawa8651" creationdate="20181114T031212Z">
        <seg>`ceil(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`cglobal`&lt;x1/&gt; are a symbol specification identical to that used
by &lt;x2/&gt;`ccall`&lt;x3/&gt;, and a type describing the value stored in the variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152511Z" creationid="hsugawa8651" creationdate="20181117T152511Z">
        <seg>'cglobal'&lt;x1/&gt;は、使用されたものと同じシンボル仕様です。 &lt;x2/&gt;'ccall'&lt;x3/&gt;によって、変数に格納された値を記述するタイプが次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`copy(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064414Z" creationid="hsugawa8651" creationdate="20181114T064414Z">
        <seg>`copy(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`copy`&lt;x1/&gt; and other out-of-place
operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150506Z" creationid="hsugawa8651" creationdate="20181117T150506Z">
        <seg>「コピー」&lt;x1/&gt;およびその他の場所 操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`copy`&lt;x1/&gt; and other out-of-place
operations. No matter how an &lt;x2/&gt;AbstractArray{T,N}&lt;x3/&gt; is represented internally, &lt;x4/&gt;T&lt;x5/&gt; is the type of
object returned by &lt;x6/&gt;integer&lt;x7/&gt; indexing (&lt;x8/&gt;A[1, ..., 1]&lt;x9/&gt;, when &lt;x10/&gt;A&lt;x11/&gt; is not empty) and &lt;x12/&gt;N&lt;x13/&gt; should be
the length of the tuple returned by &lt;x14/&gt;`size`&lt;x15/&gt;. For more details on defining custom
&lt;x16/&gt;AbstractArray&lt;x17/&gt; implementations, see the &lt;x18/&gt;&lt;x19/&gt;&lt;x20/&gt;(@ref man-interface-array).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135321Z" creationid="hsugawa8651" creationdate="20181117T135321Z">
        <seg>「コピー」&lt;x1/&gt;およびその他の場所 オペレーションは、&lt;x2/&gt;AbstractArray{T,N}&lt;x3/&gt;が内部的に表されても、&lt;x4/&gt;T&lt;x5/&gt;はタイプである。 &lt;x6/&gt;整数&lt;x7/&gt;インデックス(&lt;x8/&gt;A[1,.…,1]&lt;x9/&gt;,&lt;x10/&gt;)は&lt;x10/&gt;A&lt;x11/&gt;であり、&lt;x12/&gt;N&lt;x13/&gt;は&lt;x12/&gt;n&lt;x13/&gt;である。 &lt;x14/&gt;`size'&lt;x15/&gt;によって返されるタプルの長さ。カスタムの定義についての詳細は &lt;x16/&gt;AbstractArray&lt;x17/&gt;実装を参照してください。&lt;x18/&gt;&lt;x19/&gt;&lt;x20/&gt;(@ref man interface array)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`deepcopy(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064418Z" creationid="hsugawa8651" creationdate="20181114T064418Z">
        <seg>`deepcopy(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`div(x,y)`&lt;x1/&gt;, &lt;x2/&gt;x÷y&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031239Z" creationid="hsugawa8651" creationdate="20181114T031239Z">
        <seg>`div(x,y)`&lt;x1/&gt;, &lt;x2/&gt;x÷y&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`eachindex(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153302Z" creationid="hsugawa8651" creationdate="20181109T153302Z">
        <seg>`eachindex(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`eltype(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150349Z" creationid="hsugawa8651" creationdate="20181117T150349Z">
        <seg>`eltype(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`falses(dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064409Z" creationid="hsugawa8651" creationdate="20181114T064409Z">
        <seg>`falses(dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`fill!(A, x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064438Z" creationid="hsugawa8651" creationdate="20181114T064438Z">
        <seg>`fill!(A, x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`fill(x, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064440Z" creationid="hsugawa8651" creationdate="20181114T064440Z">
        <seg>`fill(x, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`fld(x,y)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031244Z" creationid="hsugawa8651" creationdate="20181114T031244Z">
        <seg>`fld(x,y)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`floor(T, x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031151Z" creationid="hsugawa8651" creationdate="20181114T031151Z">
        <seg>`floor(T, x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`floor(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031122Z" creationid="hsugawa8651" creationdate="20181114T031122Z">
        <seg>`floor(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`getindex`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025910Z" creationid="hsugawa8651" creationdate="20181110T025910Z">
        <seg>`getindex`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`getindex`&lt;x1/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113057Z" creationid="hsugawa8651" creationdate="20181112T113057Z">
        <seg>`getindex`&lt;x1/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`hcat(A...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064514Z" creationid="hsugawa8651" creationdate="20181114T064514Z">
        <seg>`hcat(A...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`hcat`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025842Z" creationid="hsugawa8651" creationdate="20181110T025842Z">
        <seg>`hcat`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`hvcat`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025855Z" creationid="hsugawa8651" creationdate="20181110T025855Z">
        <seg>`hvcat`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`hvcat`&lt;x1/&gt; concatenates in both dimension 1 (with semicolons) and dimension 2 (with spaces).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154644Z" creationid="hsugawa8651" creationdate="20181109T154644Z">
        <seg>「ホフカト」&lt;x1/&gt;は、次元1(セミコロン)と次元2(スペースを含む)の両方で連結されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`hvcat`&lt;x1/&gt; concatenates in both dimension 1 (with semicolons) and dimension 2 (with spaces).
Consider these examples of this syntax:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134628Z" creationid="hsugawa8651" creationdate="20181117T134628Z">
        <seg>「ホフカト」&lt;x1/&gt;は、次元1(セミコロン)と次元2(スペースを含む)の両方で連結されます。 この構文の例を次に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`isequal(x, y)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030539Z" creationid="hsugawa8651" creationdate="20181114T030539Z">
        <seg>`isequal(x, y)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`isequal`&lt;x1/&gt; considers &lt;x2/&gt;NaN&lt;x3/&gt;s equal to each other:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030606Z" creationid="hsugawa8651" creationdate="20181114T030603Z">
        <seg>「isequal」&lt;x1/&gt;は、&lt;x2/&gt;NaN&lt;x3/&gt;を互いに等しいとみなします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`isequal`&lt;x1/&gt; to determine equality.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T041722Z" creationid="hsugawa8651" creationdate="20181112T041722Z">
        <seg>等価を決定するには、「isequal」&lt;x1/&gt;を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`isfinite(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030545Z" creationid="hsugawa8651" creationdate="20181114T030545Z">
        <seg>`isfinite(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`isinf(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030549Z" creationid="hsugawa8651" creationdate="20181114T030549Z">
        <seg>`isinf(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`isnan(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030558Z" creationid="hsugawa8651" creationdate="20181114T030558Z">
        <seg>`isnan(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`length(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153218Z" creationid="hsugawa8651" creationdate="20181109T153218Z">
        <seg>`length(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`length(iter)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112304Z" creationid="hsugawa8651" creationdate="20181112T112304Z">
        <seg>`length(iter)`&lt;x1/&gt;`length(iter)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`mod(x,y)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031255Z" creationid="hsugawa8651" creationdate="20181114T031255Z">
        <seg>`mod(x,y)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`mod1(x,y)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031310Z" creationid="hsugawa8651" creationdate="20181114T031310Z">
        <seg>`mod1(x,y)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`mod2pi(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031316Z" creationid="hsugawa8651" creationdate="20181114T031316Z">
        <seg>`mod2pi(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ndims(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153230Z" creationid="hsugawa8651" creationdate="20181109T153230Z">
        <seg>`ndims(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`one(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112015Z" creationid="hsugawa8651" creationdate="20181112T112015Z">
        <seg>`one(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ones(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064400Z" creationid="hsugawa8651" creationdate="20181114T064400Z">
        <seg>`ones(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`push!`&lt;x1/&gt;ing each element into a &lt;x2/&gt;Vector{Any}&lt;x3/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112721Z" creationid="hsugawa8651" creationdate="20181112T112721Z">
        <seg>「プッシュ!」&lt;x1/&gt;各要素を&lt;x2/&gt;ベクトル{Any}&lt;x3/&gt;に押し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`rand(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064427Z" creationid="hsugawa8651" creationdate="20181114T064427Z">
        <seg>`rand(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`randn(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064430Z" creationid="hsugawa8651" creationdate="20181114T064430Z">
        <seg>`randn(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`range(start, stop=stop, length=n)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064435Z" creationid="hsugawa8651" creationdate="20181114T064435Z">
        <seg>`range(start, stop=stop, length=n)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`reinterpret(T, A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064424Z" creationid="hsugawa8651" creationdate="20181114T064424Z">
        <seg>`reinterpret(T, A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`reshape(A, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064412Z" creationid="hsugawa8651" creationdate="20181114T064412Z">
        <seg>`reshape(A, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`round(T, x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031114Z" creationid="hsugawa8651" creationdate="20181114T031114Z">
        <seg>`round(T, x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`round(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031107Z" creationid="hsugawa8651" creationdate="20181114T031107Z">
        <seg>`round(x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`setindex!`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025917Z" creationid="hsugawa8651" creationdate="20181110T025917Z">
        <seg>`setindex!`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`setprecision`&lt;x1/&gt; and &lt;x2/&gt;`setrounding`&lt;x3/&gt;,
and all further calculations will take these changes in account.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111713Z" creationid="hsugawa8651" creationdate="20181112T111713Z">
        <seg>'setprecision'&lt;x1/&gt;および&lt;x2/&gt;'セロウンディング'&lt;x3/&gt; さらに計算を行うと、これらの変更は考慮されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`similar(A, T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064421Z" creationid="hsugawa8651" creationdate="20181114T064421Z">
        <seg>`similar(A, T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`size(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153236Z" creationid="hsugawa8651" creationdate="20181109T153236Z">
        <seg>`size(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`size(A,n)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T153242Z" creationid="hsugawa8651" creationdate="20181109T153242Z">
        <seg>`size(A,n)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`sort.jl`&lt;x1/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064222Z" creationid="hsugawa8651" creationdate="20181114T064222Z">
        <seg>`sort.jl`&lt;x1/&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`stderr`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043141Z" creationid="hsugawa8651" creationdate="20181112T043141Z">
        <seg>`stderr`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`stdin`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043139Z" creationid="hsugawa8651" creationdate="20181112T043139Z">
        <seg>`stdin`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`stdout`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T043140Z" creationid="hsugawa8651" creationdate="20181112T043140Z">
        <seg>`stdout`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`stride(A,k)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064339Z" creationid="hsugawa8651" creationdate="20181114T064339Z">
        <seg>`stride(A,k)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`strides(A)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064343Z" creationid="hsugawa8651" creationdate="20181114T064343Z">
        <seg>`strides(A)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`trues(dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064403Z" creationid="hsugawa8651" creationdate="20181114T064403Z">
        <seg>`trues(dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`trunc(T, x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031229Z" creationid="hsugawa8651" creationdate="20181114T031229Z">
        <seg>`trunc(T, x)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`vcat(A...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064511Z" creationid="hsugawa8651" creationdate="20181114T064511Z">
        <seg>`vcat(A...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`vcat`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025849Z" creationid="hsugawa8651" creationdate="20181110T025849Z">
        <seg>`vcat`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`view`&lt;x1/&gt; function, which is called the same way as
&lt;x2/&gt;`getindex`&lt;x3/&gt; (with an array and a series of index arguments).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160431Z" creationid="hsugawa8651" creationdate="20181109T160431Z">
        <seg>「view」&lt;x1/&gt;関数は、以下と同じ方法で呼び出されます。 &lt;x2/&gt;`getindex'&lt;x3/&gt;(配列と一連のインデックス引数を持つ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`view`&lt;x1/&gt; function, which is called the same way as
&lt;x2/&gt;`getindex`&lt;x3/&gt; (with an array and a series of index arguments). The result
of &lt;x4/&gt;`view`&lt;x5/&gt; looks the same as the result of &lt;x6/&gt;`getindex`&lt;x7/&gt;, except the
data is left in place. &lt;x8/&gt;`view`&lt;x9/&gt; stores the input index vectors in a
&lt;x10/&gt;SubArray&lt;x11/&gt; object, which can later be used to index the original array
indirectly.  By putting the &lt;x12/&gt;`@views`&lt;x13/&gt; macro in front of an expression or
block of code, any &lt;x14/&gt;array[...]&lt;x15/&gt; slice in that expression will be converted to
create a &lt;x16/&gt;SubArray&lt;x17/&gt; view instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135345Z" creationid="hsugawa8651" creationdate="20181117T135345Z">
        <seg>「view」&lt;x1/&gt;関数は、以下と同じ方法で呼び出されます。 &lt;x2/&gt;`getindex'&lt;x3/&gt;(配列と一連のインデックス引数を持つ)。結果 &lt;x4/&gt;'view'&lt;x5/&gt;は、&lt;x6/&gt;'getindex'&lt;x7/&gt;の結果と同じであるが データは所定の場所に残されます。&lt;x8/&gt;'view'&lt;x9/&gt;は、入力インデックスベクトルを格納します。 &lt;x10/&gt;サブアレイ&lt;x11/&gt;オブジェクトで、後でオリジナルの配列をインデックス化するために使用できます。 間接的には、&lt;x12/&gt;`@views`&lt;x13/&gt;マクロを式の前に置くか、または コードのブロック、任意の&lt;x14/&gt;配列[.]&lt;x15/&gt;スライスは、その式の中に変換されます。 代わりに&lt;x16/&gt;サブアレイを作成&lt;x17/&gt;ビューを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`zero(x)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112005Z" creationid="hsugawa8651" creationdate="20181112T112005Z">
        <seg>'0(x)'&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`zeros(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064357Z" creationid="hsugawa8651" creationdate="20181114T064357Z">
        <seg>`zeros(T, dims...)`&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a += b&lt;x4/&gt;) are parsed
as &lt;x5/&gt;a .= a .+ b&lt;x6/&gt;, where &lt;x7/&gt;.=&lt;x8/&gt; is a fused &lt;x9/&gt;in-place&lt;x10/&gt; assignment operation
(see the &lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;(@ref man-vectorized)).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132629Z" creationid="hsugawa8651" creationdate="20181113T132629Z">
        <seg>+=b&lt;x4/&gt;)は解析されます。 &lt;x5/&gt;a.=a.+b&lt;x6/&gt;。ここで&lt;x7/&gt;=&lt;x8/&gt;は、&lt;x9/&gt;&lt;x8/&gt;であり、&lt;x7/&gt;は、&lt;x9/&gt;のインプレースである。 (&lt;x11/&gt;&lt;x12/&gt;&lt;x13/&gt;(@ref man vectorized))を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a &lt;x1/&gt;BitArray&lt;x2/&gt; with all values &lt;x3/&gt;false&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154417Z" creationid="hsugawa8651" creationdate="20181109T154417Z">
        <seg>&lt;x1/&gt;BitArray&lt;x2/&gt;であり、すべての値は&lt;x3/&gt;false&lt;x4/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a &lt;x1/&gt;`BitArray`&lt;x2/&gt; with all values &lt;x3/&gt;true&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064408Z" creationid="hsugawa8651" creationdate="20181109T154402Z">
        <seg>&lt;x1/&gt;'BitArray'&lt;x2/&gt;はすべての値が&lt;x3/&gt;真&lt;x4/&gt;である</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021227Z" creationid="hsugawa8651" creationdate="20181116T021227Z">
        <seg>a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function pointer (for example, from &lt;x1/&gt;dlsym&lt;x2/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T223840Z" creationid="hsugawa8651" creationdate="20181109T223840Z">
        <seg>関数ポインタ(たとえば、&lt;x1/&gt;dlsym&lt;x2/&gt;からの関数ポインタです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a range expressing the valid indices along dimension &lt;x1/&gt;n&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154257Z" creationid="hsugawa8651" creationdate="20181109T154257Z">
        <seg>寸法&lt;x1/&gt;n&lt;x2/&gt;に沿って有効なインデックスを表現する範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a return type of &lt;x1/&gt;Ref{Any}&lt;x2/&gt; is invalid, it should either be &lt;x3/&gt;Any&lt;x4/&gt; (corresponding to &lt;x5/&gt;jl_value_t*&lt;x6/&gt;)
or &lt;x7/&gt;Ptr{Any}&lt;x8/&gt; (corresponding to &lt;x9/&gt;jl_value_t**&lt;x10/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151813Z" creationid="hsugawa8651" creationdate="20181117T151813Z">
        <seg>&lt;x1/&gt;Ref{Any}&lt;x2/&gt;の戻り値が無効です。&lt;x3/&gt;Any&lt;x4/&gt;(&lt;x5/&gt;jl_value_t*&lt;x6/&gt;に対応します) または&lt;x7/&gt;Ptr{Any}&lt;x8/&gt;(&lt;x9/&gt;jl_value_t**&lt;x10/&gt;に対応する)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a tuple containing the dimensions of &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154246Z" creationid="hsugawa8651" creationdate="20181109T154246Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;の次元を含むタプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a tuple containing the valid indices of &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154254Z" creationid="hsugawa8651" creationdate="20181109T154254Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;の有効なインデックスを含むタプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a tuple of the strides in each dimension</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154309Z" creationid="hsugawa8651" creationdate="20181109T154309Z">
        <seg>各次元の上昇点の集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a value greater than all finite floating-point values</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110817Z" creationid="hsugawa8651" creationdate="20181112T110817Z">
        <seg>すべての有限浮動小数点値より大きい値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a value less than all finite floating-point values</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110835Z" creationid="hsugawa8651" creationdate="20181112T110835Z">
        <seg>すべての有限浮動小数点値より小さい値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a value not &lt;x1/&gt;==&lt;x2/&gt; to any floating-point value (including itself)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110843Z" creationid="hsugawa8651" creationdate="20181112T110843Z">
        <seg>浮動小数点値(自身を含む)に対して&lt;x1/&gt;==&lt;x2/&gt;ではない値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a!( )&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032243Z" creationid="hsugawa8651" creationdate="20181114T032243Z">
        <seg>a!( )&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a:b&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063537Z" creationid="hsugawa8651" creationdate="20181114T063537Z">
        <seg>a:b&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a:s:b&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063541Z" creationid="hsugawa8651" creationdate="20181114T063541Z">
        <seg>a:s:b&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a&lt;x1/&gt; and &lt;x2/&gt;b&lt;x3/&gt;, and &lt;x4/&gt;`maximum(a)`&lt;x5/&gt;, which finds the largest value within
&lt;x6/&gt;a&lt;x7/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160031Z" creationid="hsugawa8651" creationdate="20181109T160031Z">
        <seg>&lt;x1/&gt;および&lt;x2/&gt;b&lt;x3/&gt;、&lt;x4/&gt;の最大値(a)&lt;x5/&gt;は、最も大きい値を示します。 &lt;x6/&gt;a&lt;x7/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a&lt;x1/&gt; and &lt;x2/&gt;b&lt;x3/&gt;, and &lt;x4/&gt;`maximum(a)`&lt;x5/&gt;, which finds the largest value within
&lt;x6/&gt;a&lt;x7/&gt;. The same relationship holds for &lt;x8/&gt;min.(a,b)&lt;x9/&gt; and &lt;x10/&gt;minimum(a)&lt;x11/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135208Z" creationid="hsugawa8651" creationdate="20181117T135208Z">
        <seg>&lt;x1/&gt;および&lt;x2/&gt;b&lt;x3/&gt;、&lt;x4/&gt;の最大値(a)&lt;x5/&gt;は、最も大きい値を示します。 &lt;x6/&gt;&lt;x7/&gt;。&lt;x8/&gt;min(a,b)&lt;x9/&gt;と&lt;x10/&gt;最小(a)&lt;x11/&gt;と同じ関係が成り立つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a[]&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063025Z" creationid="hsugawa8651" creationdate="20181114T063025Z">
        <seg>a[]&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>abstract type AbstractArray{T, N} end
eltype(::Type{&lt;:AbstractArray{T}}) where {T} = T</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054127Z" creationid="hsugawa8651" creationdate="20181116T054127Z">
        <seg>abstract type AbstractArray{T, N} end
eltype(::Type{&lt;:AbstractArray{T}}) where {T} = T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>abstract type AbstractArray{T, N} end
eltype(::Type{AbstractArray}) = Any
eltype(::Type{AbstractArray{T}}) where {T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A&lt;:AbstractArray} = eltype(supertype(A))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054135Z" creationid="hsugawa8651" creationdate="20181116T054135Z">
        <seg>abstract type AbstractArray{T, N} end
eltype(::Type{AbstractArray}) = Any
eltype(::Type{AbstractArray{T}}) where {T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A&lt;:AbstractArray} = eltype(supertype(A))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>abstract type Number end
abstract type Real     &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer  &lt;: Real end
abstract type Signed   &lt;: Integer end
abstract type Unsigned &lt;: Integer end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021555Z" creationid="hsugawa8651" creationdate="20181116T021555Z">
        <seg>abstract type Number end
abstract type Real     &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer  &lt;: Real end
abstract type Signed   &lt;: Integer end
abstract type Unsigned &lt;: Integer end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>access named fields in objects/modules (calling &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref Base.getproperty) or &lt;x4/&gt;&lt;x5/&gt;&lt;x6/&gt;(@ref Base.setproperty!)), also prefixes elementwise function calls (calling &lt;x7/&gt;`broadcast`&lt;x8/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063536Z" creationid="hsugawa8651" creationdate="20181114T063536Z">
        <seg>オブジェクト/モジュールの名前付きフィールド(呼び出し&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref Base.getproperty)または&lt;x4/&gt;&lt;x6/&gt;&lt;x6/&gt;&lt;x6/&gt;&lt;x6/&gt;(@ref Base.setproperty!))は、要素関数呼び出し(&lt;x7/&gt;ブロードキャスト"&lt;x8/&gt;)を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an &lt;x1/&gt;Array&lt;x2/&gt; filled with the value &lt;x3/&gt;x&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064443Z" creationid="hsugawa8651" creationdate="20181114T064443Z">
        <seg>&lt;x3/&gt;x&lt;x4/&gt;の値で満たされた&lt;x1/&gt;配列&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an &lt;x1/&gt;Array&lt;x2/&gt; of all ones</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154358Z" creationid="hsugawa8651" creationdate="20181109T154358Z">
        <seg>全ての&lt;x1/&gt;アレイ&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an &lt;x1/&gt;Array&lt;x2/&gt; of all zeros</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154354Z" creationid="hsugawa8651" creationdate="20181109T154354Z">
        <seg>すべてのゼロの&lt;x1/&gt;配列&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an &lt;x1/&gt;Array&lt;x2/&gt; with random, iid &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt; and uniformly distributed values in the half-open interval &lt;x6/&gt;[0, 1)&lt;x7/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154449Z" creationid="hsugawa8651" creationdate="20181109T154449Z">
        <seg>&lt;x1/&gt;配列&lt;x2/&gt;で、ランダムなiid&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;で、半オープン間隔&lt;x6/&gt;[0 1]&lt;x7/&gt;で均一に分布した値を示す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an &lt;x1/&gt;Array&lt;x2/&gt; with random, iid and standard normally distributed values</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154452Z" creationid="hsugawa8651" creationdate="20181109T154452Z">
        <seg>ランダムなiidと標準的な正規分布の値を持つ&lt;x1/&gt;配列&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an array containing the same data as &lt;x1/&gt;A&lt;x2/&gt;, but with different dimensions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154421Z" creationid="hsugawa8651" creationdate="20181109T154421Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;と同じデータを含む配列であるが、異なる次元を含む配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an array with the same binary data as &lt;x1/&gt;A&lt;x2/&gt;, but with element type &lt;x3/&gt;T&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154445Z" creationid="hsugawa8651" creationdate="20181109T154445Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;と同じバイナリデータを持つ配列であるが、要素タイプ&lt;x3/&gt;T&lt;x4/&gt;である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an efficient iterator for visiting each position in &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154302Z" creationid="hsugawa8651" creationdate="20181109T154302Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;の各位置を訪問するための効率的なイテレータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an uninitialized array of the same type as &lt;x1/&gt;A&lt;x2/&gt; (dense, sparse, etc.), but with the specified element type and dimensions.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154439Z" creationid="hsugawa8651" creationdate="20181109T154439Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;(密、疎等)と同じタイプの初期化されていない配列ですが、指定されたエレメントタイプとディメンションがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an uninitialized array of the same type as &lt;x1/&gt;A&lt;x2/&gt; (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of &lt;x3/&gt;A&lt;x4/&gt; if omitted.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134523Z" creationid="hsugawa8651" creationdate="20181117T134523Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;(密、疎など)と同じタイプの初期化されていない配列ですが、指定された要素タイプと次元があります。2番目と3番目の引数は両方ともオプションで、&lt;x/&gt;A&lt;x4/&gt;の要素タイプと次元は省略されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an uninitialized dense &lt;x1/&gt;`Array`&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154351Z" creationid="hsugawa8651" creationdate="20181109T154351Z">
        <seg>初期化されていない密な&lt;x1/&gt;`配列"&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and can cause especial headaches with &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man-multi-dim-arrays):</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030531Z" creationid="hsugawa8651" creationdate="20181114T030531Z">
        <seg>また、&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref man multi dim arrayS)で特別な頭痛を引き起こす可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and compare how these results differ:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015720Z" creationid="hsugawa8651" creationdate="20181116T015720Z">
        <seg>and compare how these results differ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>argument value must be a valid Julia object</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151536Z" creationid="hsugawa8651" creationdate="20181117T151533Z">
        <seg>引数の値は有効なJuliaオブジェクトでなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>argument value must be a valid Julia object (or &lt;x1/&gt;C_NULL&lt;x2/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151546Z" creationid="hsugawa8651" creationdate="20181117T151546Z">
        <seg>引数の値は有効なジュリアオブジェクトでなければなりません(または&lt;x1/&gt;C_NULL&lt;x2/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>argument value will be copied (passed by value)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151515Z" creationid="hsugawa8651" creationdate="20181117T151515Z">
        <seg>引数の値がコピーされます(値によって渡されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>argument value will be copied (returned by-value)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151802Z" creationid="hsugawa8651" creationdate="20181117T151802Z">
        <seg>引数の値がコピーされます(値によって返されます)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>argument value will be copied if it is an &lt;x1/&gt;isbits&lt;x2/&gt; type otherwise, the value must be a valid Julia
object</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151556Z" creationid="hsugawa8651" creationdate="20181117T151556Z">
        <seg>引数の値は、&lt;x1/&gt;イスビトス&lt;x2/&gt;の場合はコピーされます。それ以外の場合は、有効なジュリアである必要があります。 オブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array indexing (calling &lt;x1/&gt;`getindex`&lt;x2/&gt; or &lt;x3/&gt;`setindex!`&lt;x4/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063044Z" creationid="hsugawa8651" creationdate="20181114T063044Z">
        <seg>array indexing (calling &lt;x1/&gt;`getindex`&lt;x2/&gt; or &lt;x3/&gt;`setindex!`&lt;x4/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>at the end of a function name, &lt;x1/&gt;!&lt;x2/&gt; is used as a convention to indicate that a function modifies its argument(s)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032245Z" creationid="hsugawa8651" creationdate="20181114T032245Z">
        <seg>関数名の最後に、&lt;x1/&gt;!&lt;x2/&gt;は関数がその引数を変更することを示す規則として使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>axes(A)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022510Z" creationid="hsugawa8651" creationdate="20181113T022510Z">
        <seg>axes(A)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>backslash operator</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150256Z" creationid="hsugawa8651" creationdate="20181117T150256Z">
        <seg>バックスラッシュ演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bar(x::Integer) = x ^ 2&lt;x1/&gt; will do the same thing, but it is both simpler and faster.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032213Z" creationid="hsugawa8651" creationdate="20181116T032213Z">
        <seg>bar(x::Integer)=x^2&lt;x1/&gt;は同じことを行いますが、どちらもより単純で速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>begin multi-line comment (these are nestable)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032254Z" creationid="hsugawa8651" creationdate="20181114T032254Z">
        <seg>複数行コメントを開始します(これらはnestableです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>begin single line comment</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032249Z" creationid="hsugawa8651" creationdate="20181114T032249Z">
        <seg>単一行コメントを開始する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>binary minus</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132019Z" creationid="hsugawa8651" creationdate="20181113T132019Z">
        <seg>binary minus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>binary plus</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132007Z" creationid="hsugawa8651" creationdate="20181113T132007Z">
        <seg>バイナリプラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bitwise and</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132241Z" creationid="hsugawa8651" creationdate="20181113T132241Z">
        <seg>bitwise and</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bitwise not operator</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150254Z" creationid="hsugawa8651" creationdate="20181117T150254Z">
        <seg>ビット単位の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bitwise or</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132250Z" creationid="hsugawa8651" creationdate="20181113T132250Z">
        <seg>bitwise or</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bitwise xor (exclusive or)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132300Z" creationid="hsugawa8651" creationdate="20181113T132300Z">
        <seg>ビット単位のXOR(排他的な排他的な排他的論理和)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bitwise xor operator</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150247Z" creationid="hsugawa8651" creationdate="20181117T150247Z">
        <seg>ビット単位のXOR演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bool&lt;x1/&gt; (only in C++)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150906Z" creationid="hsugawa8651" creationdate="20181117T150906Z">
        <seg>bool&lt;x1/&gt; (only in C++)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>broadcast(f, args...)&lt;x1/&gt;, providing a convenient syntax to broadcast any function
(&lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref man-vectorized)).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161321Z" creationid="hsugawa8651" creationdate="20181114T161321Z">
        <seg>ブロードキャスト(f,args.)&lt;x1/&gt;は、任意の関数をブロードキャストするための便利な構文を提供します。 (&lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref manベクトル化))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>broadcast(f, args...)&lt;x1/&gt;, providing a convenient syntax to broadcast any function
(&lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref man-vectorized)). Nested "dot calls" &lt;x5/&gt;f.(...)&lt;x6/&gt; (including calls to &lt;x7/&gt;.+&lt;x8/&gt; etcetera)
&lt;x9/&gt;&lt;x10/&gt;&lt;x11/&gt;(@ref man-dot-operators) into a single &lt;x12/&gt;broadcast&lt;x13/&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135258Z" creationid="hsugawa8651" creationdate="20181117T135258Z">
        <seg>ブロードキャスト(f,args.)&lt;x1/&gt;は、任意の関数をブロードキャストするための便利な構文を提供します。 (&lt;x2/&gt;&lt;x3/&gt;&lt;x4/&gt;(@ref man vectorized))ネストされた"ドットコール"&lt;x5/&gt;f.(...)&lt;x6/&gt;(&lt;x7/&gt;.+&lt;x8/&gt;eteteraへの呼び出しを含む) &lt;x9/&gt;&lt;x10/&gt;&lt;x11/&gt;(@ref man dot演算子)は、単一の&lt;x12/&gt;ブロードキャスト・&lt;x13/&gt;コールに対して使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131627Z" creationid="hsugawa8651" creationdate="20181113T131627Z">
        <seg>broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall
Core.Intrinsics.cglobal
Base.@cfunction
Base.CFunction
Base.unsafe_convert
Base.cconvert
Base.unsafe_load
Base.unsafe_store!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042025Z" creationid="hsugawa8651" creationdate="20181110T042025Z">
        <seg>ccall
Core.Intrinsics.cglobal
Base.@cfunction
Base.CFunction
Base.unsafe_convert
Base.cconvert
Base.unsafe_load
Base.unsafe_store!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall using a threadpool (Experimental)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044702Z" creationid="hsugawa8651" creationdate="20181112T044702Z">
        <seg>ccall using a threadpool (Experimental)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152453Z" creationid="hsugawa8651" creationdate="20181117T152453Z">
        <seg>ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall((:foo, "libfoo"), Cvoid, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022718Z" creationid="hsugawa8651" creationdate="20181116T022718Z">
        <seg>ccall((:foo, "libfoo"), Cvoid, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall((:foo, "libfoo"), Cvoid, (Int32, Float64), x, y)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022714Z" creationid="hsugawa8651" creationdate="20181116T022714Z">
        <seg>ccall((:foo, "libfoo"), Cvoid, (Int32, Float64), x, y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall((@static Sys.iswindows() ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031926Z" creationid="hsugawa8651" creationdate="20181114T031926Z">
        <seg>ccall((@static Sys.iswindows() ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall(sym, ...) &lt;x3/&gt; Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152406Z" creationid="hsugawa8651" creationdate="20181117T152406Z">
        <seg>ccall(sym, ...)&lt;x3/&gt;(シンボル、ライブラリ)タプルの代わりにポインタ`sym'を使用します(残りの引数は同じです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall&lt;x1/&gt; / &lt;x2/&gt;@cfunction&lt;x3/&gt; argument translation guide</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151500Z" creationid="hsugawa8651" creationdate="20181117T151500Z">
        <seg>ccall&lt;x1/&gt;/&lt;x2/&gt;@cfunction&lt;x3/&gt;引数変換ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ccall&lt;x1/&gt; / &lt;x2/&gt;@cfunction&lt;x3/&gt; return type translation guide</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151737Z" creationid="hsugawa8651" creationdate="20181117T151734Z">
        <seg>ccall&lt;x1/&gt;/&lt;x2/&gt;@cfunction&lt;x3/&gt;return type translation guide</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>changes &lt;x1/&gt;true&lt;x2/&gt; to &lt;x3/&gt;false&lt;x4/&gt; and vice versa</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132157Z" creationid="hsugawa8651" creationdate="20181113T132157Z">
        <seg>changes &lt;x1/&gt;true&lt;x2/&gt; to &lt;x3/&gt;false&lt;x4/&gt; and vice versa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>char*&lt;x1/&gt; to a C routine that does not assume NUL termination (e.g. because you pass an explicit
string length), or if you know for certain that your Julia string does not contain NUL and want
to skip the check, you can use &lt;x2/&gt;Ptr{UInt8}&lt;x3/&gt; as the argument type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150952Z" creationid="hsugawa8651" creationdate="20181117T150952Z">
        <seg>char*&lt;x1/&gt;はNUL終了を想定していないCルーチンに対して(例えば明示的なものを渡すなど) 文字列の長さ)、またはJulia文字列にNULが含まれていないことがわかっている場合は このチェックをスキップするには、引数のタイプとして&lt;x2/&gt;Ptr{UInt8}&lt;x3/&gt;を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>clock&lt;x1/&gt; takes no arguments and returns an &lt;x2/&gt;`Int32`&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224034Z" creationid="hsugawa8651" creationdate="20181109T224034Z">
        <seg>クロック&lt;x1/&gt;は引数を取らず、&lt;x2/&gt;`Int32`&lt;x3/&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>clock&lt;x1/&gt; takes no arguments and returns an &lt;x2/&gt;`Int32`&lt;x3/&gt;. One common gotcha is that a 1-tuple must be
written with a trailing comma. For example, to call the &lt;x4/&gt;getenv&lt;x5/&gt; function to get a pointer to
the value of an environment variable, one makes a call like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134117Z" creationid="hsugawa8651" creationdate="20181117T134117Z">
        <seg>clock&lt;x1/&gt;は引数を取らず、&lt;x2/&gt;`Int32`&lt;x3/&gt;を返します。1つの一般的なgotchaは1タプルを必要とします。 は、次のように記述されます。たとえば、&lt;x4/&gt;getenv&lt;x5/&gt;関数を呼び出してポインタを取得するには、次のようにカンマで区切ります。 環境変数の値は、次のような呼び出しを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>complex transpose operator Aᴴ</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063021Z" creationid="hsugawa8651" creationdate="20181114T063021Z">
        <seg>複素転置演算子Aᴴ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>complex(float(x))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021143Z" creationid="hsugawa8651" creationdate="20181116T021143Z">
        <seg>complex(float(x))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>complexfunction(arg::Int) = ...
complexfunction(arg::Any) = complexfunction(convert(Int, arg))

matmul(a::T, b::T) = ...
matmul(a, b) = matmul(promote(a, b)...)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054308Z" creationid="hsugawa8651" creationdate="20181116T054308Z">
        <seg>complexfunction(arg::Int) = ...
complexfunction(arg::Any) = complexfunction(convert(Int, arg))

matmul(a::T, b::T) = ...
matmul(a, b) = matmul(promote(a, b)...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>concatenate input arrays along dimension(s) &lt;x1/&gt;k&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154549Z" creationid="hsugawa8651" creationdate="20181109T154549Z">
        <seg>次元に沿って入力配列を連結する&lt;x1/&gt;k&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cond = Base.AsyncCondition()
wait(cond)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152629Z" creationid="hsugawa8651" creationdate="20181117T152629Z">
        <seg>cond = Base.AsyncCondition()
wait(cond)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>const m128 = NTuple{4,VecElement{Float32}}

function add(a::m128, b::m128)
    (VecElement(a[1].value+b[1].value),
     VecElement(a[2].value+b[2].value),
     VecElement(a[3].value+b[3].value),
     VecElement(a[4].value+b[4].value))
end

triple(c::m128) = add(add(c,c),c)

code_native(triple,(m128,))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044828Z" creationid="hsugawa8651" creationdate="20181112T044828Z">
        <seg>const m128 = NTuple{4,VecElement{Float32}}

function add(a::m128, b::m128)
    (VecElement(a[1].value+b[1].value),
     VecElement(a[2].value+b[2].value),
     VecElement(a[3].value+b[3].value),
     VecElement(a[4].value+b[4].value))
end

triple(c::m128) = add(add(c,c),c)

code_native(triple,(m128,))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -&gt; VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -&gt; VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, "libdist"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151326Z" creationid="hsugawa8651" creationdate="20181117T151326Z">
        <seg>const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -&gt; VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -&gt; VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, "libdist"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>copy &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064416Z" creationid="hsugawa8651" creationdate="20181109T154430Z">
        <seg>copy &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>copy &lt;x1/&gt;A&lt;x2/&gt;, recursively copying its elements</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154435Z" creationid="hsugawa8651" creationdate="20181109T154435Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;をコピーして、その要素を再帰的にコピーする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>copyto!(dest, bc::Broadcasted{DestStyle})</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131647Z" creationid="hsugawa8651" creationdate="20181113T131647Z">
        <seg>copyto!(dest, bc::Broadcasted{DestStyle})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>copyto!(dest::DestType, bc::Broadcasted{Nothing})</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131658Z" creationid="hsugawa8651" creationdate="20181113T131658Z">
        <seg>copyto!(dest::DestType, bc::Broadcasted{Nothing})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currently unsupported by &lt;x1/&gt;@cfunction&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151722Z" creationid="hsugawa8651" creationdate="20181117T151722Z">
        <seg>現在は&lt;x1/&gt;@cfunction&lt;x2/&gt;によってサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defalg(v::AbstractArray) = MergeSort
defalg(v::AbstractArray{&lt;:Number}) = QuickSort</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064228Z" creationid="hsugawa8651" creationdate="20181114T064228Z">
        <seg>defalg(v::AbstractArray) = MergeSort
defalg(v::AbstractArray{&lt;:Number}) = QuickSort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined in terms of scalar &lt;x1/&gt;setindex!&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022349Z" creationid="hsugawa8651" creationdate="20181113T022349Z">
        <seg>スカラー&lt;x1/&gt;setindex!&lt;x2/&gt;の観点から定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delimit character literals</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063521Z" creationid="hsugawa8651" creationdate="20181114T063521Z">
        <seg>文字リテラルを区切る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delimit external process (command) specifications</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063525Z" creationid="hsugawa8651" creationdate="20181114T063525Z">
        <seg>外部プロセス(コマンド)仕様の境界指定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delimit string literals</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063507Z" creationid="hsugawa8651" creationdate="20181114T063507Z">
        <seg>文字列リテラルを区切る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>depends on how this parameter is used, first translate this to the intended pointer type, then
determine the Julia equivalent using the remaining rules in this list</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151525Z" creationid="hsugawa8651" creationdate="20181117T151525Z">
        <seg>このパラメータがどのように使用されるかによって異なります。まず、このパラメータを目的のポインタ・タイプに変換します。 このリストの残りのルールを使用して、Julia equivalentを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>desc : desc == "" ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022220Z" creationid="hsugawa8651" creationdate="20181116T022220Z">
        <seg>desc : desc == "" ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dest&lt;x1/&gt; or the specific subtype of &lt;x2/&gt;bc&lt;x3/&gt;,
to avoid ambiguities between packages we recommend the following convention.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131641Z" creationid="hsugawa8651" creationdate="20181113T131641Z">
        <seg>dest&lt;x1/&gt;または&lt;x2/&gt;bc&lt;x3/&gt;の特定のサブタイプ パッケージ間の曖昧さを避けるために、次の規則が推奨されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dims&lt;x1/&gt; argument (ordinarily a &lt;x2/&gt;Dims&lt;x3/&gt; size-tuple) can accept &lt;x4/&gt;AbstractUnitRange&lt;x5/&gt; objects,
perhaps range-types &lt;x6/&gt;Ind&lt;x7/&gt; of your own design.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083418Z" creationid="hsugawa8651" creationdate="20181113T083418Z">
        <seg>&lt;x1/&gt;引数(通常は&lt;x2/&gt;Dimms&lt;x3/&gt;サイズのタプル)は&lt;x4/&gt;AbstractUnitRange&lt;x5/&gt;オブジェクトを受け入れることができます。 独自の設計では、おそらく範囲のタイプは&lt;x6/&gt;Ind&lt;x7/&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>divide</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132049Z" creationid="hsugawa8651" creationdate="20181113T132049Z">
        <seg>分割する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110238Z" creationid="hsugawa8651" creationdate="20181112T110238Z">
        <seg>double&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eltype(::Type{AbstractArray{T, N} where {T&lt;:S, N&lt;:M}}) where {M, S} = Any
eltype(::Type{AbstractArray{T, N} where {T&lt;:S}}) where {N, S} = Any
eltype(::Type{AbstractArray{T, N} where {N&lt;:M}}) where {M, T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A &lt;: AbstractArray} = eltype(supertype(A))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054140Z" creationid="hsugawa8651" creationdate="20181116T054140Z">
        <seg>eltype(::Type{AbstractArray{T, N} where {T&lt;:S, N&lt;:M}}) where {M, S} = Any
eltype(::Type{AbstractArray{T, N} where {T&lt;:S}}) where {N, S} = Any
eltype(::Type{AbstractArray{T, N} where {N&lt;:M}}) where {M, T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A &lt;: AbstractArray} = eltype(supertype(A))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eltype(IterType)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112156Z" creationid="hsugawa8651" creationdate="20181112T112156Z">
        <seg>eltype(IterType)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eltype_wrong(::Type{A}) where {A&lt;:AbstractArray} = A.parameters[1]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054146Z" creationid="hsugawa8651" creationdate="20181116T054146Z">
        <seg>eltype_wrong(::Type{A}) where {A&lt;:AbstractArray} = A.parameters[1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end
end
using Bar</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025208Z" creationid="hsugawa8651" creationdate="20181110T025208Z">
        <seg>end
end
using Bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end
mycompare (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133233Z" creationid="hsugawa8651" creationdate="20181117T133233Z">
        <seg>end
mycompare (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end multi-line comment</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032303Z" creationid="hsugawa8651" creationdate="20181114T032303Z">
        <seg>複数行コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>equivalent to &lt;x1/&gt;--code-coverage=user&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224802Z" creationid="hsugawa8651" creationdate="20181109T224802Z">
        <seg>&lt;x1/&gt;--code coverage=user&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>equivalent to &lt;x1/&gt;--track-allocation=user&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224807Z" creationid="hsugawa8651" creationdate="20181109T224807Z">
        <seg>&lt;x1/&gt;に相当する--トラック割り当て=ユーザ&lt;x2/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>equivalent to &lt;x1/&gt;rem(x,y)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132147Z" creationid="hsugawa8651" creationdate="20181113T132147Z">
        <seg>&lt;x1/&gt;rem(x,y)&lt;x2/&gt;に相当する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>equivalent to &lt;x1/&gt;y / x&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132124Z" creationid="hsugawa8651" creationdate="20181113T132124Z">
        <seg>&lt;x1/&gt;y/x&lt;x2/&gt;に相当する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>error("out of order") : new(x,y)
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155746Z" creationid="hsugawa8651" creationdate="20181117T155746Z">
        <seg>error("out of order") : new(x,y)
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval&lt;x1/&gt; only operates at the top level,
so within this expression local variables will not be available (unless their values are substituted
with &lt;x2/&gt;$&lt;x3/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152309Z" creationid="hsugawa8651" creationdate="20181117T152309Z">
        <seg>eval&lt;x1/&gt;は最上位レベルでのみ動作します。 この式では、ローカル変数は使用できません(値が代入されない限り)。 &lt;x2/&gt;$&lt;x3/&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ex : msgs[1]
           msg = string(msg_body)
           return :($ex ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015439Z" creationid="hsugawa8651" creationdate="20181116T015439Z">
        <seg>ex : msgs[1]
           msg = string(msg_body)
           return :($ex ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exponent operator</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032314Z" creationid="hsugawa8651" creationdate="20181114T032314Z">
        <seg>指数演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054330Z" creationid="hsugawa8651" creationdate="20181116T054330Z">
        <seg>f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(a::Int,b::Int) = a-2b</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054335Z" creationid="hsugawa8651" creationdate="20181116T054335Z">
        <seg>f(a::Int,b::Int) = a-2b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(a=1,b=2) = a+2b</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054328Z" creationid="hsugawa8651" creationdate="20181116T054328Z">
        <seg>f(a=1,b=2) = a+2b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x, y::Int) = 1
f(x::Int, y) = 2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054405Z" creationid="hsugawa8651" creationdate="20181116T054405Z">
        <seg>f(x, y::Int) = 1
f(x::Int, y) = 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054442Z" creationid="hsugawa8651" creationdate="20181116T054442Z">
        <seg>f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054432Z" creationid="hsugawa8651" creationdate="20181116T054432Z">
        <seg>f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054430Z" creationid="hsugawa8651" creationdate="20181116T054430Z">
        <seg>f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x::Int, y::Int) = 3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054407Z" creationid="hsugawa8651" creationdate="20181116T054407Z">
        <seg>f(x::Int, y::Int) = 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054413Z" creationid="hsugawa8651" creationdate="20181116T054413Z">
        <seg>f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054439Z" creationid="hsugawa8651" creationdate="20181116T054439Z">
        <seg>f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f(x::Tuple{}) = 3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054426Z" creationid="hsugawa8651" creationdate="20181116T054426Z">
        <seg>f(x::Tuple{}) = 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f&lt;x1/&gt; and &lt;x2/&gt;args&lt;x3/&gt;, describing the function and argument list, respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131342Z" creationid="hsugawa8651" creationdate="20181113T131342Z">
        <seg>f&lt;x1/&gt;と&lt;x2/&gt;args&lt;x3/&gt;は、関数と引数リストをそれぞれ記述しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>false : even(n - 1);

julia&gt; even(3)
false

julia&gt; odd(3)
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022336Z" creationid="hsugawa8651" creationdate="20181116T022336Z">
        <seg>false : even(n - 1);

julia&gt; even(3)
false

julia&gt; odd(3)
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>false&lt;x1/&gt; (0)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110221Z" creationid="hsugawa8651" creationdate="20181112T110221Z">
        <seg>false&lt;x1/&gt; (0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fill the array &lt;x1/&gt;A&lt;x2/&gt; with the value &lt;x3/&gt;x&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154507Z" creationid="hsugawa8651" creationdate="20181109T154507Z">
        <seg>&lt;x3/&gt;x&lt;x4/&gt;の値を持つ配列&lt;x1/&gt;A&lt;x2/&gt;を配列に埋め込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix_combining_chars(char) : "$char")
        end
        push!(entries, [
            join(code_points, " + "), join(characters),
            join(inputs, ", "), join(unicode_names, " + ")
        ])
    end
    return Markdown.Table(entries, [:l, :l, :l, :l])
end

table_entries(
    tab_completions(
        REPL.REPLCompletions.latex_symbols,
        REPL.REPLCompletions.emoji_symbols
    ),
    unicode_data()
)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022233Z" creationid="hsugawa8651" creationdate="20181116T022233Z">
        <seg>fix_combining_chars(char) : "$char")
        end
        push!(entries, [
            join(code_points, " + "), join(characters),
            join(inputs, ", "), join(unicode_names, " + ")
        ])
    end
    return Markdown.Table(entries, [:l, :l, :l, :l])
end

table_entries(
    tab_completions(
        REPL.REPLCompletions.latex_symbols,
        REPL.REPLCompletions.emoji_symbols
    ),
    unicode_data()
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021333Z" creationid="hsugawa8651" creationdate="20181116T021333Z">
        <seg>foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo(x::Real) = ...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021327Z" creationid="hsugawa8651" creationdate="20181116T021327Z">
        <seg>foo(x::Real) = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo(x::T) where {T&lt;:Real} = ...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021324Z" creationid="hsugawa8651" creationdate="20181116T021324Z">
        <seg>foo(x::T) where {T&lt;:Real} = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc "`add(a,b)` adds `a` and `b` together" add
@doc "`subtract(a,b)` subtracts `b` from `a`" subtract</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020128Z" creationid="hsugawa8651" creationdate="20181116T020128Z">
        <seg>for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc "`add(a,b)` adds `a` and `b` together" add
@doc "`subtract(a,b)` subtracts `b` from `a`" subtract</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for a in A
    &lt;x1/&gt; Do something with the element a
end

for i in eachindex(A)
    &lt;x2/&gt; Do something with i and/or A[i]
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155827Z" creationid="hsugawa8651" creationdate="20181109T155827Z">
        <seg>for a in A
    &lt;x1/&gt; Do something with the element a
end

for i in eachindex(A)
    &lt;x2/&gt; Do something with i and/or A[i]
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for i in iter   &lt;x1/&gt; or  "for i = iter"
    &lt;x2/&gt; body
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042045Z" creationid="hsugawa8651" creationdate="20181110T042045Z">
        <seg>for i in iter   &lt;x1/&gt; or  "for i = iter"
    &lt;x2/&gt; body
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for line = lines
    m = match(r"^\s*(?:&lt;x1/&gt;|$)", line)
    if m === nothing
        &lt;x2/&gt; non-comment
    else
        &lt;x3/&gt; comment
    end
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015629Z" creationid="hsugawa8651" creationdate="20181116T015629Z">
        <seg>for line = lines
    m = match(r"^\s*(?:&lt;x1/&gt;|$)", line)
    if m === nothing
        &lt;x2/&gt; non-comment
    else
        &lt;x3/&gt; comment
    end
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for op = (:sin, :cos, :tan, :log, :exp)
    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015604Z" creationid="hsugawa8651" creationdate="20181116T015604Z">
        <seg>for op = (:sin, :cos, :tan, :log, :exp)
    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for op = (:sin, :cos, :tan, :log, :exp)
    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015602Z" creationid="hsugawa8651" creationdate="20181116T015602Z">
        <seg>for op = (:sin, :cos, :tan, :log, :exp)
    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for op = (:sin, :cos, :tan, :log, :exp)
    eval(quote
        Base.$op(a::MyNumber) = MyNumber($op(a.x))
    end)
end
&lt;x1/&gt; output</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015540Z" creationid="hsugawa8651" creationdate="20181116T015540Z">
        <seg>for op = (:sin, :cos, :tan, :log, :exp)
    eval(quote
        Base.$op(a::MyNumber) = MyNumber($op(a.x))
    end)
end
&lt;x1/&gt; output</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>free(ptr)&lt;x1/&gt; when the returned &lt;x2/&gt;Array&lt;x3/&gt; object is finalized.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152608Z" creationid="hsugawa8651" creationdate="20181117T152608Z">
        <seg>返された&lt;x2/&gt;アレイ&lt;x3/&gt;オブジェクトがファイナライズされたときに、フリー(ptr)&lt;x1/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType
    &lt;x1/&gt; Scan the inputs for the ArrayAndChar:
    A = find_aac(bc)
    &lt;x2/&gt; Use the char field of A to create the output
    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)
end

"`A = find_aac(As)` returns the first ArrayAndChar among the arguments."
find_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)
find_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))
find_aac(x) = x
find_aac(a::ArrayAndChar, rest) = a
find_aac(::Any, rest) = find_aac(rest)
&lt;x3/&gt; output
find_aac (generic function with 5 methods)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131423Z" creationid="hsugawa8651" creationdate="20181113T131423Z">
        <seg>function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType
    &lt;x1/&gt; Scan the inputs for the ArrayAndChar:
    A = find_aac(bc)
    &lt;x2/&gt; Use the char field of A to create the output
    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)
end

"`A = find_aac(As)` returns the first ArrayAndChar among the arguments."
find_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)
find_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))
find_aac(x) = x
find_aac(a::ArrayAndChar, rest) = a
find_aac(::Any, rest) = find_aac(rest)
&lt;x3/&gt; output
find_aac (generic function with 5 methods)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function Date(y::Int64, m::Int64=1, d::Int64=1)
    err = validargs(Date, y, m, d)
    err === nothing || throw(err)
    return Date(UTD(totaldays(y, m, d)))
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030121Z" creationid="hsugawa8651" creationdate="20181110T030121Z">
        <seg>function Date(y::Int64, m::Int64=1, d::Int64=1)
    err = validargs(Date, y, m, d)
    err === nothing || throw(err)
    return Date(UTD(totaldays(y, m, d)))
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, "libLAPACK"),
                    Float64,
                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),
                    n, DX, incx, DY, incy)
    return product
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151848Z" creationid="hsugawa8651" creationdate="20181117T151848Z">
        <seg>function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, "libLAPACK"),
                    Float64,
                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),
                    n, DX, incx, DY, incy)
    return product
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function double!(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021222Z" creationid="hsugawa8651" creationdate="20181116T021222Z">
        <seg>function double!(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function double(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021219Z" creationid="hsugawa8651" creationdate="20181116T021219Z">
        <seg>function double(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function f(;x::Int=1)
    &lt;x1/&gt;
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030145Z" creationid="hsugawa8651" creationdate="20181110T030145Z">
        <seg>function f(;x::Int=1)
    &lt;x1/&gt;
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function f(x, a=b, b=1)
    &lt;x1/&gt;
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030205Z" creationid="hsugawa8651" creationdate="20181110T030205Z">
        <seg>function f(x, a=b, b=1)
    &lt;x1/&gt;
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function f(x; y)
    &lt;x1/&gt;
end
f(3, y=5) &lt;x2/&gt; ok, y is assigned
f(3)      &lt;x3/&gt; throws UndefKeywordError(:y)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030153Z" creationid="hsugawa8651" creationdate="20181110T030153Z">
        <seg>function f(x; y)
    &lt;x1/&gt;
end
f(3, y=5) &lt;x2/&gt; ok, y is assigned
f(3)      &lt;x3/&gt; throws UndefKeywordError(:y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function f(x; y=0, kwargs...)
    &lt;x1/&gt;
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030148Z" creationid="hsugawa8651" creationdate="20181110T030148Z">
        <seg>function f(x; y=0, kwargs...)
    &lt;x1/&gt;
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function foo(a,b)
    return a+b, a*b
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030038Z" creationid="hsugawa8651" creationdate="20181110T030038Z">
        <seg>function foo(a,b)
    return a+b, a*b
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021210Z" creationid="hsugawa8651" creationdate="20181116T021210Z">
        <seg>function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021214Z" creationid="hsugawa8651" creationdate="20181116T021214Z">
        <seg>function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function g(x,y)
    return x * y
    x + y
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025734Z" creationid="hsugawa8651" creationdate="20181110T025734Z">
        <seg>function g(x,y)
    return x * y
    x + y
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function getenv(var::AbstractString)
    val = ccall((:getenv, "libc"),
                Cstring, (Cstring,), var)
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    unsafe_string(val)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224118Z" creationid="hsugawa8651" creationdate="20181109T224118Z">
        <seg>function getenv(var::AbstractString)
    val = ccall((:getenv, "libc"),
                Cstring, (Cstring,), var)
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    unsafe_string(val)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function gethostname()
    hostname = Vector{UInt8}(undef, 128)
    ccall((:gethostname, "libc"), Int32,
          (Ptr{UInt8}, Csize_t),
          hostname, sizeof(hostname))
    hostname[end] = 0; &lt;x1/&gt; ensure null-termination
    return unsafe_string(pointer(hostname))
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022628Z" creationid="hsugawa8651" creationdate="20181116T022628Z">
        <seg>function gethostname()
    hostname = Vector{UInt8}(undef, 128)
    ccall((:gethostname, "libc"), Int32,
          (Ptr{UInt8}, Csize_t),
          hostname, sizeof(hostname))
    hostname[end] = 0; &lt;x1/&gt; ensure null-termination
    return unsafe_string(pointer(hostname))
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054322Z" creationid="hsugawa8651" creationdate="20181116T054322Z">
        <seg>function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function matmul(a::AbstractMatrix, b::AbstractMatrix)
    op = (ai, bi) -&gt; ai * bi + ai * bi

    &lt;x1/&gt; this is insufficient because it assumes `one(eltype(a))` is constructable:
    &lt;x2/&gt; R = typeof(op(one(eltype(a)), one(eltype(b))))

    &lt;x3/&gt; this fails because it assumes `a[1]` exists and is representative of all elements of the array
    &lt;x4/&gt; R = typeof(op(a[1], b[1]))

    &lt;x5/&gt; this is incorrect because it assumes that `+` calls `promote_type`
    &lt;x6/&gt; but this is not true for some types, such as Bool:
    &lt;x7/&gt; R = promote_type(ai, bi)

    &lt;x8/&gt; this is wrong, since depending on the return value
    &lt;x9/&gt; of type-inference is very brittle (as well as not being optimizable):
    &lt;x10/&gt; R = Base.return_types(op, (eltype(a), eltype(b)))

    &lt;x11/&gt; but, finally, this works:
    R = promote_op(op, eltype(a), eltype(b))
    &lt;x12/&gt; although sometimes it may give a larger type than desired
    &lt;x13/&gt; it will always give a correct type

    output = similar(b, R, (size(a, 1), size(b, 2)))
    if size(a, 2) &gt; 0
        for j in 1:size(b, 2)
            for i in 1:size(b, 1)
                &lt;x14/&gt; here we don't use `ab = zero(R)`,
                &lt;x15/&gt; since `R` might be `Any` and `zero(Any)` is not defined
                &lt;x16/&gt; we also must declare `ab::R` to make the type of `ab` constant in the loop,
                &lt;x17/&gt; since it is possible that typeof(a * b) != typeof(a * b + a * b) == R
                ab::R = a[i, 1] * b[1, j]
                for k in 2:size(a, 2)
                    ab += a[i, k] * b[k, j]
                end
                output[i, j] = ab
            end
        end
    end
    return output
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054234Z" creationid="hsugawa8651" creationdate="20181116T054234Z">
        <seg>function matmul(a::AbstractMatrix, b::AbstractMatrix)
    op = (ai, bi) -&gt; ai * bi + ai * bi

    &lt;x1/&gt; this is insufficient because it assumes `one(eltype(a))` is constructable:
    &lt;x2/&gt; R = typeof(op(one(eltype(a)), one(eltype(b))))

    &lt;x3/&gt; this fails because it assumes `a[1]` exists and is representative of all elements of the array
    &lt;x4/&gt; R = typeof(op(a[1], b[1]))

    &lt;x5/&gt; this is incorrect because it assumes that `+` calls `promote_type`
    &lt;x6/&gt; but this is not true for some types, such as Bool:
    &lt;x7/&gt; R = promote_type(ai, bi)

    &lt;x8/&gt; this is wrong, since depending on the return value
    &lt;x9/&gt; of type-inference is very brittle (as well as not being optimizable):
    &lt;x10/&gt; R = Base.return_types(op, (eltype(a), eltype(b)))

    &lt;x11/&gt; but, finally, this works:
    R = promote_op(op, eltype(a), eltype(b))
    &lt;x12/&gt; although sometimes it may give a larger type than desired
    &lt;x13/&gt; it will always give a correct type

    output = similar(b, R, (size(a, 1), size(b, 2)))
    if size(a, 2) &gt; 0
        for j in 1:size(b, 2)
            for i in 1:size(b, 1)
                &lt;x14/&gt; here we don't use `ab = zero(R)`,
                &lt;x15/&gt; since `R` might be `Any` and `zero(Any)` is not defined
                &lt;x16/&gt; we also must declare `ab::R` to make the type of `ab` constant in the loop,
                &lt;x17/&gt; since it is possible that typeof(a * b) != typeof(a * b + a * b) == R
                ab::R = a[i, 1] * b[1, j]
                for k in 2:size(a, 2)
                    ab += a[i, k] * b[k, j]
                end
                output[i, j] = ab
            end
        end
    end
    return output
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  &lt;x1/&gt; now perform the "real" computation
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054456Z" creationid="hsugawa8651" creationdate="20181116T054456Z">
        <seg>function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  &lt;x1/&gt; now perform the "real" computation
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function myplus(x,y)
    x+y
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021608Z" creationid="hsugawa8651" creationdate="20181116T021608Z">
        <seg>function myplus(x,y)
    x+y
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function myplus(x::Int,y::Int)
    x+y
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021612Z" creationid="hsugawa8651" creationdate="20181116T021612Z">
        <seg>function myplus(x::Int,y::Int)
    x+y
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function norm(p::Point{&lt;:Real})
    sqrt(p.x^2 + p.y^2)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021803Z" creationid="hsugawa8651" creationdate="20181116T021803Z">
        <seg>function norm(p::Point{&lt;:Real})
    sqrt(p.x^2 + p.y^2)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030220Z" creationid="hsugawa8651" creationdate="20181110T030220Z">
        <seg>function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function plot(x, y; style="solid", width=1, color="black")
    &lt;x1/&gt;
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030138Z" creationid="hsugawa8651" creationdate="20181110T030138Z">
        <seg>function plot(x, y; style="solid", width=1, color="black")
    &lt;x1/&gt;
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError("this method can only qsort isbits arrays"))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    &lt;x1/&gt; Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    &lt;x2/&gt; (and protected against finalization) by the ccall
    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),
        a, length(a), Base.elsize(a), callback)
    &lt;x3/&gt; We could instead use:
    &lt;x4/&gt;    GC.@preserve callback begin
    &lt;x5/&gt;        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    &lt;x6/&gt;    end
    &lt;x7/&gt; if we needed to use it outside of a `ccall`
    return a
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152345Z" creationid="hsugawa8651" creationdate="20181117T152345Z">
        <seg>function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError("this method can only qsort isbits arrays"))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    &lt;x1/&gt; Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    &lt;x2/&gt; (and protected against finalization) by the ccall
    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),
        a, length(a), Base.elsize(a), callback)
    &lt;x3/&gt; We could instead use:
    &lt;x4/&gt;    GC.@preserve callback begin
    &lt;x5/&gt;        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    &lt;x6/&gt;    end
    &lt;x7/&gt; if we needed to use it outside of a `ccall`
    return a
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021540Z" creationid="hsugawa8651" creationdate="20181116T021540Z">
        <seg>function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
    if N != length(I)
        throw(ArgumentError("Number of dimensions must match number of indices."))
    end
    if @generated
        ex = :(I[$N] - 1)
        for i = (N - 1):-1:1
            ex = :(I[$i] - 1 + dims[$i] * $ex)
        end
        return :($ex + 1)
    else
        ind = I[N] - 1
        for i = (N - 1):-1:1
            ind = I[i] - 1 + dims[i]*ind
        end
        return ind + 1
    end
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032354Z" creationid="hsugawa8651" creationdate="20181116T032354Z">
        <seg>function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
    if N != length(I)
        throw(ArgumentError("Number of dimensions must match number of indices."))
    end
    if @generated
        ex = :(I[$N] - 1)
        for i = (N - 1):-1:1
            ex = :(I[$i] - 1 + dims[$i] * $ex)
        end
        return :($ex + 1)
    else
        ind = I[N] - 1
        for i = (N - 1):-1:1
            ind = I[i] - 1 + dims[i]*ind
        end
        return ind + 1
    end
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>g(x::A) = x</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054437Z" creationid="hsugawa8651" creationdate="20181116T054437Z">
        <seg>g(x::A) = x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>g., &lt;x7/&gt;√√-a&lt;x8/&gt; as &lt;x9/&gt;√(√(-a))&lt;x10/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030932Z" creationid="hsugawa8651" creationdate="20181114T030932Z">
        <seg>g., &lt;x7/&gt;√√-a&lt;x8/&gt; as &lt;x9/&gt;√(√(-a))&lt;x10/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>getenv&lt;x1/&gt; C library function is wrapped in the following Julia function,
which is a simplified version of the actual definition from &lt;x2/&gt;`env.jl`&lt;x3/&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224115Z" creationid="hsugawa8651" creationdate="20181109T224115Z">
        <seg>getenv&lt;x1/&gt;Cライブラリ関数は、次のJulia関数にラップされています。 これは、&lt;x2/&gt;'env.jl'&lt;x3/&gt;からの実際の定義の簡略化されたバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>getindex(A, I...)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113332Z" creationid="hsugawa8651" creationdate="20181112T113332Z">
        <seg>getindex(A, I...)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>getindex(A, I::Vararg{Int, N})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113231Z" creationid="hsugawa8651" creationdate="20181112T113231Z">
        <seg>getindex(A, I::Vararg{Int, N})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>getindex(A, i::Int)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113222Z" creationid="hsugawa8651" creationdate="20181112T113222Z">
        <seg>getindex(A, i::Int)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>getindex(A::ArrayType, i::Int)&lt;x1/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022831Z" creationid="hsugawa8651" creationdate="20181113T022831Z">
        <seg>getindex(A::ArrayType, i::Int)&lt;x1/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>getindex(X, i)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112956Z" creationid="hsugawa8651" creationdate="20181112T112956Z">
        <seg>getindex(X, i)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>graph = Dict{UUID,Dict{Symbol,UUID}}(
    &lt;x1/&gt; Bobcat:
    UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf") =&gt; Dict{Symbol,UUID}(
        :Cobra =&gt; UUID("4725e24d-f727-424b-bca0-c4307a3456fa"),
        :Dingo =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    &lt;x2/&gt; Cobra:
    UUID("4725e24d-f727-424b-bca0-c4307a3456fa") =&gt; Dict{Symbol,UUID}(
        :Dingo =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    &lt;x3/&gt; Dingo:
    UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc") =&gt; Dict{Symbol,UUID}(),
)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015950Z" creationid="hsugawa8651" creationdate="20181116T015950Z">
        <seg>graph = Dict{UUID,Dict{Symbol,UUID}}(
    &lt;x1/&gt; Bobcat:
    UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf") =&gt; Dict{Symbol,UUID}(
        :Cobra =&gt; UUID("4725e24d-f727-424b-bca0-c4307a3456fa"),
        :Dingo =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    &lt;x2/&gt; Cobra:
    UUID("4725e24d-f727-424b-bca0-c4307a3456fa") =&gt; Dict{Symbol,UUID}(
        :Dingo =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    &lt;x3/&gt; Dingo:
    UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc") =&gt; Dict{Symbol,UUID}(),
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>graph = Dict{UUID,Dict{Symbol,UUID}}(
    &lt;x1/&gt; Priv – the private one:
    UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b") =&gt; Dict{Symbol,UUID}(
        :Pub   =&gt; UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
        :Zebra =&gt; UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    &lt;x2/&gt; Priv – the public one:
    UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c") =&gt; Dict{Symbol,UUID}(),
    &lt;x3/&gt; Pub:
    UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1") =&gt; Dict{Symbol,UUID}(
        :Priv  =&gt; UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"),
        :Zebra =&gt; UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    &lt;x4/&gt; Zebra:
    UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62") =&gt; Dict{Symbol,UUID}(),
)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015916Z" creationid="hsugawa8651" creationdate="20181116T015916Z">
        <seg>graph = Dict{UUID,Dict{Symbol,UUID}}(
    &lt;x1/&gt; Priv – the private one:
    UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b") =&gt; Dict{Symbol,UUID}(
        :Pub   =&gt; UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
        :Zebra =&gt; UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    &lt;x2/&gt; Priv – the public one:
    UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c") =&gt; Dict{Symbol,UUID}(),
    &lt;x3/&gt; Pub:
    UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1") =&gt; Dict{Symbol,UUID}(
        :Priv  =&gt; UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"),
        :Zebra =&gt; UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    &lt;x4/&gt; Zebra:
    UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62") =&gt; Dict{Symbol,UUID}(),
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>graph[UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1")][:Priv]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015922Z" creationid="hsugawa8651" creationdate="20181116T015922Z">
        <seg>graph[UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1")][:Priv]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>greater than</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030425Z" creationid="hsugawa8651" creationdate="20181114T030425Z">
        <seg>より大きい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>greater than or equal to</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030448Z" creationid="hsugawa8651" creationdate="20181114T030448Z">
        <seg>以上</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gsl_permutation&lt;x1/&gt;,
that has no internal fields and whose sole purpose is to be placed in the type parameter of a
&lt;x2/&gt;Ptr&lt;x3/&gt; type.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152044Z" creationid="hsugawa8651" creationdate="20181117T152044Z">
        <seg>gsl remutation&lt;x1/&gt; は、内部フィールドを持たず、その唯一の目的は &lt;x2/&gt;Ptr&lt;x3/&gt;型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>half&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110231Z" creationid="hsugawa8651" creationdate="20181112T110231Z">
        <seg>half&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152443Z" creationid="hsugawa8651" creationdate="20181117T152436Z">
        <seg>hn=Vector{UInt8}(undef,256) err=ccall(:gethostname,stdcall,Int32,(Ptr{UInt8},UInt32),hn,長さ(hn))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (a == b)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021308Z" creationid="hsugawa8651" creationdate="20181116T021308Z">
        <seg>if (a == b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if &lt;x1/&gt;T&lt;x2/&gt; is an &lt;x3/&gt;enum&lt;x4/&gt;, the argument type should be equivalent to &lt;x5/&gt;Cint&lt;x6/&gt; or &lt;x7/&gt;Cuint&lt;x8/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151512Z" creationid="hsugawa8651" creationdate="20181117T151512Z">
        <seg>&lt;x1/&gt;T&lt;x2/&gt;が&lt;x3/&gt;enum&lt;x4/&gt;の場合、引数のタイプは&lt;x5/&gt;Cint&lt;x6/&gt;または&lt;x7/&gt;Cuint&lt;x8/&gt;と同等である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022042Z" creationid="hsugawa8651" creationdate="20181116T022042Z">
        <seg>if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if Sys.iswindows()
    windows_specific_thing(a)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224833Z" creationid="hsugawa8651" creationdate="20181109T224833Z">
        <seg>if Sys.iswindows()
    windows_specific_thing(a)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if a == b</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021303Z" creationid="hsugawa8651" creationdate="20181116T021303Z">
        <seg>if a == b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if condition()
    "..."
    f(x) = x
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020140Z" creationid="hsugawa8651" creationdate="20181116T020140Z">
        <seg>if condition()
    "..."
    f(x) = x
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if v"0.2" &lt;= VERSION &lt; v"0.3-"
    &lt;x1/&gt; do something specific to 0.2 release series
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021112Z" creationid="hsugawa8651" creationdate="20181116T021112Z">
        <seg>if v"0.2" &lt;= VERSION &lt; v"0.3-"
    &lt;x1/&gt; do something specific to 0.2 release series
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if x &lt; y
    println("x is less than y")
elseif x &gt; y
    println("x is greater than y")
else
    println("x is equal to y")
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225839Z" creationid="hsugawa8651" creationdate="20181109T225839Z">
        <seg>if x &lt; y
    println("x is less than y")
elseif x &gt; y
    println("x is greater than y")
else
    println("x is equal to y")
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if&lt;x1/&gt; blocks also return a value, which may seem unintuitive to users coming from many other languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230019Z" creationid="hsugawa8651" creationdate="20181109T230019Z">
        <seg>もし&lt;x1/&gt;ブロックが値を返すと、他の多くの言語から来るユーザーにとって直感的ではないように思えるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if&lt;x1/&gt; blocks are "leaky", i.e. they do not introduce a local scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225914Z" creationid="hsugawa8651" creationdate="20181109T225914Z">
        <seg>&lt;x1/&gt;ブロックが「リーク」である場合、すなわち、ローカルスコープを導入しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if_true : if_false&lt;x2/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063208Z" creationid="hsugawa8651" creationdate="20181114T063208Z">
        <seg>if_true : if_false&lt;x2/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>import Foo
function bar(...)
    &lt;x1/&gt; ... refer to Foo symbols via Foo.baz ...
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025140Z" creationid="hsugawa8651" creationdate="20181110T025140Z">
        <seg>import Foo
function bar(...)
    &lt;x1/&gt; ... refer to Foo symbols via Foo.baz ...
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in C:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151157Z" creationid="hsugawa8651" creationdate="20181117T151157Z">
        <seg>C:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in Julia:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151205Z" creationid="hsugawa8651" creationdate="20181117T151200Z">
        <seg>ジュリア:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>include("mynewcode.jl")              &lt;x1/&gt; this defines a module MyModule
obj1 = MyModule.ObjConstructor(a, b)
obj2 = MyModule.somefunction(obj1)
&lt;x2/&gt; Got an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024750Z" creationid="hsugawa8651" creationdate="20181110T024750Z">
        <seg>include("mynewcode.jl")              &lt;x1/&gt; this defines a module MyModule
obj1 = MyModule.ObjConstructor(a, b)
obj2 = MyModule.somefunction(obj1)
&lt;x2/&gt; Got an error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>index an entire dimension (firstindex:lastindex), see &lt;x1/&gt;`Colon`&lt;x2/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063546Z" creationid="hsugawa8651" creationdate="20181114T063546Z">
        <seg>索引全体(firstindex:lastindex)をインデックス化します。&lt;x1/&gt;`コロン`&lt;x2/&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>indicates that &lt;x1/&gt;Tuple&lt;x2/&gt; "wins" over zero-dimensional arrays (the output container will be a tuple).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131755Z" creationid="hsugawa8651" creationdate="20181113T131755Z">
        <seg>&lt;x1/&gt;タプル&lt;x2/&gt;"が0次元配列に対して(出力コンテナはタプルになります)"勝ち"であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input = convert(AbstractArray{Eltype}, input)
output = similar(input, Eltype)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054157Z" creationid="hsugawa8651" creationdate="20181116T054157Z">
        <seg>input = convert(AbstractArray{Eltype}, input)
output = similar(input, Eltype)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>integer divide</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132104Z" creationid="hsugawa8651" creationdate="20181113T132104Z">
        <seg>整数除算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>invoke macro &lt;x1/&gt;m&lt;x2/&gt;; followed by space-separated expressions</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032235Z" creationid="hsugawa8651" creationdate="20181114T032229Z">
        <seg>呼び出しマクロ&lt;x1/&gt;m&lt;x2/&gt;;それに続く空間的に区切られた式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>io = IOBuffer()
Base.banner(io)
banner = String(take!(io))
import Markdown
Markdown.parse("```\n\$ julia\n\n$(banner)\njulia&gt; 1 + 2\n3\n\njulia&gt; ans\n3\n```")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224257Z" creationid="hsugawa8651" creationdate="20181109T224257Z">
        <seg>io = IOBuffer()
Base.banner(io)
banner = String(take!(io))
import Markdown
Markdown.parse("```\n\$ julia\n\n$(banner)\njulia&gt; 1 + 2\n3\n\njulia&gt; ans\n3\n```")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is translated into:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042111Z" creationid="hsugawa8651" creationdate="20181110T042111Z">
        <seg>は次のように変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>isequal&lt;x1/&gt; can also be used to distinguish signed zeros:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030613Z" creationid="hsugawa8651" creationdate="20181114T030613Z">
        <seg>isequal&lt;x1/&gt; can also be used to distinguish signed zeros:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iterate(iter)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112056Z" creationid="hsugawa8651" creationdate="20181112T112056Z">
        <seg>iterate(iter)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iterate(iter, state)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112106Z" creationid="hsugawa8651" creationdate="20181112T112106Z">
        <seg>iterate(iter, state)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jl_value_t**&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151537Z" creationid="hsugawa8651" creationdate="20181117T151537Z">
        <seg>jl_value_t**&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jl_value_t*&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151529Z" creationid="hsugawa8651" creationdate="20181117T151529Z">
        <seg>jl_value_t*&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jl_value_t*&lt;x1/&gt; pointers, as &lt;x2/&gt;Ptr{Cvoid}&lt;x3/&gt;, by calling &lt;x4/&gt;`pointer_from_objref(v)`&lt;x5/&gt;.)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152556Z" creationid="hsugawa8651" creationdate="20181117T152556Z">
        <seg>jl_value_t*&lt;x2/&gt;ポインタは&lt;x2/&gt;Ptr{Cvoid}&lt;x3/&gt;、&lt;x4/&gt;'ポインタ_from_objref(v)`&lt;x5/&gt;を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia -L _init.jl</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022550Z" creationid="hsugawa8651" creationdate="20181116T022550Z">
        <seg>julia -L _init.jl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia [switches] -- [programfile] [args...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224522Z" creationid="hsugawa8651" creationdate="20181109T224522Z">
        <seg>julia [switches] -- [programfile] [args...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt;      :(a + b*c + 1)       ==
       Meta.parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015123Z" creationid="hsugawa8651" creationdate="20181116T015123Z">
        <seg>julia&gt;      :(a + b*c + 1)       ==
       Meta.parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; """
         Hello,
         world."""
"Hello,\nworld."</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020857Z" creationid="hsugawa8651" creationdate="20181116T020857Z">
        <seg>julia&gt; """
         Hello,
         world."""
"Hello,\nworld."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; """    This
         is
           a test"""
"    This\nis\n  a test"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020837Z" creationid="hsugawa8651" creationdate="20181116T020837Z">
        <seg>julia&gt; """    This
         is
           a test"""
"    This\nis\n  a test"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; "$greet, $whom.\n"
"Hello, world.\n"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020804Z" creationid="hsugawa8651" creationdate="20181116T020804Z">
        <seg>julia&gt; "$greet, $whom.\n"
"Hello, world.\n"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; "1 + 2 = $(1 + 2)"
"1 + 2 = 3"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020810Z" creationid="hsugawa8651" creationdate="20181116T020810Z">
        <seg>julia&gt; "1 + 2 = $(1 + 2)"
"1 + 2 = 3"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; "abracadabra" &lt; "xylophone"
true

julia&gt; "abracadabra" == "xylophone"
false

julia&gt; "Hello, world." != "Goodbye, world."
true

julia&gt; "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020903Z" creationid="hsugawa8651" creationdate="20181116T020903Z">
        <seg>julia&gt; "abracadabra" &lt; "xylophone"
true

julia&gt; "abracadabra" == "xylophone"
false

julia&gt; "Hello, world." != "Goodbye, world."
true

julia&gt; "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; $a + b
ERROR: syntax: "$" expression outside quote</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015151Z" creationid="hsugawa8651" creationdate="20181116T015151Z">
        <seg>julia&gt; $a + b
ERROR: syntax: "$" expression outside quote</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 'A' &lt; 'a'
true

julia&gt; 'A' &lt;= 'a' &lt;= 'Z'
false

julia&gt; 'A' &lt;= 'X' &lt;= 'Z'
true

julia&gt; 'x' - 'a'
23

julia&gt; 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020534Z" creationid="hsugawa8651" creationdate="20181116T020534Z">
        <seg>julia&gt; 'A' &lt; 'a'
true

julia&gt; 'A' &lt;= 'a' &lt;= 'Z'
false

julia&gt; 'A' &lt;= 'X' &lt;= 'Z'
true

julia&gt; 'x' - 'a'
23

julia&gt; 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)

julia&gt; '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia&gt; '\U10ffff'
'\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020529Z" creationid="hsugawa8651" creationdate="20181116T020529Z">
        <seg>julia&gt; '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)

julia&gt; '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia&gt; '\U10ffff'
'\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; typeof(ans)
Char</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020508Z" creationid="hsugawa8651" creationdate="20181116T020508Z">
        <seg>julia&gt; 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; typeof(ans)
Char</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; (1+2)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got Int64

julia&gt; (1+2)::Int
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021429Z" creationid="hsugawa8651" creationdate="20181116T021429Z">
        <seg>julia&gt; (1+2)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got Int64

julia&gt; (1+2)::Int
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; (1, 1+1)
(1, 2)

julia&gt; (1,)
(1,)

julia&gt; x = (0.0, "hello", 6*7)
(0.0, "hello", 42)

julia&gt; x[2]
"hello"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030017Z" creationid="hsugawa8651" creationdate="20181110T030017Z">
        <seg>julia&gt; (1, 1+1)
(1, 2)

julia&gt; (1,)
(1,)

julia&gt; x = (0.0, "hello", 6*7)
(0.0, "hello", 42)

julia&gt; x[2]
"hello"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; (Cstring)
Cstring

julia&gt; (Cstring,)
(Cstring,)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224103Z" creationid="hsugawa8651" creationdate="20181109T224103Z">
        <seg>julia&gt; (Cstring)
Cstring

julia&gt; (Cstring,)
(Cstring,)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; (typemin(Float16),typemax(Float16))
(-Inf16, Inf16)

julia&gt; (typemin(Float32),typemax(Float32))
(-Inf32, Inf32)

julia&gt; (typemin(Float64),typemax(Float64))
(-Inf, Inf)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110853Z" creationid="hsugawa8651" creationdate="20181112T110853Z">
        <seg>julia&gt; (typemin(Float16),typemax(Float16))
(-Inf16, Inf16)

julia&gt; (typemin(Float32),typemax(Float32))
(-Inf32, Inf32)

julia&gt; (typemin(Float64),typemax(Float64))
(-Inf, Inf)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia&gt; for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225534Z" creationid="hsugawa8651" creationdate="20181109T225534Z">
        <seg>julia&gt; (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia&gt; for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia&gt; x(x+1)
ERROR: MethodError: objects of type Int64 are not callable</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111843Z" creationid="hsugawa8651" creationdate="20181112T111843Z">
        <seg>julia&gt; (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia&gt; x(x+1)
ERROR: MethodError: objects of type Int64 are not callable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; (x-1)x
6</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111836Z" creationid="hsugawa8651" creationdate="20181112T111836Z">
        <seg>julia&gt; (x-1)x
6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030616Z" creationid="hsugawa8651" creationdate="20181114T030616Z">
        <seg>julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; -0x2
0xfe

julia&gt; -0x0002
0xfffe</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225522Z" creationid="hsugawa8651" creationdate="20181109T225522Z">
        <seg>julia&gt; -0x2
0xfe

julia&gt; -0x0002
0xfffe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 0.0 == -0.0
true

julia&gt; bitstring(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"

julia&gt; bitstring(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110748Z" creationid="hsugawa8651" creationdate="20181112T110748Z">
        <seg>julia&gt; 0.0 == -0.0
true

julia&gt; bitstring(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"

julia&gt; bitstring(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 0.5f0
0.5f0

julia&gt; typeof(ans)
Float32

julia&gt; 2.5f-4
0.00025f0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110606Z" creationid="hsugawa8651" creationdate="20181112T110606Z">
        <seg>julia&gt; 0.5f0
0.5f0

julia&gt; typeof(ans)
Float32

julia&gt; 2.5f-4
0.00025f0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 0b10
0x02

julia&gt; typeof(ans)
UInt8

julia&gt; 0o010
0x08

julia&gt; typeof(ans)
UInt8

julia&gt; 0x00000000000000001111222233334444
0x00000000000000001111222233334444

julia&gt; typeof(ans)
UInt128</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225357Z" creationid="hsugawa8651" creationdate="20181109T225357Z">
        <seg>julia&gt; 0b10
0x02

julia&gt; typeof(ans)
UInt8

julia&gt; 0o010
0x08

julia&gt; typeof(ans)
UInt8

julia&gt; 0x00000000000000001111222233334444
0x00000000000000001111222233334444

julia&gt; typeof(ans)
UInt128</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 0x1
0x01

julia&gt; typeof(ans)
UInt8

julia&gt; 0x123
0x0123

julia&gt; typeof(ans)
UInt16

julia&gt; 0x1234567
0x01234567

julia&gt; typeof(ans)
UInt32

julia&gt; 0x123456789abcdef
0x0123456789abcdef

julia&gt; typeof(ans)
UInt64

julia&gt; 0x11112222333344445555666677778888
0x11112222333344445555666677778888

julia&gt; typeof(ans)
UInt128</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110410Z" creationid="hsugawa8651" creationdate="20181112T110410Z">
        <seg>julia&gt; 0x1
0x01

julia&gt; typeof(ans)
UInt8

julia&gt; 0x123
0x0123

julia&gt; typeof(ans)
UInt16

julia&gt; 0x1234567
0x01234567

julia&gt; typeof(ans)
UInt32

julia&gt; 0x123456789abcdef
0x0123456789abcdef

julia&gt; typeof(ans)
UInt64

julia&gt; 0x11112222333344445555666677778888
0x11112222333344445555666677778888

julia&gt; typeof(ans)
UInt128</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 0x1p0
1.0

julia&gt; 0x1.8p3
12.0

julia&gt; 0x.4p-1
0.125

julia&gt; typeof(ans)
Float64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110706Z" creationid="hsugawa8651" creationdate="20181112T110706Z">
        <seg>julia&gt; 0x1p0
1.0

julia&gt; 0x1.8p3
12.0

julia&gt; 0x.4p-1
0.125

julia&gt; typeof(ans)
Float64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1
1

julia&gt; 1234
1234</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225207Z" creationid="hsugawa8651" creationdate="20181109T225207Z">
        <seg>julia&gt; 1
1

julia&gt; 1234
1234</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1 &amp;&amp; true
ERROR: TypeError: non-boolean (Int64) used in boolean context</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230815Z" creationid="hsugawa8651" creationdate="20181109T230815Z">
        <seg>julia&gt; 1 &amp;&amp; true
ERROR: TypeError: non-boolean (Int64) used in boolean context</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1 + 2 + 3
6

julia&gt; +(1,2,3)
6</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025821Z" creationid="hsugawa8651" creationdate="20181110T025821Z">
        <seg>julia&gt; 1 + 2 + 3
6

julia&gt; +(1,2,3)
6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132214Z" creationid="hsugawa8651" creationdate="20181113T132214Z">
        <seg>julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030714Z" creationid="hsugawa8651" creationdate="20181114T030714Z">
        <seg>julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030451Z" creationid="hsugawa8651" creationdate="20181114T030451Z">
        <seg>julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1.0
1.0

julia&gt; 1.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110548Z" creationid="hsugawa8651" creationdate="20181112T110548Z">
        <seg>julia&gt; 1.0
1.0

julia&gt; 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 1/Inf
0.0

julia&gt; 1/0
Inf

julia&gt; -5/0
-Inf

julia&gt; 0.000001/0
Inf

julia&gt; 0/0
NaN

julia&gt; 500 + Inf
Inf

julia&gt; 500 - Inf
-Inf

julia&gt; Inf + Inf
Inf

julia&gt; Inf - Inf
NaN

julia&gt; Inf * Inf
Inf

julia&gt; Inf / Inf
NaN

julia&gt; 0 * Inf
NaN</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110848Z" creationid="hsugawa8651" creationdate="20181112T110848Z">
        <seg>julia&gt; 1/Inf
0.0

julia&gt; 1/0
Inf

julia&gt; -5/0
-Inf

julia&gt; 0.000001/0
Inf

julia&gt; 0/0
NaN

julia&gt; 500 + Inf
Inf

julia&gt; 500 - Inf
-Inf

julia&gt; Inf + Inf
Inf

julia&gt; Inf - Inf
NaN

julia&gt; Inf * Inf
Inf

julia&gt; Inf / Inf
NaN

julia&gt; 0 * Inf
NaN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 2(x-1)^2 - 3(x-1) + 1
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111809Z" creationid="hsugawa8651" creationdate="20181112T111809Z">
        <seg>julia&gt; 2(x-1)^2 - 3(x-1) + 1
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 25 in Squares(10)
true

julia&gt; using Statistics

julia&gt; mean(Squares(100))
3383.5

julia&gt; std(Squares(100))
3024.355854282583</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112556Z" creationid="hsugawa8651" creationdate="20181112T112556Z">
        <seg>julia&gt; 25 in Squares(10)
true

julia&gt; using Statistics

julia&gt; mean(Squares(100))
3383.5

julia&gt; std(Squares(100))
3024.355854282583</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; 2^2x
64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111740Z" creationid="hsugawa8651" creationdate="20181112T111740Z">
        <seg>julia&gt; 2^2x
64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; :(1 + 2)
:(1 + 2)

julia&gt; eval(ans)
3

julia&gt; ex = :(a + b)
:(a + b)

julia&gt; eval(ex)
ERROR: UndefVarError: b not defined
[...]

julia&gt; a = 1; b = 2;

julia&gt; eval(ex)
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015227Z" creationid="hsugawa8651" creationdate="20181116T015227Z">
        <seg>julia&gt; :(1 + 2)
:(1 + 2)

julia&gt; eval(ans)
3

julia&gt; ex = :(a + b)
:(a + b)

julia&gt; eval(ex)
ERROR: UndefVarError: b not defined
[...]

julia&gt; a = 1; b = 2;

julia&gt; eval(ex)
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; :(:)
:(:)

julia&gt; :(::)
:(::)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015112Z" creationid="hsugawa8651" creationdate="20181116T015112Z">
        <seg>julia&gt; :(:)
:(:)

julia&gt; :(::)
:(::)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; :foo
:foo

julia&gt; typeof(ans)
Symbol</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015105Z" creationid="hsugawa8651" creationdate="20181116T015105Z">
        <seg>julia&gt; :foo
:foo

julia&gt; typeof(ans)
Symbol</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; :foo == Symbol("foo")
true

julia&gt; Symbol("func",10)
:func10

julia&gt; Symbol(:var,'_',"sym")
:var_sym</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015109Z" creationid="hsugawa8651" creationdate="20181116T015109Z">
        <seg>julia&gt; :foo == Symbol("foo")
true

julia&gt; Symbol("func",10)
:func10

julia&gt; Symbol(:var,'_',"sym")
:var_sym</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; &lt;x1/&gt;123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; &lt;x2/&gt;UInt32(123)
0xffffff84

julia&gt; &lt;x3/&gt;UInt8(123)
0x84</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132330Z" creationid="hsugawa8651" creationdate="20181113T132330Z">
        <seg>julia&gt; &lt;x1/&gt;123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; &lt;x2/&gt;UInt32(123)
0xffffff84

julia&gt; &lt;x3/&gt;UInt8(123)
0x84</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @assert 1 == 1.0

julia&gt; @assert 1 == 0
ERROR: AssertionError: 1 == 0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015423Z" creationid="hsugawa8651" creationdate="20181116T015423Z">
        <seg>julia&gt; @assert 1 == 1.0

julia&gt; @assert 1 == 0
ERROR: AssertionError: 1 == 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @generated function bar(x)
           if x &lt;: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia&gt; bar(4)
16

julia&gt; bar("baz")
"baz"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015745Z" creationid="hsugawa8651" creationdate="20181116T015745Z">
        <seg>julia&gt; @generated function bar(x)
           if x &lt;: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia&gt; bar(4)
16

julia&gt; bar("baz")
"baz"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @generated function baz(x)
           if rand() &lt; .9
               return :(x^2)
           else
               return :("boo!")
           end
       end
baz (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015748Z" creationid="hsugawa8651" creationdate="20181116T015748Z">
        <seg>julia&gt; @generated function baz(x)
           if rand() &lt; .9
               return :(x^2)
           else
               return :("boo!")
           end
       end
baz (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @generated function foo(x)
           Core.println(x)
           return :(x * x)
       end
foo (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015657Z" creationid="hsugawa8651" creationdate="20181116T015657Z">
        <seg>julia&gt; @generated function foo(x)
           Core.println(x)
           return :(x * x)
       end
foo (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen (generic function with 1 method)

julia&gt; sub2ind_gen((3, 5), 1, 2)
4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032317Z" creationid="hsugawa8651" creationdate="20181116T032317Z">
        <seg>julia&gt; @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen (generic function with 1 method)

julia&gt; sub2ind_gen((3, 5), 1, 2)
4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           return sub2ind_gen_impl(dims, I...)
       end
sub2ind_gen (generic function with 1 method)

julia&gt; function sub2ind_gen_impl(dims::Type{T}, I...) where T &lt;: NTuple{N,Any} where N
           length(I) == N || return :(error("partial indexing is unsupported"))
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen_impl (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032322Z" creationid="hsugawa8651" creationdate="20181116T032322Z">
        <seg>julia&gt; @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           return sub2ind_gen_impl(dims, I...)
       end
sub2ind_gen (generic function with 1 method)

julia&gt; function sub2ind_gen_impl(dims::Type{T}, I...) where T &lt;: NTuple{N,Any} where N
           length(I) == N || return :(error("partial indexing is unsupported"))
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen_impl (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @generated gen1(x::Real) = f(x);

julia&gt; gen1(1)
"definition for Type{Int}"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015741Z" creationid="hsugawa8651" creationdate="20181116T015741Z">
        <seg>julia&gt; @generated gen1(x::Real) = f(x);

julia&gt; gen1(1)
"definition for Type{Int}"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @macroexpand @assert a == b
:(if Main.a == Main.b
        Main.nothing
    else
        (Main.throw)((Main.AssertionError)("a == b"))
    end)

julia&gt; @macroexpand @assert a==b "a should equal b!"
:(if Main.a == Main.b
        Main.nothing
    else
        (Main.throw)((Main.AssertionError)("a should equal b!"))
    end)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015446Z" creationid="hsugawa8651" creationdate="20181116T015446Z">
        <seg>julia&gt; @macroexpand @assert a == b
:(if Main.a == Main.b
        Main.nothing
    else
        (Main.throw)((Main.AssertionError)("a == b"))
    end)

julia&gt; @macroexpand @assert a==b "a should equal b!"
:(if Main.a == Main.b
        Main.nothing
    else
        (Main.throw)((Main.AssertionError)("a should equal b!"))
    end)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @macroexpand @sayhello "human"
:((println)("Hello, ", "human"))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015313Z" creationid="hsugawa8651" creationdate="20181116T015313Z">
        <seg>julia&gt; @macroexpand @sayhello "human"
:((println)("Hello, ", "human"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia&gt; @noinline example() = try
           bad_function()
       catch
           stacktrace()
       end
example (generic function with 1 method)

julia&gt; example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[2]:4
 top-level scope
 eval at boot.jl:317 [inlined]
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020411Z" creationid="hsugawa8651" creationdate="20181116T020411Z">
        <seg>julia&gt; @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia&gt; @noinline example() = try
           bad_function()
       catch
           stacktrace()
       end
example (generic function with 1 method)

julia&gt; example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[2]:4
 top-level scope
 eval at boot.jl:317 [inlined]
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia&gt; @noinline example() = try
           bad_function()
       catch
           stacktrace(catch_backtrace())
       end
example (generic function with 1 method)

julia&gt; example()
8-element Array{Base.StackTraces.StackFrame,1}:
 bad_function() at REPL[1]:1
 example() at REPL[2]:2
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020416Z" creationid="hsugawa8651" creationdate="20181116T020416Z">
        <seg>julia&gt; @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia&gt; @noinline example() = try
           bad_function()
       catch
           stacktrace(catch_backtrace())
       end
example (generic function with 1 method)

julia&gt; example()
8-element Array{Base.StackTraces.StackFrame,1}:
 bad_function() at REPL[1]:1
 example() at REPL[2]:2
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @noinline child() = error("Whoops!")
child (generic function with 1 method)

julia&gt; @noinline parent() = child()
parent (generic function with 1 method)

julia&gt; @noinline function grandparent()
           try
               parent()
           catch err
               println("ERROR: ", err.msg)
               stacktrace(catch_backtrace())
           end
       end
grandparent (generic function with 1 method)

julia&gt; grandparent()
ERROR: Whoops!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020419Z" creationid="hsugawa8651" creationdate="20181116T020419Z">
        <seg>julia&gt; @noinline child() = error("Whoops!")
child (generic function with 1 method)

julia&gt; @noinline parent() = child()
parent (generic function with 1 method)

julia&gt; @noinline function grandparent()
           try
               parent()
           catch err
               println("ERROR: ", err.msg)
               stacktrace(catch_backtrace())
           end
       end
grandparent (generic function with 1 method)

julia&gt; grandparent()
ERROR: Whoops!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @sayhello("human")
Hello, human</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015307Z" creationid="hsugawa8651" creationdate="20181116T015307Z">
        <seg>julia&gt; @sayhello("human")
Hello, human</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; @sayhello()
Hello, world!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015301Z" creationid="hsugawa8651" creationdate="20181116T015301Z">
        <seg>julia&gt; @sayhello()
Hello, world!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083232Z" creationid="hsugawa8651" creationdate="20181113T083232Z">
        <seg>julia&gt; A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia&gt; sin.(A)
3-element Array{Float64,1}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030231Z" creationid="hsugawa8651" creationdate="20181110T030231Z">
        <seg>julia&gt; A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia&gt; sin.(A)
3-element Array{Float64,1}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = [1.3, -2.7, 4.4, 3.1]
4-element Array{Float64,1}:
  1.3
 -2.7
  4.4
  3.1

julia&gt; ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia&gt; A
4-element Array{Float64,1}:
 -2.7
  1.3
  3.1
  4.4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022704Z" creationid="hsugawa8651" creationdate="20181116T022704Z">
        <seg>julia&gt; A = [1.3, -2.7, 4.4, 3.1]
4-element Array{Float64,1}:
  1.3
 -2.7
  4.4
  3.1

julia&gt; ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia&gt; A
4-element Array{Float64,1}:
 -2.7
  1.3
  3.1
  4.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = rand(4,3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155847Z" creationid="hsugawa8651" creationdate="20181109T155847Z">
        <seg>julia&gt; A = rand(4,3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155608Z" creationid="hsugawa8651" creationdate="20181109T155608Z">
        <seg>julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[1, 2, 1, 1] &lt;x1/&gt; all scalar indices
3

julia&gt; A[[1, 2], [1], [1, 2], [1]] &lt;x2/&gt; all vector indices
2×1×2×1 Array{Int64,4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia&gt; A[[1, 2], [1], [1, 2], 1] &lt;x3/&gt; a mix of index types
2×1×2 Array{Int64,3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155139Z" creationid="hsugawa8651" creationdate="20181109T155139Z">
        <seg>julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[1, 2, 1, 1] &lt;x1/&gt; all scalar indices
3

julia&gt; A[[1, 2], [1], [1, 2], [1]] &lt;x2/&gt; all vector indices
2×1×2×1 Array{Int64,4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia&gt; A[[1, 2], [1], [1, 2], 1] &lt;x3/&gt; a mix of index types
2×1×2 Array{Int64,3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2));

julia&gt; A[[1 2; 1 2]]
2×2 Array{Int64,2}:
 1  2
 1  2

julia&gt; A[[1 2; 1 2], 1, 2, 1]
2×2 Array{Int64,2}:
 5  6
 5  6</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155157Z" creationid="hsugawa8651" creationdate="20181109T155157Z">
        <seg>julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2));

julia&gt; A[[1 2; 1 2]]
2×2 Array{Int64,2}:
 1  2
 1  2

julia&gt; A[[1 2; 1 2], 1, 2, 1]
2×2 Array{Int64,2}:
 5  6
 5  6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A = reshape(collect(1:2:18), (3, 3))
3×3 Array{Int64,2}:
 1   7  13
 3   9  15
 5  11  17

julia&gt; A[4]
7

julia&gt; A[[2, 5, 8]]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[[1 4; 3 8]]
2×2 Array{Int64,2}:
 1   7
 5  15

julia&gt; A[[]]
0-element Array{Int64,1}

julia&gt; A[1:2:5]
3-element Array{Int64,1}:
 1
 5
 9

julia&gt; A[2, :]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[:, 3]
3-element Array{Int64,1}:
 13
 15
 17</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155550Z" creationid="hsugawa8651" creationdate="20181109T155550Z">
        <seg>julia&gt; A = reshape(collect(1:2:18), (3, 3))
3×3 Array{Int64,2}:
 1   7  13
 3   9  15
 5  11  17

julia&gt; A[4]
7

julia&gt; A[[2, 5, 8]]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[[1 4; 3 8]]
2×2 Array{Int64,2}:
 1   7
 5  15

julia&gt; A[[]]
0-element Array{Int64,1}

julia&gt; A[1:2:5]
3-element Array{Int64,1}:
 1
 5
 9

julia&gt; A[2, :]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[:, 3]
3-element Array{Int64,1}:
 13
 15
 17</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083241Z" creationid="hsugawa8651" creationdate="20181113T083241Z">
        <seg>julia&gt; A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161101Z" creationid="hsugawa8651" creationdate="20181114T161101Z">
        <seg>julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia&gt; sum(A)
45.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083334Z" creationid="hsugawa8651" creationdate="20181113T083334Z">
        <seg>julia&gt; A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia&gt; sum(A)
45.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.eltype(::Type{Squares}) = Int &lt;x1/&gt; Note that this is defined for the type

julia&gt; Base.length(S::Squares) = S.count</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112644Z" creationid="hsugawa8651" creationdate="20181112T112644Z">
        <seg>julia&gt; Base.eltype(::Type{Squares}) = Int &lt;x1/&gt; Note that this is defined for the type

julia&gt; Base.length(S::Squares) = S.count</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.firstindex(S::Squares) = 1

julia&gt; Base.lastindex(S::Squares) = length(S)

julia&gt; Squares(23)[end]
529</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113120Z" creationid="hsugawa8651" creationdate="20181112T113120Z">
        <seg>julia&gt; Base.firstindex(S::Squares) = 1

julia&gt; Base.lastindex(S::Squares) = length(S)

julia&gt; Squares(23)[end]
529</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia&gt; Base.getindex(S::Squares, I) = [S[i] for i in I]

julia&gt; Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113142Z" creationid="hsugawa8651" creationdate="20181112T113142Z">
        <seg>julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia&gt; Base.getindex(S::Squares, I) = [S[i] for i in I]

julia&gt; Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state &lt; 1 ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112915Z" creationid="hsugawa8651" creationdate="20181112T112915Z">
        <seg>julia&gt; Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state &lt; 1 ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031001Z" creationid="hsugawa8651" creationdate="20181114T031001Z">
        <seg>julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 13, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  &lt;x1/&gt; (Note the necessary parens on `:(=)`)
(0, 1, 1)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030953Z" creationid="hsugawa8651" creationdate="20181114T030953Z">
        <seg>julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 13, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  &lt;x1/&gt; (Note the necessary parens on `:(=)`)
(0, 1, 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.show(io::IO, ::MIME"text/html", z::Polar{T}) where {T} =
           println(io, "&lt;x1/&gt;Polar{$T}&lt;x2/&gt; complex number: ",
                   z.r, " &lt;x3/&gt;e&lt;x4/&gt;&lt;x5/&gt;", z.Θ, " &lt;x6/&gt;i&lt;x7/&gt;&lt;x8/&gt;")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022119Z" creationid="hsugawa8651" creationdate="20181116T022119Z">
        <seg>julia&gt; Base.show(io::IO, ::MIME"text/html", z::Polar{T}) where {T} =
           println(io, "&lt;x1/&gt;Polar{$T}&lt;x2/&gt; complex number: ",
                   z.r, " &lt;x3/&gt;e&lt;x4/&gt;&lt;x5/&gt;", z.Θ, " &lt;x6/&gt;i&lt;x7/&gt;&lt;x8/&gt;")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.show(io::IO, ::MIME"text/plain", z::Polar{T}) where{T} =
           print(io, "Polar{$T} complex number:\n   ", z)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022112Z" creationid="hsugawa8651" creationdate="20181116T022112Z">
        <seg>julia&gt; Base.show(io::IO, ::MIME"text/plain", z::Polar{T}) where{T} =
           print(io, "Polar{$T} complex number:\n   ", z)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.show(io::IO, z::Polar) = print(io, z.r, " * exp(", z.Θ, "im)")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022108Z" creationid="hsugawa8651" creationdate="20181116T022108Z">
        <seg>julia&gt; Base.show(io::IO, z::Polar) = print(io, z.r, " * exp(", z.Θ, "im)")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia&gt; sum(Squares(1803))
1955361914</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112844Z" creationid="hsugawa8651" creationdate="20181112T112844Z">
        <seg>julia&gt; Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia&gt; sum(Squares(1803))
1955361914</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; BigInt(typemax(Int64)) + 1
9223372036854775808

julia&gt; parse(BigInt, "123456789012345678901234567890") + 1
123456789012345678901234567891

julia&gt; parse(BigFloat, "1.23456789012345678901")
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia&gt; BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia&gt; factorial(BigInt(40))
815915283247897734345611269596115894272000000000</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111550Z" creationid="hsugawa8651" creationdate="20181112T111550Z">
        <seg>julia&gt; BigInt(typemax(Int64)) + 1
9223372036854775808

julia&gt; parse(BigInt, "123456789012345678901234567890") + 1
123456789012345678901234567891

julia&gt; parse(BigFloat, "1.23456789012345678901")
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia&gt; BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia&gt; factorial(BigInt(40))
815915283247897734345611269596115894272000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Char(0x110000)
'\U110000': Unicode U+110000 (category In: Invalid, too high)

julia&gt; isvalid(Char, 0x110000)
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020526Z" creationid="hsugawa8651" creationdate="20181116T020526Z">
        <seg>julia&gt; Char(0x110000)
'\U110000': Unicode U+110000 (category In: Invalid, too high)

julia&gt; isvalid(Char, 0x110000)
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Char(120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020522Z" creationid="hsugawa8651" creationdate="20181116T020522Z">
        <seg>julia&gt; Char(120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Float32(-1.5)
-1.5f0

julia&gt; typeof(ans)
Float32</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110637Z" creationid="hsugawa8651" creationdate="20181112T110637Z">
        <seg>julia&gt; Float32(-1.5)
-1.5f0

julia&gt; typeof(ans)
Float32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Float64 &lt;: Point
false

julia&gt; AbstractString &lt;: Point
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021750Z" creationid="hsugawa8651" creationdate="20181116T021750Z">
        <seg>julia&gt; Float64 &lt;: Point
false

julia&gt; AbstractString &lt;: Point
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Foo((), 23.5, 1)
ERROR: InexactError: Int64(Int64, 23.5)
Stacktrace:
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021656Z" creationid="hsugawa8651" creationdate="20181116T021656Z">
        <seg>julia&gt; Foo((), 23.5, 1)
ERROR: InexactError: Int64(Int64, 23.5)
Stacktrace:
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Foo() = Foo(0)
Foo

julia&gt; Foo()
Foo(0, 0)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155717Z" creationid="hsugawa8651" creationdate="20181117T155717Z">
        <seg>julia&gt; Foo() = Foo(0)
Foo

julia&gt; Foo()
Foo(0, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Foo(x) = Foo(x,x)
Foo

julia&gt; Foo(1)
Foo(1, 1)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155711Z" creationid="hsugawa8651" creationdate="20181117T155711Z">
        <seg>julia&gt; Foo(x) = Foo(x,x)
Foo

julia&gt; Foo(1)
Foo(1, 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Fs = Vector{Any}(undef, 2);

julia&gt; for j = 1:2
           Fs[j] = ()-&gt;j
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022359Z" creationid="hsugawa8651" creationdate="20181116T022359Z">
        <seg>julia&gt; Fs = Vector{Any}(undef, 2);

julia&gt; for j = 1:2
           Fs[j] = ()-&gt;j
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           Fs[i] = ()-&gt;i
           global i += 1
       end

julia&gt; Fs[1]()
3

julia&gt; Fs[2]()
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022345Z" creationid="hsugawa8651" creationdate="20181116T022345Z">
        <seg>julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           Fs[i] = ()-&gt;i
           global i += 1
       end

julia&gt; Fs[1]()
3

julia&gt; Fs[2]()
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           let i = i
               Fs[i] = ()-&gt;i
           end
           global i += 1
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022352Z" creationid="hsugawa8651" creationdate="20181116T022352Z">
        <seg>julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           let i = i
               Fs[i] = ()-&gt;i
           end
           global i += 1
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Int('\0')
0

julia&gt; Int('\t')
9

julia&gt; Int('\n')
10

julia&gt; Int('\e')
27

julia&gt; Int('\x7f')
127

julia&gt; Int('\177')
127</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020532Z" creationid="hsugawa8651" creationdate="20181116T020532Z">
        <seg>julia&gt; Int('\0')
0

julia&gt; Int('\t')
9

julia&gt; Int('\n')
10

julia&gt; Int('\e')
27

julia&gt; Int('\x7f')
127

julia&gt; Int('\177')
127</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Int('x')
120

julia&gt; typeof(ans)
Int64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020504Z" creationid="hsugawa8651" creationdate="20181116T020504Z">
        <seg>julia&gt; Int('x')
120

julia&gt; typeof(ans)
Int64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(Int8, 3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(Int8, 128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031057Z" creationid="hsugawa8651" creationdate="20181114T031057Z">
        <seg>julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(Int8, 3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(Int8, 128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 :: IntOrString
1

julia&gt; "Hello!" :: IntOrString
"Hello!"

julia&gt; 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021726Z" creationid="hsugawa8651" creationdate="20181116T021726Z">
        <seg>julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 :: IntOrString
1

julia&gt; "Hello!" :: IntOrString
"Hello!"

julia&gt; 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Integer &lt;: Number
true

julia&gt; Integer &lt;: AbstractFloat
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021604Z" creationid="hsugawa8651" creationdate="20181116T021604Z">
        <seg>julia&gt; Integer &lt;: Number
true

julia&gt; Integer &lt;: AbstractFloat
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015101Z" creationid="hsugawa8651" creationdate="20181116T015101Z">
        <seg>julia&gt; Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030512Z" creationid="hsugawa8651" creationdate="20181114T030512Z">
        <seg>julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; NamedTuple{(:a, :b),Tuple{Float32, String}}((1,""))
(a = 1.0f0, b = "")

julia&gt; NamedTuple{(:a, :b)}((1,""))
(a = 1, b = "")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021939Z" creationid="hsugawa8651" creationdate="20181116T021939Z">
        <seg>julia&gt; NamedTuple{(:a, :b),Tuple{Float32, String}}((1,""))
(a = 1.0f0, b = "")

julia&gt; NamedTuple{(:a, :b)}((1,""))
(a = 1, b = "")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; OrderedPair(1, 2)
OrderedPair(1, 2)

julia&gt; OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] OrderedPair(::Int64, ::Int64) at ./none:4
 [3] top-level scope</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155751Z" creationid="hsugawa8651" creationdate="20181117T155751Z">
        <seg>julia&gt; OrderedPair(1, 2)
OrderedPair(1, 2)

julia&gt; OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] OrderedPair(::Int64, ::Int64) at ./none:4
 [3] top-level scope</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021819Z" creationid="hsugawa8651" creationdate="20181116T021819Z">
        <seg>julia&gt; Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}

julia&gt; Point(1,2)
Point{Int64}(1, 2)

julia&gt; typeof(ans)
Point{Int64}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021816Z" creationid="hsugawa8651" creationdate="20181116T021816Z">
        <seg>julia&gt; Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}

julia&gt; Point(1,2)
Point{Int64}(1, 2)

julia&gt; typeof(ans)
Point{Int64}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Pointy{Float64}
Pointy{Float64}

julia&gt; Pointy{Real}
Pointy{Real}

julia&gt; Pointy{AbstractString}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Type{AbstractString}

julia&gt; Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Int64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021901Z" creationid="hsugawa8651" creationdate="20181116T021901Z">
        <seg>julia&gt; Pointy{Float64}
Pointy{Float64}

julia&gt; Pointy{Real}
Pointy{Real}

julia&gt; Pointy{AbstractString}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Type{AbstractString}

julia&gt; Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Int64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Pointy{Float64} &lt;: Pointy{&lt;:Real}
true

julia&gt; Pointy{Real} &lt;: Pointy{&gt;:Int}
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021844Z" creationid="hsugawa8651" creationdate="20181116T021844Z">
        <seg>julia&gt; Pointy{Float64} &lt;: Pointy{&lt;:Real}
true

julia&gt; Pointy{Real} &lt;: Pointy{&gt;:Int}
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Pointy{Float64} &lt;: Pointy{Real}
false

julia&gt; Pointy{Real} &lt;: Pointy{Float64}
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021833Z" creationid="hsugawa8651" creationdate="20181116T021833Z">
        <seg>julia&gt; Pointy{Float64} &lt;: Pointy{Real}
false

julia&gt; Pointy{Real} &lt;: Pointy{Float64}
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Pointy{Int64} &lt;: Pointy
true

julia&gt; Pointy{1} &lt;: Pointy
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021826Z" creationid="hsugawa8651" creationdate="20181116T021826Z">
        <seg>julia&gt; Pointy{Int64} &lt;: Pointy
true

julia&gt; Pointy{1} &lt;: Pointy
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point{Float64}
Point{Float64}

julia&gt; Point{AbstractString}
Point{AbstractString}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021742Z" creationid="hsugawa8651" creationdate="20181116T021742Z">
        <seg>julia&gt; Point{Float64}
Point{Float64}

julia&gt; Point{AbstractString}
Point{AbstractString}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point{Float64} &lt;: Point
true

julia&gt; Point{AbstractString} &lt;: Point
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021747Z" creationid="hsugawa8651" creationdate="20181116T021747Z">
        <seg>julia&gt; Point{Float64} &lt;: Point
true

julia&gt; Point{AbstractString} &lt;: Point
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point{Float64} &lt;: Pointy{Float64}
true

julia&gt; Point{Real} &lt;: Pointy{Real}
true

julia&gt; Point{AbstractString} &lt;: Pointy{AbstractString}
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021850Z" creationid="hsugawa8651" creationdate="20181116T021850Z">
        <seg>julia&gt; Point{Float64} &lt;: Pointy{Float64}
true

julia&gt; Point{Real} &lt;: Pointy{Real}
true

julia&gt; Point{AbstractString} &lt;: Pointy{AbstractString}
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point{Float64} &lt;: Pointy{Real}
false

julia&gt; Point{Float64} &lt;: Pointy{&lt;:Real}
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021853Z" creationid="hsugawa8651" creationdate="20181116T021853Z">
        <seg>julia&gt; Point{Float64} &lt;: Pointy{Real}
false

julia&gt; Point{Float64} &lt;: Pointy{&lt;:Real}
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point{Float64} &lt;: Point{Int64}
false

julia&gt; Point{Float64} &lt;: Point{Real}
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021752Z" creationid="hsugawa8651" creationdate="20181116T021752Z">
        <seg>julia&gt; Point{Float64} &lt;: Point{Int64}
false

julia&gt; Point{Float64} &lt;: Point{Real}
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point{Float64}(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
[...]

julia&gt; Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021813Z" creationid="hsugawa8651" creationdate="20181116T021813Z">
        <seg>julia&gt; Point{Float64}(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
[...]

julia&gt; Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021810Z" creationid="hsugawa8651" creationdate="20181116T021810Z">
        <seg>julia&gt; Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Array{Polar{Float64},1}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022114Z" creationid="hsugawa8651" creationdate="20181116T022114Z">
        <seg>julia&gt; Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Array{Polar{Float64},1}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Ptr{Float64} &lt;: Ptr
true

julia&gt; Ptr{Int64} &lt;: Ptr
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022006Z" creationid="hsugawa8651" creationdate="20181116T022006Z">
        <seg>julia&gt; Ptr{Float64} &lt;: Ptr
true

julia&gt; Ptr{Int64} &lt;: Ptr
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Any}
true

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Real}
false

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,}
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021923Z" creationid="hsugawa8651" creationdate="20181116T021923Z">
        <seg>julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Any}
true

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Real}
false

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,}
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; Y = [1.0, 2.0, 3.0, 4.0];

julia&gt; X = similar(Y); &lt;x1/&gt; pre-allocate output array

julia&gt; @.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030248Z" creationid="hsugawa8651" creationdate="20181110T030248Z">
        <seg>julia&gt; Y = [1.0, 2.0, 3.0, 4.0];

julia&gt; X = similar(Y); &lt;x1/&gt; pre-allocate output array

julia&gt; @.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155100Z" creationid="hsugawa8651" creationdate="20181109T155100Z">
        <seg>julia&gt; [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155040Z" creationid="hsugawa8651" creationdate="20181109T155040Z">
        <seg>julia&gt; [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; [1 NaN] == [1 NaN]
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030525Z" creationid="hsugawa8651" creationdate="20181114T030525Z">
        <seg>julia&gt; [1 NaN] == [1 NaN]
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132518Z" creationid="hsugawa8651" creationdate="20181113T132518Z">
        <seg>julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; [1:5;] .|&gt; [x-&gt;x^2, inv, x-&gt;2*x, -, isodd]
5-element Array{Real,1}:
    1
    0.5
    6
   -4
 true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030300Z" creationid="hsugawa8651" creationdate="20181110T030300Z">
        <seg>julia&gt; [1:5;] .|&gt; [x-&gt;x^2, inv, x-&gt;2*x, -, isodd]
5-element Array{Real,1}:
    1
    0.5
    6
   -4
 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154710Z" creationid="hsugawa8651" creationdate="20181109T154710Z">
        <seg>julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; [[1; 2]; [3, 4]]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; [[1 2]; [3 4]]
2×2 Array{Int64,2}:
 1  2
 3  4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154652Z" creationid="hsugawa8651" creationdate="20181109T154652Z">
        <seg>julia&gt; [[1; 2]; [3, 4]]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; [[1 2]; [3 4]]
2×2 Array{Int64,2}:
 1  2
 3  4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = 1;

julia&gt; ex = :($a + b)
:(1 + b)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015146Z" creationid="hsugawa8651" creationdate="20181116T015146Z">
        <seg>julia&gt; a = 1;

julia&gt; ex = :($a + b)
:(1 + b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = 1;

julia&gt; ex = Expr(:call, :+, a, :b)
:(1 + b)

julia&gt; a = 0; b = 2;

julia&gt; eval(ex)
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015235Z" creationid="hsugawa8651" creationdate="20181116T015235Z">
        <seg>julia&gt; a = 1;

julia&gt; ex = Expr(:call, :+, a, :b)
:(1 + b)

julia&gt; a = 0; b = 2;

julia&gt; eval(ex)
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = ArrayAndChar([1 2; 3 4], 'x')
2×2 ArrayAndChar{Int64,2} with char 'x':
 1  2
 3  4

julia&gt; a .+ 1
2×2 ArrayAndChar{Int64,2} with char 'x':
 2  3
 4  5

julia&gt; a .+ [5,10]
2×2 ArrayAndChar{Int64,2} with char 'x':
  6   7
 13  14</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131434Z" creationid="hsugawa8651" creationdate="20181113T131434Z">
        <seg>julia&gt; a = ArrayAndChar([1 2; 3 4], 'x')
2×2 ArrayAndChar{Int64,2} with char 'x':
 1  2
 3  4

julia&gt; a .+ 1
2×2 ArrayAndChar{Int64,2} with char 'x':
 2  3
 4  5

julia&gt; a .+ [5,10]
2×2 ArrayAndChar{Int64,2} with char 'x':
  6   7
 13  14</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; print(:($a^2))
3.0 * exp(4.0im) ^ 2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022126Z" creationid="hsugawa8651" creationdate="20181116T022126Z">
        <seg>julia&gt; a = Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; print(:($a^2))
3.0 * exp(4.0im) ^ 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = [1,2,5,6,7];

julia&gt; searchsorted(a, 4)
3:2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155322Z" creationid="hsugawa8651" creationdate="20181109T155322Z">
        <seg>julia&gt; a = [1,2,5,6,7];

julia&gt; searchsorted(a, 4)
3:2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = [2,3,1];

julia&gt; sort!(a);

julia&gt; a
3-element Array{Int64,1}:
 1
 2
 3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044850Z" creationid="hsugawa8651" creationdate="20181112T044850Z">
        <seg>julia&gt; a = [2,3,1];

julia&gt; sort!(a);

julia&gt; a
3-element Array{Int64,1}:
 1
 2
 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = rand(10, 10)
10×10 Array{Float64,2}:
 0.517515  0.0348206  0.749042   0.0979679  …  0.75984     0.950481   0.579513
 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898
 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137
 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999
 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304
 0.160872  0.455168   0.489254   0.827851   …  0.62226     0.0995456  0.946522
 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837
 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181
 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357
 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231

julia&gt; b = view(a, 2:2:8,2:2:4)
4×2 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:
 0.873479   0.0697848
 0.0317896  0.534457
 0.455168   0.827851
 0.700731   0.0126213

julia&gt; (q, r) = qr(b);

julia&gt; q
4×4 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.722358    0.227524  -0.247784    -0.604181
 -0.0262896  -0.575919  -0.804227     0.144377
 -0.376419   -0.75072    0.540177    -0.0541979
 -0.579497    0.230151  -0.00552346   0.781782

julia&gt; r
2×2 Array{Float64,2}:
 -1.20921  -0.383393
  0.0      -0.910506</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160525Z" creationid="hsugawa8651" creationdate="20181109T160525Z">
        <seg>julia&gt; a = rand(10, 10)
10×10 Array{Float64,2}:
 0.517515  0.0348206  0.749042   0.0979679  …  0.75984     0.950481   0.579513
 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898
 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137
 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999
 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304
 0.160872  0.455168   0.489254   0.827851   …  0.62226     0.0995456  0.946522
 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837
 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181
 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357
 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231

julia&gt; b = view(a, 2:2:8,2:2:4)
4×2 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:
 0.873479   0.0697848
 0.0317896  0.534457
 0.455168   0.827851
 0.700731   0.0126213

julia&gt; (q, r) = qr(b);

julia&gt; q
4×4 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.722358    0.227524  -0.247784    -0.604181
 -0.0262896  -0.575919  -0.804227     0.144377
 -0.376419   -0.75072    0.540177    -0.0541979
 -0.579497    0.230151  -0.00552346   0.781782

julia&gt; r
2×2 Array{Float64,2}:
 -1.20921  -0.383393
  0.0      -0.910506</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a = rand(2,1); A = rand(2,3);

julia&gt; repeat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160046Z" creationid="hsugawa8651" creationdate="20181109T160046Z">
        <seg>julia&gt; a = rand(2,1); A = rand(2,3);

julia&gt; repeat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; a, b = "\xe2\x88", "\x80"
("\xe2\x88", "\x80")

julia&gt; c = a*b
"∀"

julia&gt; collect.([a, b, c])
3-element Array{Array{Char,1},1}:
 ['\xe2\x88']
 ['\x80']
 ['∀']

julia&gt; length.([a, b, c])
3-element Array{Int64,1}:
 1
 1
 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020746Z" creationid="hsugawa8651" creationdate="20181116T020746Z">
        <seg>julia&gt; a, b = "\xe2\x88", "\x80"
("\xe2\x88", "\x80")

julia&gt; c = a*b
"∀"

julia&gt; collect.([a, b, c])
3-element Array{Array{Char,1},1}:
 ['\xe2\x88']
 ['\x80']
 ['∀']

julia&gt; length.([a, b, c])
3-element Array{Int64,1}:
 1
 1
 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; abstract type Pointy{T} end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021823Z" creationid="hsugawa8651" creationdate="20181116T021823Z">
        <seg>julia&gt; abstract type Pointy{T} end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; args = [:x, :y, :z];

julia&gt; :(f(1, $(args...)))
:(f(1, x, y, z))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015159Z" creationid="hsugawa8651" creationdate="20181116T015159Z">
        <seg>julia&gt; args = [:x, :y, :z];

julia&gt; :(f(1, $(args...)))
:(f(1, x, y, z))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; b = SelfReferential(a)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155848Z" creationid="hsugawa8651" creationdate="20181117T155848Z">
        <seg>julia&gt; b = SelfReferential(a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; b"DATA\xff\u2200"
8-element Base.CodeUnits{UInt8,String}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021048Z" creationid="hsugawa8651" creationdate="20181116T021048Z">
        <seg>julia&gt; b"DATA\xff\u2200"
8-element Base.CodeUnits{UInt8,String}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; b"\xff"
1-element Base.CodeUnits{UInt8,String}:
 0xff

julia&gt; b"\uff"
2-element Base.CodeUnits{UInt8,String}:
 0xc3
 0xbf</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021059Z" creationid="hsugawa8651" creationdate="20181116T021059Z">
        <seg>julia&gt; b"\xff"
1-element Base.CodeUnits{UInt8,String}:
 0xff

julia&gt; b"\uff"
2-element Base.CodeUnits{UInt8,String}:
 0xc3
 0xbf</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; bar(1,2)
(1, 2, ())

julia&gt; bar(1,2,3)
(1, 2, (3,))

julia&gt; bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030058Z" creationid="hsugawa8651" creationdate="20181110T030058Z">
        <seg>julia&gt; bar(1,2)
(1, 2, ())

julia&gt; bar(1,2,3)
(1, 2, (3,))

julia&gt; bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030056Z" creationid="hsugawa8651" creationdate="20181110T030056Z">
        <seg>julia&gt; bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia&gt; bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia&gt; bar(1,2,3,4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054317Z" creationid="hsugawa8651" creationdate="20181116T054317Z">
        <seg>julia&gt; bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia&gt; bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia&gt; bar(1,2,3,4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; baz(a,b) = a + b;

julia&gt; args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia&gt; baz(args...)
3

julia&gt; args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030114Z" creationid="hsugawa8651" creationdate="20181110T030114Z">
        <seg>julia&gt; baz(a,b) = a + b;

julia&gt; args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia&gt; baz(args...)
3

julia&gt; args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; begin x = 1; y = 2; x + y end
3

julia&gt; (x = 1;
        y = 2;
        x + y)
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225823Z" creationid="hsugawa8651" creationdate="20181109T225823Z">
        <seg>julia&gt; begin x = 1; y = 2; x + y end
3

julia&gt; (x = 1;
        y = 2;
        x + y)
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160057Z" creationid="hsugawa8651" creationdate="20181109T160057Z">
        <seg>julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; "hi, $c"
"hi, x"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020818Z" creationid="hsugawa8651" creationdate="20181116T020818Z">
        <seg>julia&gt; c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; "hi, $c"
"hi, x"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152512Z" creationid="hsugawa8651" creationdate="20181117T152512Z">
        <seg>julia&gt; cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; collect(Squares(4))
4-element Array{Int64,1}:
  1
  4
  9
 16</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112726Z" creationid="hsugawa8651" creationdate="20181112T112726Z">
        <seg>julia&gt; collect(Squares(4))
4-element Array{Int64,1}:
  1
  4
  9
 16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const T1 = Array{Array{T,1} where T, 1}
Array{Array{T,1} where T,1}

julia&gt; const T2 = Array{Array{T,1}, 1} where T
Array{Array{T,1},1} where T</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022019Z" creationid="hsugawa8651" creationdate="20181116T022019Z">
        <seg>julia&gt; const T1 = Array{Array{T,1} where T, 1}
Array{Array{T,1} where T,1}

julia&gt; const T2 = Array{Array{T,1}, 1} where T
Array{Array{T,1},1} where T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const a = [1]
1-element Array{Int64,1}:
 1

julia&gt; a = [1]
WARNING: redefining constant a
1-element Array{Int64,1}:
 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022437Z" creationid="hsugawa8651" creationdate="20181116T022437Z">
        <seg>julia&gt; const a = [1]
1-element Array{Int64,1}:
 1

julia&gt; a = [1]
WARNING: redefining constant a
1-element Array{Int64,1}:
 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const a, b = 1, 2
(1, 2)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022420Z" creationid="hsugawa8651" creationdate="20181116T022420Z">
        <seg>julia&gt; const a, b = 1, 2
(1, 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const e  = 2.71828182845904523536;

julia&gt; const pi = 3.14159265358979323846;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022414Z" creationid="hsugawa8651" creationdate="20181116T022414Z">
        <seg>julia&gt; const e  = 2.71828182845904523536;

julia&gt; const pi = 3.14159265358979323846;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const s1 = "1"
"1"

julia&gt; s2 = "1"
"1"

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x00000000132c9638
 Ptr{UInt8} @0x0000000013dd3d18

julia&gt; s1 = s2
"1"

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x0000000013dd3d18
 Ptr{UInt8} @0x0000000013dd3d18</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022434Z" creationid="hsugawa8651" creationdate="20181116T022434Z">
        <seg>julia&gt; const s1 = "1"
"1"

julia&gt; s2 = "1"
"1"

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x00000000132c9638
 Ptr{UInt8} @0x0000000013dd3d18

julia&gt; s1 = s2
"1"

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x0000000013dd3d18
 Ptr{UInt8} @0x0000000013dd3d18</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const x = 1
1

julia&gt; f() = x
f (generic function with 1 method)

julia&gt; f()
1

julia&gt; x = 2
WARNING: redefining constant x
2

julia&gt; f()
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022441Z" creationid="hsugawa8651" creationdate="20181116T022441Z">
        <seg>julia&gt; const x = 1
1

julia&gt; f() = x
f (generic function with 1 method)

julia&gt; f()
1

julia&gt; x = 2
WARNING: redefining constant x
2

julia&gt; f()
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const x = 1.0
1.0

julia&gt; x = 1
ERROR: invalid redefinition of constant x</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022426Z" creationid="hsugawa8651" creationdate="20181116T022426Z">
        <seg>julia&gt; const x = 1.0
1.0

julia&gt; x = 1
ERROR: invalid redefinition of constant x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const y = 1.0
1.0

julia&gt; y = 2.0
WARNING: redefining constant y
2.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022429Z" creationid="hsugawa8651" creationdate="20181116T022429Z">
        <seg>julia&gt; const y = 1.0
1.0

julia&gt; y = 2.0
WARNING: redefining constant y
2.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; const z = 100
100

julia&gt; z = 100
100</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022432Z" creationid="hsugawa8651" creationdate="20181116T022432Z">
        <seg>julia&gt; const z = 100
100

julia&gt; z = 100
100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, ".</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T160140Z" creationid="hsugawa8651" creationdate="20181109T160140Z">
        <seg>julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, ".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, ". ", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1. First"
 "2. Second"
 "3. Third"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T135302Z" creationid="hsugawa8651" creationdate="20181117T135302Z">
        <seg>julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, ". ", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1. First"
 "2. Second"
 "3. Third"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083324Z" creationid="hsugawa8651" creationdate="20181113T083324Z">
        <seg>julia&gt; copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; dump(Meta.parse(":(1+2)"))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 1
        3: Int64 2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015218Z" creationid="hsugawa8651" creationdate="20181116T015218Z">
        <seg>julia&gt; dump(Meta.parse(":(1+2)"))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 1
        3: Int64 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; dump(Meta.parse(":x"))
QuoteNode
  value: Symbol x</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015223Z" creationid="hsugawa8651" creationdate="20181116T015223Z">
        <seg>julia&gt; dump(Meta.parse(":x"))
QuoteNode
  value: Symbol x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; e = quote quote $$x end end
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    $(Expr(:quote, quote
    &lt;x3/&gt;= none:1 =&lt;x4/&gt;
    $(Expr(:$, :(1 + 2)))
end))
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015211Z" creationid="hsugawa8651" creationdate="20181116T015211Z">
        <seg>julia&gt; e = quote quote $$x end end
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    $(Expr(:quote, quote
    &lt;x3/&gt;= none:1 =&lt;x4/&gt;
    $(Expr(:$, :(1 + 2)))
end))
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; else = false
ERROR: syntax: unexpected "else"

julia&gt; try = "No"
ERROR: syntax: unexpected "="</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022524Z" creationid="hsugawa8651" creationdate="20181116T022524Z">
        <seg>julia&gt; else = false
ERROR: syntax: unexpected "else"

julia&gt; try = "No"
ERROR: syntax: unexpected "="</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; eps(1.0)
2.220446049250313e-16

julia&gt; eps(1000.)
1.1368683772161603e-13

julia&gt; eps(1e-27)
1.793662034335766e-43

julia&gt; eps(0.0)
5.0e-324</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111203Z" creationid="hsugawa8651" creationdate="20181112T111203Z">
        <seg>julia&gt; eps(1.0)
2.220446049250313e-16

julia&gt; eps(1000.)
1.1368683772161603e-13

julia&gt; eps(1e-27)
1.793662034335766e-43

julia&gt; eps(0.0)
5.0e-324</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; eps(Float32)
1.1920929f-7

julia&gt; eps(Float64)
2.220446049250313e-16

julia&gt; eps() &lt;x1/&gt; same as eps(Float64)
2.220446049250313e-16</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111138Z" creationid="hsugawa8651" creationdate="20181112T111138Z">
        <seg>julia&gt; eps(Float32)
1.1920929f-7

julia&gt; eps(Float64)
2.220446049250313e-16

julia&gt; eps() &lt;x1/&gt; same as eps(Float64)
2.220446049250313e-16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; eval(e)
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    1 + 2
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015208Z" creationid="hsugawa8651" creationdate="20181116T015208Z">
        <seg>julia&gt; eval(e)
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    1 + 2
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; eval(e)
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    3
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015215Z" creationid="hsugawa8651" creationdate="20181116T015215Z">
        <seg>julia&gt; eval(e)
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    3
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; ex = :(a in $:((1,2,3)) )
:(a in (1, 2, 3))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015153Z" creationid="hsugawa8651" creationdate="20181116T015153Z">
        <seg>julia&gt; ex = :(a in $:((1,2,3)) )
:(a in (1, 2, 3))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; ex = :(a+b*c+1)
:(a + b * c + 1)

julia&gt; typeof(ex)
Expr</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015117Z" creationid="hsugawa8651" creationdate="20181116T015117Z">
        <seg>julia&gt; ex = :(a+b*c+1)
:(a + b * c + 1)

julia&gt; typeof(ex)
Expr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; ex = :(x = 1)
:(x = 1)

julia&gt; x
ERROR: UndefVarError: x not defined

julia&gt; eval(ex)
1

julia&gt; x
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015230Z" creationid="hsugawa8651" creationdate="20181116T015230Z">
        <seg>julia&gt; ex = :(x = 1)
:(x = 1)

julia&gt; x
ERROR: UndefVarError: x not defined

julia&gt; eval(ex)
1

julia&gt; x
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; ex = macroexpand(Main, :(@sayhello("human")) )
:((Main.println)("Hello, ", "human"))

julia&gt; typeof(ex)
Expr</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015309Z" creationid="hsugawa8651" creationdate="20181116T015309Z">
        <seg>julia&gt; ex = macroexpand(Main, :(@sayhello("human")) )
:((Main.println)("Hello, ", "human"))

julia&gt; typeof(ex)
Expr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; ex = quote
           x = 1
           y = 2
           x + y
       end
quote
    &lt;x1/&gt;= none:2 =&lt;x2/&gt;
    x = 1
    &lt;x3/&gt;= none:3 =&lt;x4/&gt;
    y = 2
    &lt;x5/&gt;= none:4 =&lt;x6/&gt;
    x + y
end

julia&gt; typeof(ex)
Expr</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015127Z" creationid="hsugawa8651" creationdate="20181116T015127Z">
        <seg>julia&gt; ex = quote
           x = 1
           y = 2
           x + y
       end
quote
    &lt;x1/&gt;= none:2 =&lt;x2/&gt;
    x = 1
    &lt;x3/&gt;= none:3 =&lt;x4/&gt;
    y = 2
    &lt;x5/&gt;= none:4 =&lt;x6/&gt;
    x + y
end

julia&gt; typeof(ex)
Expr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; example() = stacktrace()
example (generic function with 1 method)

julia&gt; example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("&lt;x1/&gt;28&lt;x2/&gt;29")){REPL.REPLBackend})() at event.jl:92</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020403Z" creationid="hsugawa8651" creationdate="20181116T020403Z">
        <seg>julia&gt; example() = stacktrace()
example (generic function with 1 method)

julia&gt; example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("&lt;x1/&gt;28&lt;x2/&gt;29")){REPL.REPLBackend})() at event.jl:92</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; example() = stacktrace()
example (generic function with 1 method)

julia&gt; example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
[...]

julia&gt; @noinline child() = stacktrace()
child (generic function with 1 method)

julia&gt; @noinline parent() = child()
parent (generic function with 1 method)

julia&gt; grandparent() = parent()
grandparent (generic function with 1 method)

julia&gt; grandparent()
9-element Array{Base.StackTraces.StackFrame,1}:
 child() at REPL[3]:1
 parent() at REPL[4]:1
 grandparent() at REPL[5]:1
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020358Z" creationid="hsugawa8651" creationdate="20181116T020358Z">
        <seg>julia&gt; example() = stacktrace()
example (generic function with 1 method)

julia&gt; example()
7-element Array{Base.StackTraces.StackFrame,1}:
 example() at REPL[1]:1
 top-level scope
 eval at boot.jl:317 [inlined]
[...]

julia&gt; @noinline child() = stacktrace()
child (generic function with 1 method)

julia&gt; @noinline parent() = child()
parent (generic function with 1 method)

julia&gt; grandparent() = parent()
grandparent (generic function with 1 method)

julia&gt; grandparent()
9-element Array{Base.StackTraces.StackFrame,1}:
 child() at REPL[3]:1
 parent() at REPL[4]:1
 grandparent() at REPL[5]:1
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f
f (generic function with 2 methods)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053936Z" creationid="hsugawa8651" creationdate="20181116T053936Z">
        <seg>julia&gt; f
f (generic function with 2 methods)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f = +;

julia&gt; f(1,2,3)
6</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025828Z" creationid="hsugawa8651" creationdate="20181110T025828Z">
        <seg>julia&gt; f = +;

julia&gt; f(1,2,3)
6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f = y -&gt; y + a;

julia&gt; f(3)
ERROR: UndefVarError: a not defined
Stacktrace:
[...]

julia&gt; a = 1
1

julia&gt; f(3)
4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022331Z" creationid="hsugawa8651" creationdate="20181116T022331Z">
        <seg>julia&gt; f = y -&gt; y + a;

julia&gt; f(3)
ERROR: UndefVarError: a not defined
Stacktrace:
[...]

julia&gt; a = 1
1

julia&gt; f(3)
4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia&gt; f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053933Z" creationid="hsugawa8651" creationdate="20181116T053933Z">
        <seg>julia&gt; f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia&gt; f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(1)
"definition for Int"

julia&gt; g(1)
"definition for Int"

julia&gt; fetch(schedule(t, 1))
"original definition"

julia&gt; t = @async f(wait()); yield();

julia&gt; fetch(schedule(t, 1))
"definition for Int"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054120Z" creationid="hsugawa8651" creationdate="20181116T054120Z">
        <seg>julia&gt; f(1)
"definition for Int"

julia&gt; g(1)
"definition for Int"

julia&gt; fetch(schedule(t, 1))
"original definition"

julia&gt; t = @async f(wait()); yield();

julia&gt; fetch(schedule(t, 1))
"definition for Int"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(1)
"definition for Int"

julia&gt; g(1)
"definition for Int"

julia&gt; gen1(1)
"original definition"

julia&gt; gen2(1)
"definition for Int"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015738Z" creationid="hsugawa8651" creationdate="20181116T015738Z">
        <seg>julia&gt; f(1)
"definition for Int"

julia&gt; g(1)
"definition for Int"

julia&gt; gen1(1)
"original definition"

julia&gt; gen2(1)
"definition for Int"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(1) &amp; t(2)
1
2
false

julia&gt; t(1) | t(2)
1
2
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230755Z" creationid="hsugawa8651" creationdate="20181109T230755Z">
        <seg>julia&gt; f(1) &amp; t(2)
1
2
false

julia&gt; t(1) | t(2)
1
2
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(2,3)
5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025628Z" creationid="hsugawa8651" creationdate="20181110T025628Z">
        <seg>julia&gt; f(2,3)
5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia&gt; f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053858Z" creationid="hsugawa8651" creationdate="20181116T053858Z">
        <seg>julia&gt; f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia&gt; f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(2.0, 3.0)
7.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053905Z" creationid="hsugawa8651" creationdate="20181116T053905Z">
        <seg>julia&gt; f(2.0, 3.0)
7.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(2.0, 3.0)
7.0

julia&gt; f(2, 3.0)
1.0

julia&gt; f(2.0, 3)
1.0

julia&gt; f(2, 3)
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053925Z" creationid="hsugawa8651" creationdate="20181116T053925Z">
        <seg>julia&gt; f(2.0, 3.0)
7.0

julia&gt; f(2, 3.0)
1.0

julia&gt; f(2.0, 3)
1.0

julia&gt; f(2, 3)
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x) = "original definition"
f (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054109Z" creationid="hsugawa8651" creationdate="20181116T054109Z">
        <seg>julia&gt; f(x) = "original definition"
f (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x) = "original definition";</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015711Z" creationid="hsugawa8651" creationdate="20181116T015711Z">
        <seg>julia&gt; f(x) = "original definition";</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x) = 2.0 * x
f (generic function with 1 method)

julia&gt; f(1//2)
1.0

julia&gt; f(1/2)
1.0

julia&gt; f(1)
2.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021359Z" creationid="hsugawa8651" creationdate="20181116T021359Z">
        <seg>julia&gt; f(x) = 2.0 * x
f (generic function with 1 method)

julia&gt; f(1//2)
1.0

julia&gt; f(1/2)
1.0

julia&gt; f(1)
2.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x,y) = 3x + 4y;

julia&gt; A = [1.0, 2.0, 3.0];

julia&gt; B = [4.0, 5.0, 6.0];

julia&gt; f.(pi, A)
3-element Array{Float64,1}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia&gt; f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030235Z" creationid="hsugawa8651" creationdate="20181110T030235Z">
        <seg>julia&gt; f(x,y) = 3x + 4y;

julia&gt; A = [1.0, 2.0, 3.0];

julia&gt; B = [4.0, 5.0, 6.0];

julia&gt; f.(pi, A)
3-element Array{Float64,1}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia&gt; f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x,y) = println("Whoa there, Nelly.")
f (generic function with 3 methods)

julia&gt; f("foo", 1)
Whoa there, Nelly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053947Z" creationid="hsugawa8651" creationdate="20181116T053947Z">
        <seg>julia&gt; f(x,y) = println("Whoa there, Nelly.")
f (generic function with 3 methods)

julia&gt; f("foo", 1)
Whoa there, Nelly.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x,y) = x + y
f (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025509Z" creationid="hsugawa8651" creationdate="20181110T025509Z">
        <seg>julia&gt; f(x,y) = x + y
f (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x,y) = x + y
f (generic function with 1 method)

julia&gt; function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia&gt; f(2,3)
5

julia&gt; g(2,3)
6</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025743Z" creationid="hsugawa8651" creationdate="20181110T025743Z">
        <seg>julia&gt; f(x,y) = x + y
f (generic function with 1 method)

julia&gt; function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia&gt; f(2,3)
5

julia&gt; g(2,3)
6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053909Z" creationid="hsugawa8651" creationdate="20181116T053909Z">
        <seg>julia&gt; f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x::Int) = "definition for Int"
f (generic function with 2 methods)

julia&gt; f(x::Type{Int}) = "definition for Type{Int}"
f (generic function with 3 methods)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054115Z" creationid="hsugawa8651" creationdate="20181116T054115Z">
        <seg>julia&gt; f(x::Int) = "definition for Int"
f (generic function with 2 methods)

julia&gt; f(x::Type{Int}) = "definition for Type{Int}"
f (generic function with 3 methods)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x::Int) = "definition for Int";

julia&gt; f(x::Type{Int}) = "definition for Type{Int}";</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015718Z" creationid="hsugawa8651" creationdate="20181116T015718Z">
        <seg>julia&gt; f(x::Int) = "definition for Int";

julia&gt; f(x::Type{Int}) = "definition for Type{Int}";</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia&gt; f(2.0, 3)
1.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053919Z" creationid="hsugawa8651" creationdate="20181116T053919Z">
        <seg>julia&gt; f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia&gt; f(2.0, 3)
1.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; fieldnames(Foo)
(:bar, :baz, :qux)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021658Z" creationid="hsugawa8651" creationdate="20181116T021658Z">
        <seg>julia&gt; fieldnames(Foo)
(:bar, :baz, :qux)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; findfirst(isequal('o'), "xylophone")
4

julia&gt; findlast(isequal('o'), "xylophone")
7

julia&gt; findfirst(isequal('z'), "xylophone")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020906Z" creationid="hsugawa8651" creationdate="20181116T020906Z">
        <seg>julia&gt; findfirst(isequal('o'), "xylophone")
4

julia&gt; findlast(isequal('o'), "xylophone")
7

julia&gt; findfirst(isequal('z'), "xylophone")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; findnext(isequal('o'), "xylophone", 1)
4

julia&gt; findnext(isequal('o'), "xylophone", 5)
7

julia&gt; findprev(isequal('o'), "xylophone", 5)
4

julia&gt; findnext(isequal('o'), "xylophone", 8)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020908Z" creationid="hsugawa8651" creationdate="20181116T020908Z">
        <seg>julia&gt; findnext(isequal('o'), "xylophone", 1)
4

julia&gt; findnext(isequal('o'), "xylophone", 5)
7

julia&gt; findprev(isequal('o'), "xylophone", 5)
4

julia&gt; findnext(isequal('o'), "xylophone", 8)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; first, second, third = m.captures; first
"a"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021008Z" creationid="hsugawa8651" creationdate="20181116T021008Z">
        <seg>julia&gt; first, second, third = m.captures; first
"a"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; firstlast(::Val{true}) = "First"
firstlast (generic function with 1 method)

julia&gt; firstlast(::Val{false}) = "Last"
firstlast (generic function with 2 methods)

julia&gt; firstlast(Val(true))
"First"

julia&gt; firstlast(Val(false))
"Last"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022201Z" creationid="hsugawa8651" creationdate="20181116T022201Z">
        <seg>julia&gt; firstlast(::Val{true}) = "First"
firstlast (generic function with 1 method)

julia&gt; firstlast(::Val{false}) = "Last"
firstlast (generic function with 2 methods)

julia&gt; firstlast(Val(true))
"First"

julia&gt; firstlast(Val(false))
"Last"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)

julia&gt; typeof(foo)
Foo</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021649Z" creationid="hsugawa8651" creationdate="20181116T021649Z">
        <seg>julia&gt; foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)

julia&gt; typeof(foo)
Foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; foo(2,3)
(5, 6)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030031Z" creationid="hsugawa8651" creationdate="20181110T030031Z">
        <seg>julia&gt; foo(2,3)
(5, 6)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; foo(4)
16</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015703Z" creationid="hsugawa8651" creationdate="20181116T015703Z">
        <seg>julia&gt; foo(4)
16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; foo.bar
"Hello, world."

julia&gt; foo.baz
23

julia&gt; foo.qux
1.5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021701Z" creationid="hsugawa8651" creationdate="20181116T021701Z">
        <seg>julia&gt; foo.bar
"Hello, world."

julia&gt; foo.baz
23

julia&gt; foo.qux
1.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for c in s
           println(c)
       end
∀

x

∃

y</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020618Z" creationid="hsugawa8651" creationdate="20181116T020618Z">
        <seg>julia&gt; for c in s
           println(c)
       end
∀

x

∃

y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for i = 1:10
           global z
           z = i
       end

julia&gt; z
10</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022306Z" creationid="hsugawa8651" creationdate="20181116T022306Z">
        <seg>julia&gt; for i = 1:10
           global z
           z = i
       end

julia&gt; z
10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for i = 1:10
           z = i
           global z
       end

julia&gt; z
10</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022310Z" creationid="hsugawa8651" creationdate="20181116T022310Z">
        <seg>julia&gt; for i = 1:10
           z = i
           global z
       end

julia&gt; z
10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for i = 1:10
           z = i
       end

julia&gt; z
ERROR: UndefVarError: z not defined</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022300Z" creationid="hsugawa8651" creationdate="20181116T022300Z">
        <seg>julia&gt; for i = 1:10
           z = i
       end

julia&gt; z
ERROR: UndefVarError: z not defined</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for i = 1:5
           println(i)
       end
1
2
3
4
5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T231134Z" creationid="hsugawa8651" creationdate="20181109T231134Z">
        <seg>julia&gt; for i = 1:5
           println(i)
       end
1
2
3
4
5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for i = firstindex(s):lastindex(s)
           try
               println(s[i])
           catch
               &lt;x1/&gt; ignore the index error
           end
       end
∀

x

∃

y</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020615Z" creationid="hsugawa8651" creationdate="20181116T020615Z">
        <seg>julia&gt; for i = firstindex(s):lastindex(s)
           try
               println(s[i])
           catch
               &lt;x1/&gt; ignore the index error
           end
       end
∀

x

∃

y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112509Z" creationid="hsugawa8651" creationdate="20181112T112509Z">
        <seg>julia&gt; for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; for j = 1:5
           println(j)
       end
1
2
3
4
5

julia&gt; j
ERROR: UndefVarError: j not defined</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T231206Z" creationid="hsugawa8651" creationdate="20181109T231206Z">
        <seg>julia&gt; for j = 1:5
           println(j)
       end
1
2
3
4
5

julia&gt; j
ERROR: UndefVarError: j not defined</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; frame = stacktrace()[3]
eval(::Module, ::Expr) at REPL.jl:5

julia&gt; frame.func
:eval

julia&gt; frame.file
Symbol("&lt;x1/&gt;/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl")

julia&gt; frame.line
5

julia&gt; top_frame.linfo
MethodInstance for eval(::Module, ::Expr)

julia&gt; top_frame.inlined
false

julia&gt; top_frame.from_c
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020406Z" creationid="hsugawa8651" creationdate="20181116T020406Z">
        <seg>julia&gt; frame = stacktrace()[3]
eval(::Module, ::Expr) at REPL.jl:5

julia&gt; frame.func
:eval

julia&gt; frame.file
Symbol("&lt;x1/&gt;/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl")

julia&gt; frame.line
5

julia&gt; top_frame.linfo
MethodInstance for eval(::Module, ::Expr)

julia&gt; top_frame.inlined
false

julia&gt; top_frame.from_c
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function Base.getindex(S::Squares, i::Int)
           1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia&gt; Squares(100)[23]
529</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113100Z" creationid="hsugawa8651" creationdate="20181112T113100Z">
        <seg>julia&gt; function Base.getindex(S::Squares, i::Int)
           1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia&gt; Squares(100)[23]
529</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function Base.show(io::IO, z::Polar)
           if get(io, :compact, false)
               print(io, z.r, "ℯ", z.Θ, "im")
           else
               print(io, z.r, " * exp(", z.Θ, "im)")
           end
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022143Z" creationid="hsugawa8651" creationdate="20181116T022143Z">
        <seg>julia&gt; function Base.show(io::IO, z::Polar)
           if get(io, :compact, false)
               print(io, z.r, "ℯ", z.Θ, "im")
           else
               print(io, z.r, " * exp(", z.Θ, "im)")
           end
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)
           if Base.operator_precedence(:*) &lt;= precedence
               print(io, "(")
               show(io, z)
               print(io, ")")
           else
               show(io, z)
           end
       end

julia&gt; :($a^2)
:((3.0 * exp(4.0im)) ^ 2)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022129Z" creationid="hsugawa8651" creationdate="20181116T022129Z">
        <seg>julia&gt; function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)
           if Base.operator_precedence(:*) &lt;= precedence
               print(io, "(")
               show(io, z)
               print(io, ")")
           else
               show(io, z)
           end
       end

julia&gt; :($a^2)
:((3.0 * exp(4.0im)) ^ 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function f()
           i = 0
           for i = 1:3
           end
           return i
       end;

julia&gt; f()
0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022402Z" creationid="hsugawa8651" creationdate="20181116T022402Z">
        <seg>julia&gt; function f()
           i = 0
           for i = 1:3
           end
           return i
       end;

julia&gt; f()
0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function f()
           i = 0
           for outer i = 1:3
           end
           return i
       end;

julia&gt; f()
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022405Z" creationid="hsugawa8651" creationdate="20181116T022405Z">
        <seg>julia&gt; function f()
           i = 0
           for outer i = 1:3
           end
           return i
       end;

julia&gt; f()
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function f(x,y)
           x + y
       end
f (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025459Z" creationid="hsugawa8651" creationdate="20181110T025459Z">
        <seg>julia&gt; function f(x,y)
           x + y
       end
f (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function fact(n::Int)
           n &gt;= 0 || error("n must be non-negative")
           n == 0 &amp;&amp; return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia&gt; fact(5)
120

julia&gt; fact(0)
1

julia&gt; fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fact(::Int64) at ./none:2
 [3] top-level scope</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230447Z" creationid="hsugawa8651" creationdate="20181109T230447Z">
        <seg>julia&gt; function fact(n::Int)
           n &gt;= 0 || error("n must be non-negative")
           n == 0 &amp;&amp; return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia&gt; fact(5)
120

julia&gt; fact(0)
1

julia&gt; fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fact(::Int64) at ./none:2
 [3] top-level scope</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia&gt; foo()
100

julia&gt; typeof(ans)
Int8</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021530Z" creationid="hsugawa8651" creationdate="20181116T021530Z">
        <seg>julia&gt; function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia&gt; foo()
100

julia&gt; typeof(ans)
Int8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030028Z" creationid="hsugawa8651" creationdate="20181110T030028Z">
        <seg>julia&gt; function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function g(x, y)::Int8
           return x * y
       end;

julia&gt; typeof(g(1, 2))
Int8</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025812Z" creationid="hsugawa8651" creationdate="20181110T025812Z">
        <seg>julia&gt; function g(x, y)::Int8
           return x * y
       end;

julia&gt; typeof(g(1, 2))
Int8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x &gt; y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia&gt; hypot(3, 4)
5.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025759Z" creationid="hsugawa8651" creationdate="20181110T025759Z">
        <seg>julia&gt; function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x &gt; y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia&gt; hypot(3, 4)
5.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function make_expr2(op, opr1, opr2)
           opr1f, opr2f = map(x -&gt; isa(x, Number) ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015246Z" creationid="hsugawa8651" creationdate="20181116T015246Z">
        <seg>julia&gt; function make_expr2(op, opr1, opr2)
           opr1f, opr2f = map(x -&gt; isa(x, Number) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function math_expr(op, op1, op2)
           expr = Expr(:call, op, op1, op2)
           return expr
       end
math_expr (generic function with 1 method)

julia&gt;  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))
:(1 + 4 * 5)

julia&gt; eval(ex)
21</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015243Z" creationid="hsugawa8651" creationdate="20181116T015243Z">
        <seg>julia&gt; function math_expr(op, op1, op2)
           expr = Expr(:call, op, op1, op2)
           return expr
       end
math_expr (generic function with 1 method)

julia&gt;  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))
:(1 + 4 * 5)

julia&gt; eval(ex)
21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function mycompare(a, b)::Cint</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133239Z" creationid="hsugawa8651" creationdate="20181117T133239Z">
        <seg>julia&gt; function mycompare(a, b)::Cint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022642Z" creationid="hsugawa8651" creationdate="20181116T022642Z">
        <seg>julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)
       end
mycompare (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133940Z" creationid="hsugawa8651" creationdate="20181117T133940Z">
        <seg>julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)
       end
mycompare (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function printargs(args...)
           println(typeof(args))
           for (i, arg) in enumerate(args)
               println("Arg &lt;x1/&gt;$i = $arg")
           end
       end
printargs (generic function with 1 method)

julia&gt; printargs(1, 2, 3)
Tuple{Int64,Int64,Int64}
Arg &lt;x2/&gt;1 = 1
Arg &lt;x3/&gt;2 = 2
Arg &lt;x4/&gt;3 = 3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025242Z" creationid="hsugawa8651" creationdate="20181110T025242Z">
        <seg>julia&gt; function printargs(args...)
           println(typeof(args))
           for (i, arg) in enumerate(args)
               println("Arg &lt;x1/&gt;$i = $arg")
           end
       end
printargs (generic function with 1 method)

julia&gt; printargs(1, 2, 3)
Tuple{Int64,Int64,Int64}
Arg &lt;x2/&gt;1 = 1
Arg &lt;x3/&gt;2 = 2
Arg &lt;x4/&gt;3 = 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N
           ind = I[N] - 1
           for i = N-1:-1:1
               ind = I[i]-1 + dims[i]*ind
           end
           return ind + 1
       end
sub2ind_loop (generic function with 1 method)

julia&gt; sub2ind_loop((3, 5), 1, 2)
4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032245Z" creationid="hsugawa8651" creationdate="20181116T032245Z">
        <seg>julia&gt; function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N
           ind = I[N] - 1
           for i = N-1:-1:1
               ind = I[i]-1 + dims[i]*ind
           end
           return ind + 1
       end
sub2ind_loop (generic function with 1 method)

julia&gt; sub2ind_loop((3, 5), 1, 2)
4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function test(x, y)
           if x &lt; y
               println("x is less than y")
           elseif x &gt; y
               println("x is greater than y")
           else
               println("x is equal to y")
           end
       end
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225852Z" creationid="hsugawa8651" creationdate="20181109T225852Z">
        <seg>julia&gt; function test(x, y)
           if x &lt; y
               println("x is less than y")
           elseif x &gt; y
               println("x is greater than y")
           else
               println("x is equal to y")
           end
       end
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function test(x,y)
           if x &lt; y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           else
               relation = "greater than"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia&gt; test(2, 1)
x is greater than y.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225926Z" creationid="hsugawa8651" creationdate="20181109T225926Z">
        <seg>julia&gt; function test(x,y)
           if x &lt; y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           else
               relation = "greater than"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia&gt; test(2, 1)
x is greater than y.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia&gt; tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054039Z" creationid="hsugawa8651" creationdate="20181116T054039Z">
        <seg>julia&gt; function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia&gt; tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia&gt; tryeval2()
2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054103Z" creationid="hsugawa8651" creationdate="20181116T054103Z">
        <seg>julia&gt; function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia&gt; tryeval2()
2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; g = f;

julia&gt; g(2,3)
5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025635Z" creationid="hsugawa8651" creationdate="20181110T025635Z">
        <seg>julia&gt; g = f;

julia&gt; g(2,3)
5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; g(x) = 2 * x
g (generic function with 1 method)

julia&gt; g(1//2)
1//1

julia&gt; g(1/2)
1.0

julia&gt; g(1)
2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021404Z" creationid="hsugawa8651" creationdate="20181116T021404Z">
        <seg>julia&gt; g(x) = 2 * x
g (generic function with 1 method)

julia&gt; g(1//2)
1//1

julia&gt; g(1/2)
1.0

julia&gt; g(1)
2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; g(x) = f(x)
g (generic function with 1 method)

julia&gt; t = @async f(wait()); yield();</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054112Z" creationid="hsugawa8651" creationdate="20181116T054112Z">
        <seg>julia&gt; g(x) = f(x)
g (generic function with 1 method)

julia&gt; t = @async f(wait()); yield();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; g(x) = f(x);

julia&gt; @generated gen1(x) = f(x);

julia&gt; @generated gen2(x) = :(f(x));</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015713Z" creationid="hsugawa8651" creationdate="20181116T015713Z">
        <seg>julia&gt; g(x) = f(x);

julia&gt; @generated gen1(x) = f(x);

julia&gt; @generated gen2(x) = :(f(x));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia&gt; g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053955Z" creationid="hsugawa8651" creationdate="20181116T053955Z">
        <seg>julia&gt; g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia&gt; g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
10.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054010Z" creationid="hsugawa8651" creationdate="20181116T054010Z">
        <seg>julia&gt; g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
10.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; getenv("SHELL")
"/bin/bash"

julia&gt; getenv("FOOBAR")
getenv: undefined variable: FOOBAR</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224135Z" creationid="hsugawa8651" creationdate="20181109T224135Z">
        <seg>julia&gt; getenv("SHELL")
"/bin/bash"

julia&gt; getenv("FOOBAR")
getenv: undefined variable: FOOBAR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; greet * ", " * whom * ".\n"
"Hello, world.\n"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020750Z" creationid="hsugawa8651" creationdate="20181116T020750Z">
        <seg>julia&gt; greet * ", " * whom * ".\n"
"Hello, world.\n"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; greet = "Hello"
"Hello"

julia&gt; whom = "world"
"world"

julia&gt; string(greet, ", ", whom, ".\n")
"Hello, world.\n"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020743Z" creationid="hsugawa8651" creationdate="20181116T020743Z">
        <seg>julia&gt; greet = "Hello"
"Hello"

julia&gt; whom = "world"
"world"

julia&gt; string(greet, ", ", whom, ".\n")
"Hello, world.\n"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; h(x) = 2//1 * x
h (generic function with 1 method)

julia&gt; h(1//2)
1//1

julia&gt; h(1/2)
1.0

julia&gt; h(1)
2//1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021409Z" creationid="hsugawa8651" creationdate="20181116T021409Z">
        <seg>julia&gt; h(x) = 2//1 * x
h (generic function with 1 method)

julia&gt; h(1//2)
1//1

julia&gt; h(1/2)
1.0

julia&gt; h(1)
2//1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; i = 1;

julia&gt; while i &lt;= 5
           println(i)
           global i += 1
       end
1
2
3
4
5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230848Z" creationid="hsugawa8651" creationdate="20181109T230848Z">
        <seg>julia&gt; i = 1;

julia&gt; while i &lt;= 5
           println(i)
           global i += 1
       end
1
2
3
4
5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; if 1
           println("true")
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230038Z" creationid="hsugawa8651" creationdate="20181109T230038Z">
        <seg>julia&gt; if 1
           println("true")
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; import .Bar

julia&gt; x = -1;

julia&gt; Bar.foo()
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022248Z" creationid="hsugawa8651" creationdate="20181116T022248Z">
        <seg>julia&gt; import .Bar

julia&gt; x = -1;

julia&gt; Bar.foo()
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; isa(1, Int)
true

julia&gt; isa(1, AbstractFloat)
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022047Z" creationid="hsugawa8651" creationdate="20181116T022047Z">
        <seg>julia&gt; isa(1, Int)
true

julia&gt; isa(1, AbstractFloat)
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; isa(1, Type)
false

julia&gt; isa("foo", Type)
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021951Z" creationid="hsugawa8651" creationdate="20181116T021951Z">
        <seg>julia&gt; isa(1, Type)
false

julia&gt; isa("foo", Type)
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; isa(Float64, Type{Float64})
true

julia&gt; isa(Real, Type{Float64})
false

julia&gt; isa(Real, Type{Real})
true

julia&gt; isa(Float64, Type{Real})
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021944Z" creationid="hsugawa8651" creationdate="20181116T021944Z">
        <seg>julia&gt; isa(Float64, Type{Float64})
true

julia&gt; isa(Real, Type{Float64})
false

julia&gt; isa(Real, Type{Real})
true

julia&gt; isa(Float64, Type{Real})
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; isa(Type{Float64}, Type)
true

julia&gt; isa(Float64, Type)
true

julia&gt; isa(Real, Type)
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021946Z" creationid="hsugawa8651" creationdate="20181116T021946Z">
        <seg>julia&gt; isa(Type{Float64}, Type)
true

julia&gt; isa(Float64, Type)
true

julia&gt; isa(Real, Type)
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030607Z" creationid="hsugawa8651" creationdate="20181114T030607Z">
        <seg>julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; isvalid("DATA\xff\u2200")
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021054Z" creationid="hsugawa8651" creationdate="20181116T021054Z">
        <seg>julia&gt; isvalid("DATA\xff\u2200")
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; let
           local x = 1
           let
               local x = 2
           end
           x
       end
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022356Z" creationid="hsugawa8651" creationdate="20181116T022356Z">
        <seg>julia&gt; let
           local x = 1
           let
               local x = 2
           end
           x
       end
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; let state = 0
           global counter() = (state += 1)
       end;

julia&gt; counter()
1

julia&gt; counter()
2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022324Z" creationid="hsugawa8651" creationdate="20181116T022324Z">
        <seg>julia&gt; let state = 0
           global counter() = (state += 1)
       end;

julia&gt; counter()
1

julia&gt; counter()
2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")

julia&gt; m.match
"acd"

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 "a"
 "c"
 "d"

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")

julia&gt; m.match
"ad"

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 "a"
 nothing
 "d"

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020955Z" creationid="hsugawa8651" creationdate="20181116T020955Z">
        <seg>julia&gt; m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")

julia&gt; m.match
"acd"

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 "a"
 "c"
 "d"

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")

julia&gt; m.match
"ad"

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 "a"
 nothing
 "d"

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")

julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")

julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020948Z" creationid="hsugawa8651" creationdate="20181116T020948Z">
        <seg>julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")

julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")

julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; m = match(r"^\s*(?:&lt;x1/&gt;\s*(.*?)\s*$|$)", "&lt;x2/&gt; a comment ")
RegexMatch("&lt;x3/&gt; a comment ", 1="a comment")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020946Z" creationid="hsugawa8651" creationdate="20181116T020946Z">
        <seg>julia&gt; m = match(r"^\s*(?:&lt;x1/&gt;\s*(.*?)\s*$|$)", "&lt;x2/&gt; a comment ")
RegexMatch("&lt;x3/&gt; a comment ", 1="a comment")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; m=match(r"(?&lt;x1/&gt;\d+):(?&lt;x2/&gt;\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")

julia&gt; m[:minute]
"45"

julia&gt; m[2]
"45"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021015Z" creationid="hsugawa8651" creationdate="20181116T021015Z">
        <seg>julia&gt; m=match(r"(?&lt;x1/&gt;\d+):(?&lt;x2/&gt;\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")

julia&gt; m[:minute]
"45"

julia&gt; m[2]
"45"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro __LOCATION__(); return QuoteNode(__source__); end
@__LOCATION__ (macro with 1 method)

julia&gt; dump(
            @__LOCATION__(
       ))
LineNumberNode
  line: Int64 2
  file: Symbol none</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015414Z" creationid="hsugawa8651" creationdate="20181116T015414Z">
        <seg>julia&gt; macro __LOCATION__(); return QuoteNode(__source__); end
@__LOCATION__ (macro with 1 method)

julia&gt; dump(
            @__LOCATION__(
       ))
LineNumberNode
  line: Int64 2
  file: Symbol none</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro assert(ex)
           return :( $ex ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015417Z" creationid="hsugawa8651" creationdate="20181116T015417Z">
        <seg>julia&gt; macro assert(ex)
           return :( $ex ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro assert(ex, msgs...)
           msg_body = isempty(msgs) ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015436Z" creationid="hsugawa8651" creationdate="20181116T015436Z">
        <seg>julia&gt; macro assert(ex, msgs...)
           msg_body = isempty(msgs) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro m end
@m (macro with 0 methods)

julia&gt; macro m(args...)
           println("$(length(args)) arguments")
       end
@m (macro with 1 method)

julia&gt; macro m(x,y)
           println("Two arguments")
       end
@m (macro with 2 methods)

julia&gt; @m "asd"
1 arguments

julia&gt; @m 1 2
Two arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015531Z" creationid="hsugawa8651" creationdate="20181116T015531Z">
        <seg>julia&gt; macro m end
@m (macro with 0 methods)

julia&gt; macro m(args...)
           println("$(length(args)) arguments")
       end
@m (macro with 1 method)

julia&gt; macro m(x,y)
           println("Two arguments")
       end
@m (macro with 2 methods)

julia&gt; @m "asd"
1 arguments

julia&gt; @m 1 2
Two arguments</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro m(::Int)
           println("An Integer")
       end
@m (macro with 3 methods)

julia&gt; @m 2
An Integer

julia&gt; x = 2
2

julia&gt; @m x
1 arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015533Z" creationid="hsugawa8651" creationdate="20181116T015533Z">
        <seg>julia&gt; macro m(::Int)
           println("An Integer")
       end
@m (macro with 3 methods)

julia&gt; @m 2
An Integer

julia&gt; x = 2
2

julia&gt; @m x
1 arguments</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro sayhello()
           return :( println("Hello, world!") )
       end
@sayhello (macro with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015255Z" creationid="hsugawa8651" creationdate="20181116T015255Z">
        <seg>julia&gt; macro sayhello()
           return :( println("Hello, world!") )
       end
@sayhello (macro with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro sayhello(name)
           return :( println("Hello, ", $name) )
       end
@sayhello (macro with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015304Z" creationid="hsugawa8651" creationdate="20181116T015304Z">
        <seg>julia&gt; macro sayhello(name)
           return :( println("Hello, ", $name) )
       end
@sayhello (macro with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro showarg(x)
           show(x)
           &lt;x1/&gt; ... remainder of macro, returning an expression
       end
@showarg (macro with 1 method)

julia&gt; @showarg(a)
:a

julia&gt; @showarg(1+1)
:(1 + 1)

julia&gt; @showarg(println("Yo!"))
:(println("Yo!"))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015409Z" creationid="hsugawa8651" creationdate="20181116T015409Z">
        <seg>julia&gt; macro showarg(x)
           show(x)
           &lt;x1/&gt; ... remainder of macro, returning an expression
       end
@showarg (macro with 1 method)

julia&gt; @showarg(a)
:a

julia&gt; @showarg(1+1)
:(1 + 1)

julia&gt; @showarg(println("Yo!"))
:(println("Yo!"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro twostep(arg)
           println("I execute at parse time.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015318Z" creationid="hsugawa8651" creationdate="20181116T015318Z">
        <seg>julia&gt; macro twostep(arg)
           println("I execute at parse time.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; macro zerox()
           return esc(:(x = 0))
       end
@zerox (macro with 1 method)

julia&gt; function foo()
           x = 1
           @zerox
           return x &lt;x1/&gt; is zero
       end
foo (generic function with 1 method)

julia&gt; foo()
0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015522Z" creationid="hsugawa8651" creationdate="20181116T015522Z">
        <seg>julia&gt; macro zerox()
           return esc(:(x = 0))
       end
@zerox (macro with 1 method)

julia&gt; function foo()
           x = 1
           @zerox
           return x &lt;x1/&gt; is zero
       end
foo (generic function with 1 method)

julia&gt; foo()
0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030004Z" creationid="hsugawa8651" creationdate="20181110T030004Z">
        <seg>julia&gt; map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155000Z" creationid="hsugawa8651" creationdate="20181109T155000Z">
        <seg>julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154944Z" creationid="hsugawa8651" creationdate="20181109T154944Z">
        <seg>julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; map(x -&gt; x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030009Z" creationid="hsugawa8651" creationdate="20181110T030009Z">
        <seg>julia&gt; map(x -&gt; x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; match(r"^\s*(?:&lt;x1/&gt;|$)", "not a comment")

julia&gt; match(r"^\s*(?:&lt;x2/&gt;|$)", "&lt;x3/&gt; a comment")
RegexMatch("&lt;x4/&gt;")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020939Z" creationid="hsugawa8651" creationdate="20181116T020939Z">
        <seg>julia&gt; match(r"^\s*(?:&lt;x1/&gt;|$)", "not a comment")

julia&gt; match(r"^\s*(?:&lt;x2/&gt;|$)", "&lt;x3/&gt; a comment")
RegexMatch("&lt;x4/&gt;")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; methods(+)
&lt;x1/&gt; 180 methods for generic function "+":
[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227
[2] +(x::Bool, y::Bool) in Base at bool.jl:89
[3] +(x::Bool) in Base at bool.jl:86
[4] +(x::Bool, y::T) where T&lt;:AbstractFloat in Base at bool.jl:96
[5] +(x::Bool, z::Complex) in Base at complex.jl:234
[6] +(a::Float16, b::Float16) in Base at float.jl:373
[7] +(x::Float32, y::Float32) in Base at float.jl:375
[8] +(x::Float64, y::Float64) in Base at float.jl:376
[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228
[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242
[11] +(x::Char, y::Integer) in Base at char.jl:40
[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307
[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392
[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391
[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390
[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361
[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398
...
[180] +(a, b, c, xs...) in Base at operators.jl:424</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053951Z" creationid="hsugawa8651" creationdate="20181116T053951Z">
        <seg>julia&gt; methods(+)
&lt;x1/&gt; 180 methods for generic function "+":
[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227
[2] +(x::Bool, y::Bool) in Base at bool.jl:89
[3] +(x::Bool) in Base at bool.jl:86
[4] +(x::Bool, y::T) where T&lt;:AbstractFloat in Base at bool.jl:96
[5] +(x::Bool, z::Complex) in Base at complex.jl:234
[6] +(a::Float16, b::Float16) in Base at float.jl:373
[7] +(x::Float32, y::Float32) in Base at float.jl:375
[8] +(x::Float64, y::Float64) in Base at float.jl:376
[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228
[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242
[11] +(x::Char, y::Integer) in Base at char.jl:40
[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307
[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392
[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391
[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390
[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361
[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398
...
[180] +(a, b, c, xs...) in Base at operators.jl:424</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; methods(f)
&lt;x1/&gt; 2 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T053940Z" creationid="hsugawa8651" creationdate="20181116T053940Z">
        <seg>julia&gt; methods(f)
&lt;x1/&gt; 2 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; minmax(x, y) = (y &lt; x) ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030048Z" creationid="hsugawa8651" creationdate="20181110T030048Z">
        <seg>julia&gt; minmax(x, y) = (y &lt; x) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; missing + 1
missing

julia&gt; "a" * missing
missing

julia&gt; abs(missing)
missing</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054512Z" creationid="hsugawa8651" creationdate="20181116T054512Z">
        <seg>julia&gt; missing + 1
missing

julia&gt; "a" * missing
missing

julia&gt; abs(missing)
missing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; missing == 1
missing

julia&gt; missing == missing
missing

julia&gt; missing &lt; 1
missing

julia&gt; 2 &gt;= missing
missing</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054518Z" creationid="hsugawa8651" creationdate="20181116T054518Z">
        <seg>julia&gt; missing == 1
missing

julia&gt; missing == missing
missing

julia&gt; missing &lt; 1
missing

julia&gt; 2 &gt;= missing
missing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; module A
           a = 1 &lt;x1/&gt; a global in A's scope
       end;

julia&gt; module B
           module C
               c = 2
           end
           b = C.c    &lt;x2/&gt; can access the namespace of a nested global scope
                      &lt;x3/&gt; through a qualified access
           import ..A &lt;x4/&gt; makes module A available
           d = A.a
       end;

julia&gt; module D
           b = a &lt;x5/&gt; errors as D's global scope is separate from A's
       end;
ERROR: UndefVarError: a not defined

julia&gt; module E
           import ..A &lt;x6/&gt; make module A available
           A.a = 2    &lt;x7/&gt; throws below error
       end;
ERROR: cannot assign variables in other modules</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022254Z" creationid="hsugawa8651" creationdate="20181116T022254Z">
        <seg>julia&gt; module A
           a = 1 &lt;x1/&gt; a global in A's scope
       end;

julia&gt; module B
           module C
               c = 2
           end
           b = C.c    &lt;x2/&gt; can access the namespace of a nested global scope
                      &lt;x3/&gt; through a qualified access
           import ..A &lt;x4/&gt; makes module A available
           d = A.a
       end;

julia&gt; module D
           b = a &lt;x5/&gt; errors as D's global scope is separate from A's
       end;
ERROR: UndefVarError: a not defined

julia&gt; module E
           import ..A &lt;x6/&gt; make module A available
           A.a = 2    &lt;x7/&gt; throws below error
       end;
ERROR: cannot assign variables in other modules</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; module Bar
           x = 1
           foo() = x
       end;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022246Z" creationid="hsugawa8651" creationdate="20181116T022246Z">
        <seg>julia&gt; module Bar
           x = 1
           foo() = x
       end;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; mutable struct Bar
           baz
           qux::Float64
       end

julia&gt; bar = Bar("Hello", 1.5);

julia&gt; bar.qux = 2.0
2.0

julia&gt; bar.baz = 1//2
1//2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021711Z" creationid="hsugawa8651" creationdate="20181116T021711Z">
        <seg>julia&gt; mutable struct Bar
           baz
           qux::Float64
       end

julia&gt; bar = Bar("Hello", 1.5);

julia&gt; bar.qux = 2.0
2.0

julia&gt; bar.baz = 1//2
1//2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; mutable struct Incomplete
           data
           Incomplete() = new()
       end

julia&gt; z = Incomplete();</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155925Z" creationid="hsugawa8651" creationdate="20181117T155925Z">
        <seg>julia&gt; mutable struct Incomplete
           data
           Incomplete() = new()
       end

julia&gt; z = Incomplete();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155903Z" creationid="hsugawa8651" creationdate="20181117T155903Z">
        <seg>julia&gt; mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; mutable struct SelfReferential
           obj::SelfReferential
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155843Z" creationid="hsugawa8651" creationdate="20181117T155843Z">
        <seg>julia&gt; mutable struct SelfReferential
           obj::SelfReferential
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia&gt; myappend([1,2,3],4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1

julia&gt; myappend([1.0,2.0,3.0],4.0)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia&gt; myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054024Z" creationid="hsugawa8651" creationdate="20181116T054024Z">
        <seg>julia&gt; myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia&gt; myappend([1,2,3],4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1

julia&gt; myappend([1.0,2.0,3.0],4.0)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia&gt; myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133258Z" creationid="hsugawa8651" creationdate="20181117T133258Z">
        <seg>julia&gt; mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia&gt; isa(("1",), mytupletype)
true

julia&gt; isa(("1",1), mytupletype)
true

julia&gt; isa(("1",1,2), mytupletype)
true

julia&gt; isa(("1",1,2,3.0), mytupletype)
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021931Z" creationid="hsugawa8651" creationdate="20181116T021931Z">
        <seg>julia&gt; mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia&gt; isa(("1",), mytupletype)
true

julia&gt; isa(("1",1), mytupletype)
true

julia&gt; isa(("1",1,2), mytupletype)
true

julia&gt; isa(("1",1,2,3.0), mytupletype)
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia&gt; mytypeof(1)
Int64

julia&gt; mytypeof(1.0)
Float64</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054028Z" creationid="hsugawa8651" creationdate="20181116T054028Z">
        <seg>julia&gt; mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia&gt; mytypeof(1)
Int64

julia&gt; mytypeof(1.0)
Float64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; occursin("world", "Hello, world.")
true

julia&gt; occursin("o", "Xylophon")
true

julia&gt; occursin("a", "Xylophon")
false

julia&gt; occursin('o', "Xylophon")
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020911Z" creationid="hsugawa8651" creationdate="20181116T020911Z">
        <seg>julia&gt; occursin("world", "Hello, world.")
true

julia&gt; occursin("o", "Xylophon")
true

julia&gt; occursin("a", "Xylophon")
false

julia&gt; occursin('o', "Xylophon")
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; occursin(r"^\s*(?:&lt;x1/&gt;|$)", "not a comment")
false

julia&gt; occursin(r"^\s*(?:&lt;x2/&gt;|$)", "&lt;x3/&gt; a comment")
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020936Z" creationid="hsugawa8651" creationdate="20181116T020936Z">
        <seg>julia&gt; occursin(r"^\s*(?:&lt;x1/&gt;|$)", "not a comment")
false

julia&gt; occursin(r"^\s*(?:&lt;x2/&gt;|$)", "&lt;x3/&gt; a comment")
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia&gt; p(3)
931

julia&gt; p()
2551</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054346Z" creationid="hsugawa8651" creationdate="20181116T054346Z">
        <seg>julia&gt; p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia&gt; p(3)
931

julia&gt; p()
2551</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155657Z" creationid="hsugawa8651" creationdate="20181109T155657Z">
        <seg>julia&gt; page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; path = ccall((:getenv, "libc"), Cstring, (Cstring,), "SHELL")
Cstring(@0x00007fff5fbffc45)

julia&gt; unsafe_string(path)
"/bin/bash"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224044Z" creationid="hsugawa8651" creationdate="20181109T224044Z">
        <seg>julia&gt; path = ccall((:getenv, "libc"), Cstring, (Cstring,), "SHELL")
Cstring(@0x00007fff5fbffc45)

julia&gt; unsafe_string(path)
"/bin/bash"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; pi
π = 3.1415926535897...

julia&gt; pi = 3
ERROR: cannot assign variable MathConstants.pi from module Main

julia&gt; sqrt(100)
10.0

julia&gt; sqrt = 4
ERROR: cannot assign variable Base.sqrt from module Main</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022516Z" creationid="hsugawa8651" creationdate="20181116T022516Z">
        <seg>julia&gt; pi
π = 3.1415926535897...

julia&gt; pi = 3
ERROR: cannot assign variable MathConstants.pi from module Main

julia&gt; sqrt(100)
10.0

julia&gt; sqrt = 4
ERROR: cannot assign variable Base.sqrt from module Main</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; pi = 3
3

julia&gt; pi
3

julia&gt; sqrt = 4
4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022514Z" creationid="hsugawa8651" creationdate="20181116T022514Z">
        <seg>julia&gt; pi = 3
3

julia&gt; pi
3

julia&gt; sqrt = 4
4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; pointer = backtrace()[1];

julia&gt; frame = StackTraces.lookup(pointer)
1-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167

julia&gt; println("The top frame is from $(frame[1].func)!")
The top frame is from jl_apply_generic!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020442Z" creationid="hsugawa8651" creationdate="20181116T020442Z">
        <seg>julia&gt; pointer = backtrace()[1];

julia&gt; frame = StackTraces.lookup(pointer)
1-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167

julia&gt; println("The top frame is from $(frame[1].func)!")
The top frame is from jl_apply_generic!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; prefixer(prefix, sleep) = `perl -nle '$|=1; print "'$prefix' ", $_; sleep '$sleep';'`;

julia&gt; run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer("A",2) &amp; prefixer("B",2)));
B 0
A 1
B 2
A 3
B 4
A 5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020336Z" creationid="hsugawa8651" creationdate="20181116T020336Z">
        <seg>julia&gt; prefixer(prefix, sleep) = `perl -nle '$|=1; print "'$prefix' ", $_; sleep '$sleep';'`;

julia&gt; run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer("A",2) &amp; prefixer("B",2)));
B 0
A 1
B 2
A 3
B 4
A 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; print("I have \$100 in my account.\n")
I have $100 in my account.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020823Z" creationid="hsugawa8651" creationdate="20181116T020823Z">
        <seg>julia&gt; print("I have \$100 in my account.\n")
I have $100 in my account.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; println(raw"\\ \\\"")
\\ \"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021128Z" creationid="hsugawa8651" creationdate="20181116T021128Z">
        <seg>julia&gt; println(raw"\\ \\\"")
\\ \"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; r"^\s*(?:&lt;x1/&gt;|$)"
r"^\s*(?:&lt;x2/&gt;|$)"

julia&gt; typeof(ans)
Regex</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020933Z" creationid="hsugawa8651" creationdate="20181116T020933Z">
        <seg>julia&gt; r"^\s*(?:&lt;x1/&gt;|$)"
r"^\s*(?:&lt;x2/&gt;|$)"

julia&gt; typeof(ans)
Regex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; r"a+.*b+.*?d$"ism
r"a+.*b+.*?d$"ims

julia&gt; match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021034Z" creationid="hsugawa8651" creationdate="20181116T021034Z">
        <seg>julia&gt; r"a+.*b+.*?d$"ism
r"a+.*b+.*?d$"ims

julia&gt; match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

julia&gt; join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020917Z" creationid="hsugawa8651" creationdate="20181116T020917Z">
        <seg>julia&gt; repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

julia&gt; join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; replace("a", r"." =&gt; s"\g&lt;x1/&gt;1")
"a1"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021025Z" creationid="hsugawa8651" creationdate="20181116T021025Z">
        <seg>julia&gt; replace("a", r"." =&gt; s"\g&lt;x1/&gt;1")
"a1"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; replace("first second", r"(\w+) (?&lt;x1/&gt;\w+)" =&gt; s"\g&lt;x2/&gt; \1")
"second first"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021021Z" creationid="hsugawa8651" creationdate="20181116T021021Z">
        <seg>julia&gt; replace("first second", r"(\w+) (?&lt;x1/&gt;\w+)" =&gt; s"\g&lt;x2/&gt; \1")
"second first"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; run(`echo hello` &amp; `echo world`);
world
hello</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020315Z" creationid="hsugawa8651" creationdate="20181116T020315Z">
        <seg>julia&gt; run(`echo hello` &amp; `echo world`);
world
hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; run(pipeline(`echo world` &amp; `echo hello`, `sort`));
hello
world</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020319Z" creationid="hsugawa8651" creationdate="20181116T020319Z">
        <seg>julia&gt; run(pipeline(`echo world` &amp; `echo hello`, `sort`));
hello
world</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,
           prefixer("X",3) &amp; prefixer("Y",3) &amp; prefixer("Z",3),
           prefixer("A",2) &amp; prefixer("B",2)));
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020340Z" creationid="hsugawa8651" creationdate="20181116T020340Z">
        <seg>julia&gt; run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,
           prefixer("X",3) &amp; prefixer("Y",3) &amp; prefixer("Z",3),
           prefixer("A",2) &amp; prefixer("B",2)));
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; s = "\u2200 x \u2203 y"
"∀ x ∃ y"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020602Z" creationid="hsugawa8651" creationdate="20181116T020602Z">
        <seg>julia&gt; s = "\u2200 x \u2203 y"
"∀ x ∃ y"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; s = "\xc0\xa0\xe2\x88\xe2|"
"\xc0\xa0\xe2\x88\xe2|"

julia&gt; foreach(display, s)
'\xc0\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)
'\xe2\x88': Malformed UTF-8 (category Ma: Malformed, bad data)
'\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)
'|': ASCII/Unicode U+007c (category Sm: Symbol, math)

julia&gt; isvalid.(collect(s))
4-element BitArray{1}:
 false
 false
 false
  true

julia&gt; s2 = "\xf7\xbf\xbf\xbf"
"\U1fffff"

julia&gt; foreach(display, s2)
'\U1fffff': Unicode U+1fffff (category In: Invalid, too high)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020731Z" creationid="hsugawa8651" creationdate="20181116T020731Z">
        <seg>julia&gt; s = "\xc0\xa0\xe2\x88\xe2|"
"\xc0\xa0\xe2\x88\xe2|"

julia&gt; foreach(display, s)
'\xc0\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)
'\xe2\x88': Malformed UTF-8 (category Ma: Malformed, bad data)
'\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)
'|': ASCII/Unicode U+007c (category Sm: Symbol, math)

julia&gt; isvalid.(collect(s))
4-element BitArray{1}:
 false
 false
 false
  true

julia&gt; s2 = "\xf7\xbf\xbf\xbf"
"\U1fffff"

julia&gt; foreach(display, s2)
'\U1fffff': Unicode U+1fffff (category In: Invalid, too high)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; s = SquaresVector(4)
4-element SquaresVector:
  1
  4
  9
 16

julia&gt; s[s .&gt; 8]
2-element Array{Int64,1}:
  9
 16

julia&gt; s + s
4-element Array{Int64,1}:
  2
  8
 18
 32

julia&gt; sin.(s)
4-element Array{Float64,1}:
  0.8414709848078965
 -0.7568024953079282
  0.4121184852417566
 -0.2879033166650653</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083214Z" creationid="hsugawa8651" creationdate="20181113T083214Z">
        <seg>julia&gt; s = SquaresVector(4)
4-element SquaresVector:
  1
  4
  9
 16

julia&gt; s[s .&gt; 8]
2-element Array{Int64,1}:
  9
 16

julia&gt; s + s
4-element Array{Int64,1}:
  2
  8
 18
 32

julia&gt; sin.(s)
4-element Array{Float64,1}:
  0.8414709848078965
 -0.7568024953079282
  0.4121184852417566
 -0.2879033166650653</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; s[1:1]
"∀"

julia&gt; s[1:2]
ERROR: StringIndexError("∀ x ∃ y", 2)
Stacktrace:
[...]

julia&gt; s[1:4]
"∀ "</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020611Z" creationid="hsugawa8651" creationdate="20181116T020611Z">
        <seg>julia&gt; s[1:1]
"∀"

julia&gt; s[1:2]
ERROR: StringIndexError("∀ x ∃ y", 2)
Stacktrace:
[...]

julia&gt; s[1:4]
"∀ "</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia&gt; s[2]
ERROR: StringIndexError("∀ x ∃ y", 2)
[...]

julia&gt; s[3]
ERROR: StringIndexError("∀ x ∃ y", 3)
Stacktrace:
[...]

julia&gt; s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020607Z" creationid="hsugawa8651" creationdate="20181116T020607Z">
        <seg>julia&gt; s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia&gt; s[2]
ERROR: StringIndexError("∀ x ∃ y", 2)
[...]

julia&gt; s[3]
ERROR: StringIndexError("∀ x ∃ y", 3)
Stacktrace:
[...]

julia&gt; s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; same_type(1, 2)
true

julia&gt; same_type(1, 2.0)
false

julia&gt; same_type(1.0, 2.0)
true

julia&gt; same_type("foo", 2.0)
false

julia&gt; same_type("foo", "bar")
true

julia&gt; same_type(Int32(1), Int64(2))
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054019Z" creationid="hsugawa8651" creationdate="20181116T054019Z">
        <seg>julia&gt; same_type(1, 2)
true

julia&gt; same_type(1, 2.0)
false

julia&gt; same_type(1.0, 2.0)
true

julia&gt; same_type("foo", 2.0)
false

julia&gt; same_type("foo", "bar")
true

julia&gt; same_type(Int32(1), Int64(2))
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia&gt; same_type(x,y) = false
same_type (generic function with 2 methods)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054016Z" creationid="hsugawa8651" creationdate="20181116T054016Z">
        <seg>julia&gt; same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia&gt; same_type(x,y) = false
same_type (generic function with 2 methods)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; same_type_numeric(x::T, y::T) where {T&lt;:Number} = true
same_type_numeric (generic function with 1 method)

julia&gt; same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia&gt; same_type_numeric(1, 2)
true

julia&gt; same_type_numeric(1, 2.0)
false

julia&gt; same_type_numeric(1.0, 2.0)
true

julia&gt; same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T&lt;:Number, ::T&lt;:Number) where T&lt;:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia&gt; same_type_numeric("foo", "bar")
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia&gt; same_type_numeric(Int32(1), Int64(2))
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054030Z" creationid="hsugawa8651" creationdate="20181116T054030Z">
        <seg>julia&gt; same_type_numeric(x::T, y::T) where {T&lt;:Number} = true
same_type_numeric (generic function with 1 method)

julia&gt; same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia&gt; same_type_numeric(1, 2)
true

julia&gt; same_type_numeric(1, 2.0)
false

julia&gt; same_type_numeric(1.0, 2.0)
true

julia&gt; same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T&lt;:Number, ::T&lt;:Number) where T&lt;:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia&gt; same_type_numeric("foo", "bar")
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia&gt; same_type_numeric(Int32(1), Int64(2))
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia&gt; setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia&gt; setprecision(40) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.1000000000004</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111716Z" creationid="hsugawa8651" creationdate="20181112T111716Z">
        <seg>julia&gt; setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia&gt; setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia&gt; setprecision(40) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.1000000000004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; show(IOContext(stdout, :compact=&gt;true), Polar(3, 4.0))
3.0ℯ4.0im

julia&gt; [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Array{Polar{Float64},2}:
 3.0ℯ4.0im  4.0ℯ5.3im</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022148Z" creationid="hsugawa8651" creationdate="20181116T022148Z">
        <seg>julia&gt; show(IOContext(stdout, :compact=&gt;true), Polar(3, 4.0))
3.0ℯ4.0im

julia&gt; [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Array{Polar{Float64},2}:
 3.0ℯ4.0im  4.0ℯ5.3im</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; show(stdout, "text/html", Polar(3.0,4.0))
&lt;x1/&gt;Polar{Float64}&lt;x2/&gt; complex number: 3.0 &lt;x3/&gt;e&lt;x4/&gt;&lt;x5/&gt;4.0 &lt;x6/&gt;i&lt;x7/&gt;&lt;x8/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022123Z" creationid="hsugawa8651" creationdate="20181116T022123Z">
        <seg>julia&gt; show(stdout, "text/html", Polar(3.0,4.0))
&lt;x1/&gt;Polar{Float64}&lt;x2/&gt; complex number: 3.0 &lt;x3/&gt;e&lt;x4/&gt;&lt;x5/&gt;4.0 &lt;x6/&gt;i&lt;x7/&gt;&lt;x8/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sizeof(Float16(4.))
2

julia&gt; 2*Float16(4.)
Float16(8.0)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110716Z" creationid="hsugawa8651" creationdate="20181112T110716Z">
        <seg>julia&gt; sizeof(Float16(4.))
2

julia&gt; 2*Float16(4.)
Float16(8.0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sort([2,3,1])
3-element Array{Int64,1}:
 1
 2
 3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044836Z" creationid="hsugawa8651" creationdate="20181112T044836Z">
        <seg>julia&gt; sort([2,3,1])
3-element Array{Int64,1}:
 1
 2
 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sort([2,3,1], rev=true)
3-element Array{Int64,1}:
 3
 2
 1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044838Z" creationid="hsugawa8651" creationdate="20181112T044838Z">
        <seg>julia&gt; sort([2,3,1], rev=true)
3-element Array{Int64,1}:
 3
 2
 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044925Z" creationid="hsugawa8651" creationdate="20181112T044925Z">
        <seg>julia&gt; sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044917Z" creationid="hsugawa8651" creationdate="20181112T044917Z">
        <seg>julia&gt; sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044921Z" creationid="hsugawa8651" creationdate="20181112T044921Z">
        <seg>julia&gt; sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; stacktrace(trace, true)
21-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167
 do_call at interpreter.c:324
 eval_value at interpreter.c:416
 eval_body at interpreter.c:559
 jl_interpret_toplevel_thunk_callback at interpreter.c:798
 top-level scope
 jl_interpret_toplevel_thunk at interpreter.c:807
 jl_toplevel_eval_flex at toplevel.c:856
 jl_toplevel_eval_in at builtins.c:624
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 jl_apply_generic at gf.c:2167
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 jl_apply_generic at gf.c:2167
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("&lt;x1/&gt;28&lt;x2/&gt;29")){REPL.REPLBackend})() at event.jl:92
 jl_fptr_trampoline at gf.c:1838
 jl_apply_generic at gf.c:2167
 jl_apply at julia.h:1540 [inlined]
 start_task at task.c:268
 ip:0xffffffffffffffff</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020439Z" creationid="hsugawa8651" creationdate="20181116T020439Z">
        <seg>julia&gt; stacktrace(trace, true)
21-element Array{Base.StackTraces.StackFrame,1}:
 jl_apply_generic at gf.c:2167
 do_call at interpreter.c:324
 eval_value at interpreter.c:416
 eval_body at interpreter.c:559
 jl_interpret_toplevel_thunk_callback at interpreter.c:798
 top-level scope
 jl_interpret_toplevel_thunk at interpreter.c:807
 jl_toplevel_eval_flex at toplevel.c:856
 jl_toplevel_eval_in at builtins.c:624
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 jl_apply_generic at gf.c:2167
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 jl_apply_generic at gf.c:2167
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("&lt;x1/&gt;28&lt;x2/&gt;29")){REPL.REPLBackend})() at event.jl:92
 jl_fptr_trampoline at gf.c:1838
 jl_apply_generic at gf.c:2167
 jl_apply at julia.h:1540 [inlined]
 start_task at task.c:268
 ip:0xffffffffffffffff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str = """
           Hello,
           world.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020830Z" creationid="hsugawa8651" creationdate="20181116T020830Z">
        <seg>julia&gt; str = """
           Hello,
           world.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str = "Hello, world.\n"
"Hello, world.\n"

julia&gt; """Contains "quote" characters"""
"Contains \"quote\" characters"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020537Z" creationid="hsugawa8651" creationdate="20181116T020537Z">
        <seg>julia&gt; str = "Hello, world.\n"
"Hello, world.\n"

julia&gt; """Contains "quote" characters"""
"Contains \"quote\" characters"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str = "long string"
"long string"

julia&gt; substr = SubString(str, 1, 4)
"long"

julia&gt; typeof(substr)
SubString{String}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020556Z" creationid="hsugawa8651" creationdate="20181116T020556Z">
        <seg>julia&gt; str = "long string"
"long string"

julia&gt; substr = SubString(str, 1, 4)
"long"

julia&gt; typeof(substr)
SubString{String}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str[0]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [0]
[...]

julia&gt; str[end+1]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [15]
Stacktrace:
[...]</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020547Z" creationid="hsugawa8651" creationdate="20181116T020547Z">
        <seg>julia&gt; str[0]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [0]
[...]

julia&gt; str[end+1]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [15]
Stacktrace:
[...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[end]
'\n': ASCII/Unicode U+000a (category Cc: Other, control)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020539Z" creationid="hsugawa8651" creationdate="20181116T020539Z">
        <seg>julia&gt; str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[end]
'\n': ASCII/Unicode U+000a (category Cc: Other, control)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str[4:9]
"lo, wo"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020549Z" creationid="hsugawa8651" creationdate="20181116T020549Z">
        <seg>julia&gt; str[4:9]
"lo, wo"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[6:6]
","</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020552Z" creationid="hsugawa8651" creationdate="20181116T020552Z">
        <seg>julia&gt; str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[6:6]
","</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; str[end-1]
'.': ASCII/Unicode U+002e (category Po: Punctuation, other)

julia&gt; str[end÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020545Z" creationid="hsugawa8651" creationdate="20181116T020545Z">
        <seg>julia&gt; str[end-1]
'.': ASCII/Unicode U+002e (category Po: Punctuation, other)

julia&gt; str[end÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct DiagPoint{T} &lt;: Pointy{T}
           x::T
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021856Z" creationid="hsugawa8651" creationdate="20181116T021856Z">
        <seg>julia&gt; struct DiagPoint{T} &lt;: Pointy{T}
           x::T
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155810Z" creationid="hsugawa8651" creationdate="20181117T155810Z">
        <seg>julia&gt; struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Foo
           bar
           baz
       end

julia&gt; foo = Foo(1, 2)
Foo(1, 2)

julia&gt; foo.bar
1

julia&gt; foo.baz
2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155629Z" creationid="hsugawa8651" creationdate="20181117T155629Z">
        <seg>julia&gt; struct Foo
           bar
           baz
       end

julia&gt; foo = Foo(1, 2)
Foo(1, 2)

julia&gt; foo.bar
1

julia&gt; foo.baz
2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Foo
           bar
           baz::Int
           qux::Float64
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021646Z" creationid="hsugawa8651" creationdate="20181116T021646Z">
        <seg>julia&gt; struct Foo
           bar
           baz::Int
           qux::Float64
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct NoFields
       end

julia&gt; NoFields() === NoFields()
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021707Z" creationid="hsugawa8651" creationdate="20181116T021707Z">
        <seg>julia&gt; struct NoFields
       end

julia&gt; NoFields() === NoFields()
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x &gt; y ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155743Z" creationid="hsugawa8651" creationdate="20181117T155743Z">
        <seg>julia&gt; struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x &gt; y ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Point{T}
           x::T
           y::T
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021737Z" creationid="hsugawa8651" creationdate="20181116T021737Z">
        <seg>julia&gt; struct Point{T}
           x::T
           y::T
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Point{T} &lt;: Pointy{T}
           x::T
           y::T
       end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021848Z" creationid="hsugawa8651" creationdate="20181116T021848Z">
        <seg>julia&gt; struct Point{T} &lt;: Pointy{T}
           x::T
           y::T
       end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Polar{T&lt;:Real} &lt;: Number
           r::T
           Θ::T
       end

julia&gt; Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022104Z" creationid="hsugawa8651" creationdate="20181116T022104Z">
        <seg>julia&gt; struct Polar{T&lt;:Real} &lt;: Number
           r::T
           Θ::T
       end

julia&gt; Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Polynomial{R}
           coeffs::Vector{R}
       end

julia&gt; function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end

julia&gt; (p::Polynomial)() = p(5)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054341Z" creationid="hsugawa8651" creationdate="20181116T054341Z">
        <seg>julia&gt; struct Polynomial{R}
           coeffs::Vector{R}
       end

julia&gt; function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end

julia&gt; (p::Polynomial)() = p(5)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct SparseArray{T,N} &lt;: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia&gt; SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);

julia&gt; SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia&gt; Base.size(A::SparseArray) = A.dims

julia&gt; Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia&gt; Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia&gt; Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083222Z" creationid="hsugawa8651" creationdate="20181113T083222Z">
        <seg>julia&gt; struct SparseArray{T,N} &lt;: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia&gt; SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);

julia&gt; SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia&gt; Base.size(A::SparseArray) = A.dims

julia&gt; Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia&gt; Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia&gt; Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Squares
           count::Int
       end

julia&gt; Base.iterate(S::Squares, state=1) = state &gt; S.count ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112454Z" creationid="hsugawa8651" creationdate="20181112T112454Z">
        <seg>julia&gt; struct Squares
           count::Int
       end

julia&gt; Base.iterate(S::Squares, state=1) = state &gt; S.count ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct SquaresVector &lt;: AbstractArray{Int, 1}
           count::Int
       end

julia&gt; Base.size(S::SquaresVector) = (S.count,)

julia&gt; Base.IndexStyle(::Type{&lt;:SquaresVector}) = IndexLinear()

julia&gt; Base.getindex(S::SquaresVector, i::Int) = i*i</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083203Z" creationid="hsugawa8651" creationdate="20181113T083203Z">
        <seg>julia&gt; struct SquaresVector &lt;: AbstractArray{Int, 1}
           count::Int
       end

julia&gt; Base.size(S::SquaresVector) = (S.count,)

julia&gt; Base.IndexStyle(::Type{&lt;:SquaresVector}) = IndexLinear()

julia&gt; Base.getindex(S::SquaresVector, i::Int) = i*i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct T1
           x::Int64
       end

julia&gt; struct T2
           x::Int64
           T2(x) = new(x)
       end

julia&gt; T1(1)
T1(1)

julia&gt; T2(1)
T2(1)

julia&gt; T1(1.0)
T1(1)

julia&gt; T2(1.0)
T2(1)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155818Z" creationid="hsugawa8651" creationdate="20181117T155818Z">
        <seg>julia&gt; struct T1
           x::Int64
       end

julia&gt; struct T2
           x::Int64
           T2(x) = new(x)
       end

julia&gt; T1(1)
T1(1)

julia&gt; T2(1)
T2(1)

julia&gt; T1(1.0)
T1(1)

julia&gt; T2(1.0)
T2(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; struct Val{x}
       end

julia&gt; Val(x) = Val{x}()
Val</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022156Z" creationid="hsugawa8651" creationdate="20181116T022156Z">
        <seg>julia&gt; struct Val{x}
       end

julia&gt; Val(x) = Val{x}()
Val</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)
:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032331Z" creationid="hsugawa8651" creationdate="20181116T032331Z">
        <seg>julia&gt; sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)
:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sub2ind_rec(dims::Tuple{}) = 1;

julia&gt; sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =
           i1 == 1 ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032248Z" creationid="hsugawa8651" creationdate="20181116T032248Z">
        <seg>julia&gt; sub2ind_rec(dims::Tuple{}) = 1;

julia&gt; sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =
           i1 == 1 ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154933Z" creationid="hsugawa8651" creationdate="20181109T154933Z">
        <seg>julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; supertype(Float64)
AbstractFloat

julia&gt; supertype(Number)
Any

julia&gt; supertype(AbstractString)
Any

julia&gt; supertype(Any)
Any</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022057Z" creationid="hsugawa8651" creationdate="20181116T022057Z">
        <seg>julia&gt; supertype(Float64)
AbstractFloat

julia&gt; supertype(Number)
Any

julia&gt; supertype(AbstractString)
Any

julia&gt; supertype(Any)
Any</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
  supertype(!Matched::DataType) at operators.jl:42
  supertype(!Matched::UnionAll) at operators.jl:47</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022100Z" creationid="hsugawa8651" creationdate="20181116T022100Z">
        <seg>julia&gt; supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
  supertype(!Matched::DataType) at operators.jl:42
  supertype(!Matched::UnionAll) at operators.jl:47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; t = ccall((:clock, "libc"), Int32, ())
2292761

julia&gt; t
2292761

julia&gt; typeof(ans)
Int32</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224025Z" creationid="hsugawa8651" creationdate="20181109T224025Z">
        <seg>julia&gt; t = ccall((:clock, "libc"), Int32, ())
2292761

julia&gt; t
2292761

julia&gt; typeof(ans)
Int32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; t(x) = (println(x); true)
t (generic function with 1 method)

julia&gt; f(x) = (println(x); false)
f (generic function with 1 method)

julia&gt; t(1) &amp;&amp; t(2)
1
2
true

julia&gt; t(1) &amp;&amp; f(2)
1
2
false

julia&gt; f(1) &amp;&amp; t(2)
1
false

julia&gt; f(1) &amp;&amp; f(2)
1
false

julia&gt; t(1) || t(2)
1
true

julia&gt; t(1) || f(2)
1
true

julia&gt; f(1) || t(2)
1
2
true

julia&gt; f(1) || f(2)
1
2
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230250Z" creationid="hsugawa8651" creationdate="20181109T230250Z">
        <seg>julia&gt; t(x) = (println(x); true)
t (generic function with 1 method)

julia&gt; f(x) = (println(x); false)
f (generic function with 1 method)

julia&gt; t(1) &amp;&amp; t(2)
1
2
true

julia&gt; t(1) &amp;&amp; f(2)
1
2
false

julia&gt; f(1) &amp;&amp; t(2)
1
false

julia&gt; f(1) &amp;&amp; f(2)
1
false

julia&gt; t(1) || t(2)
1
true

julia&gt; t(1) || f(2)
1
true

julia&gt; f(1) || t(2)
1
2
true

julia&gt; f(1) || f(2)
1
2
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; test(x, y) = println(x &lt; y ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230142Z" creationid="hsugawa8651" creationdate="20181109T230142Z">
        <seg>julia&gt; test(x, y) = println(x &lt; y ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; trace = backtrace()
18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:
 Ptr{Nothing} @0x00007fd8734c6209
 Ptr{Nothing} @0x00007fd87362b342
 Ptr{Nothing} @0x00007fd87362c136
 Ptr{Nothing} @0x00007fd87362c986
 Ptr{Nothing} @0x00007fd87362d089
 Base.InterpreterIP(CodeInfo(:(begin
      Core.SSAValue(0) = backtrace()
      trace = Core.SSAValue(0)
      return Core.SSAValue(0)
  end)), 0x0000000000000000)
 Ptr{Nothing} @0x00007fd87362e4cf
[...]

julia&gt; stacktrace(trace)
6-element Array{Base.StackTraces.StackFrame,1}:
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("&lt;x1/&gt;28&lt;x2/&gt;29")){REPL.REPLBackend})() at event.jl:92</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020434Z" creationid="hsugawa8651" creationdate="20181116T020434Z">
        <seg>julia&gt; trace = backtrace()
18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:
 Ptr{Nothing} @0x00007fd8734c6209
 Ptr{Nothing} @0x00007fd87362b342
 Ptr{Nothing} @0x00007fd87362c136
 Ptr{Nothing} @0x00007fd87362c986
 Ptr{Nothing} @0x00007fd87362d089
 Base.InterpreterIP(CodeInfo(:(begin
      Core.SSAValue(0) = backtrace()
      trace = Core.SSAValue(0)
      return Core.SSAValue(0)
  end)), 0x0000000000000000)
 Ptr{Nothing} @0x00007fd87362e4cf
[...]

julia&gt; stacktrace(trace)
6-element Array{Base.StackTraces.StackFrame,1}:
 top-level scope
 eval at boot.jl:317 [inlined]
 eval(::Module, ::Expr) at REPL.jl:5
 eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 macro expansion at REPL.jl:116 [inlined]
 (::getfield(REPL, Symbol("&lt;x1/&gt;28&lt;x2/&gt;29")){REPL.REPLBackend})() at event.jl:92</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; true &amp;&amp; (x = (1, 2, 3))
(1, 2, 3)

julia&gt; false &amp;&amp; (x = (1, 2, 3))
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230829Z" creationid="hsugawa8651" creationdate="20181109T230829Z">
        <seg>julia&gt; true &amp;&amp; (x = (1, 2, 3))
(1, 2, 3)

julia&gt; false &amp;&amp; (x = (1, 2, 3))
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; try
           error("(A) The root cause")
       catch
           try
               error("(B) An exception while handling the exception")
           catch
               for (exc, bt) in catch_stack()
                   showerror(stdout, exc, bt)
                   println()
               end
           end
       end
(A) The root cause
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:2
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("&lt;x1/&gt;26&lt;x2/&gt;27")){REPL.REPLBackend})() at task.jl:259
(B) An exception while handling the exception
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:5
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("&lt;x3/&gt;26&lt;x4/&gt;27")){REPL.REPLBackend})() at task.jl:259</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020429Z" creationid="hsugawa8651" creationdate="20181116T020429Z">
        <seg>julia&gt; try
           error("(A) The root cause")
       catch
           try
               error("(B) An exception while handling the exception")
           catch
               for (exc, bt) in catch_stack()
                   showerror(stdout, exc, bt)
                   println()
               end
           end
       end
(A) The root cause
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:2
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("&lt;x1/&gt;26&lt;x2/&gt;27")){REPL.REPLBackend})() at task.jl:259
(B) An exception while handling the exception
Stacktrace:
 [1] error(::String) at error.jl:33
 [2] top-level scope at REPL[7]:5
 [3] eval(::Module, ::Any) at boot.jl:319
 [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85
 [5] macro expansion at REPL.jl:117 [inlined]
 [6] (::getfield(REPL, Symbol("&lt;x3/&gt;26&lt;x4/&gt;27")){REPL.REPLBackend})() at task.jl:259</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; typeof((1,"foo",2.5))
Tuple{Int64,String,Float64}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021921Z" creationid="hsugawa8651" creationdate="20181116T021921Z">
        <seg>julia&gt; typeof((1,"foo",2.5))
Tuple{Int64,String,Float64}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; typeof((a=1,b="hello"))
NamedTuple{(:a, :b),Tuple{Int64,String}}</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021936Z" creationid="hsugawa8651" creationdate="20181116T021936Z">
        <seg>julia&gt; typeof((a=1,b="hello"))
NamedTuple{(:a, :b),Tuple{Int64,String}}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; typeof(:("a should equal b"))
String

julia&gt; typeof(:("a ($a) should equal b ($b)!"))
Expr

julia&gt; dump(:("a ($a) should equal b ($b)!"))
Expr
  head: Symbol string
  args: Array{Any}((5,))
    1: String "a ("
    2: Symbol a
    3: String ") should equal b ("
    4: Symbol b
    5: String ")!"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015451Z" creationid="hsugawa8651" creationdate="20181116T015451Z">
        <seg>julia&gt; typeof(:("a should equal b"))
String

julia&gt; typeof(:("a ($a) should equal b ($b)!"))
Expr

julia&gt; dump(:("a ($a) should equal b ($b)!"))
Expr
  head: Symbol string
  args: Array{Any}((5,))
    1: String "a ("
    2: Symbol a
    3: String ") should equal b ("
    4: Symbol b
    5: String ")!"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; typeof(DataType)
DataType

julia&gt; typeof(Union)
DataType</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022054Z" creationid="hsugawa8651" creationdate="20181116T022054Z">
        <seg>julia&gt; typeof(DataType)
DataType

julia&gt; typeof(Union)
DataType</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; typeof(Rational{Int})
DataType

julia&gt; typeof(Union{Real,String})
Union</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022051Z" creationid="hsugawa8651" creationdate="20181116T022051Z">
        <seg>julia&gt; typeof(Rational{Int})
DataType

julia&gt; typeof(Union{Real,String})
Union</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; typeof(Real)
DataType

julia&gt; typeof(Int)
DataType</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021720Z" creationid="hsugawa8651" creationdate="20181116T021720Z">
        <seg>julia&gt; typeof(Real)
DataType

julia&gt; typeof(Int)
DataType</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; typeof(ex)
Expr

julia&gt; ex
:((println)("I execute at runtime.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015344Z" creationid="hsugawa8651" creationdate="20181116T015344Z">
        <seg>julia&gt; typeof(ex)
Expr

julia&gt; ex
:((println)("I execute at runtime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; using Dates

julia&gt; Date(2000, 12, 12)
2000-12-12

julia&gt; Date(2000, 12)
2000-12-01

julia&gt; Date(2000)
2000-01-01</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030125Z" creationid="hsugawa8651" creationdate="20181110T030125Z">
        <seg>julia&gt; using Dates

julia&gt; Date(2000, 12, 12)
2000-12-12

julia&gt; Date(2000, 12)
2000-12-01

julia&gt; Date(2000)
2000-01-01</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; "v: $v"
"v: [1, 2, 3]"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020815Z" creationid="hsugawa8651" creationdate="20181116T020815Z">
        <seg>julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; "v: $v"
"v: [1, 2, 3]"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia&gt; p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia&gt; v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044905Z" creationid="hsugawa8651" creationdate="20181112T044905Z">
        <seg>julia&gt; v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia&gt; p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia&gt; v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; 1 &lt; 2 ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230204Z" creationid="hsugawa8651" creationdate="20181109T230204Z">
        <seg>julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; 1 &lt; 2 ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030729Z" creationid="hsugawa8651" creationdate="20181114T030729Z">
        <seg>julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; vcat([1, 2], 3)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; hcat([1 2], 3)
1×3 Array{Int64,2}:
 1  2  3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154606Z" creationid="hsugawa8651" creationdate="20181109T154606Z">
        <seg>julia&gt; vcat([1, 2], 3)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; hcat([1 2], 3)
1×3 Array{Int64,2}:
 1  2  3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x -&gt; x^2 + 2x - 1
&lt;x1/&gt;1 (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
&lt;x2/&gt;3 (generic function with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025957Z" creationid="hsugawa8651" creationdate="20181110T025957Z">
        <seg>julia&gt; x -&gt; x^2 + 2x - 1
&lt;x1/&gt;1 (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
&lt;x2/&gt;3 (generic function with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = (2, 3, 4)
(2, 3, 4)

julia&gt; bar(1,x...)
(1, 2, (3, 4))

julia&gt; x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia&gt; bar(x...)
(1, 2, (3, 4))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030107Z" creationid="hsugawa8651" creationdate="20181110T030107Z">
        <seg>julia&gt; x = (2, 3, 4)
(2, 3, 4)

julia&gt; bar(1,x...)
(1, 2, (3, 4))

julia&gt; x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia&gt; bar(x...)
(1, 2, (3, 4))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = (3, 4)
(3, 4)

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030104Z" creationid="hsugawa8651" creationdate="20181110T030104Z">
        <seg>julia&gt; x = (3, 4)
(3, 4)

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)

julia&gt; x.a
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030023Z" creationid="hsugawa8651" creationdate="20181110T030023Z">
        <seg>julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)

julia&gt; x.a
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 0;

julia&gt; for i = 1:10
           local x &lt;x1/&gt; this is also the default
           x = i + 1
       end

julia&gt; x
0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022304Z" creationid="hsugawa8651" creationdate="20181116T022304Z">
        <seg>julia&gt; x = 0;

julia&gt; for i = 1:10
           local x &lt;x1/&gt; this is also the default
           x = i + 1
       end

julia&gt; x
0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132355Z" creationid="hsugawa8651" creationdate="20181113T132355Z">
        <seg>julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 1.0
1.0

julia&gt; y = -3
-3

julia&gt; Z = "My string"
"My string"

julia&gt; customary_phrase = "Hello world!"
"Hello world!"

julia&gt; UniversalDeclarationOfHumanRightsStart = "人人生而自由，在尊严和权利上一律平等。"
"人人生而自由，在尊严和权利上一律平等。"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022502Z" creationid="hsugawa8651" creationdate="20181116T022502Z">
        <seg>julia&gt; x = 1.0
1.0

julia&gt; y = -3
-3

julia&gt; Z = "My string"
"My string"

julia&gt; customary_phrase = "Hello world!"
"Hello world!"

julia&gt; UniversalDeclarationOfHumanRightsStart = "人人生而自由，在尊严和权利上一律平等。"
"人人生而自由，在尊严和权利上一律平等。"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 1.25f0
1.25f0

julia&gt; nextfloat(x)
1.2500001f0

julia&gt; prevfloat(x)
1.2499999f0

julia&gt; bitstring(prevfloat(x))
"00111111100111111111111111111111"

julia&gt; bitstring(x)
"00111111101000000000000000000000"

julia&gt; bitstring(nextfloat(x))
"00111111101000000000000000000001"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111321Z" creationid="hsugawa8651" creationdate="20181112T111321Z">
        <seg>julia&gt; x = 1.25f0
1.25f0

julia&gt; nextfloat(x)
1.2500001f0

julia&gt; prevfloat(x)
1.2499999f0

julia&gt; bitstring(prevfloat(x))
"00111111100111111111111111111111"

julia&gt; bitstring(x)
"00111111101000000000000000000000"

julia&gt; bitstring(nextfloat(x))
"00111111101000000000000000000001"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 10
10

julia&gt; function change_value!(y)
           y = 17
       end
change_value!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025000Z" creationid="hsugawa8651" creationdate="20181110T025000Z">
        <seg>julia&gt; x = 10
10

julia&gt; function change_value!(y)
           y = 17
       end
change_value!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 10
10

julia&gt; r"$x"
r"$x"

julia&gt; "$x"
"10"

julia&gt; r"\x"
r"\x"

julia&gt; "\x"
ERROR: syntax: invalid escape sequence</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021038Z" creationid="hsugawa8651" creationdate="20181116T021038Z">
        <seg>julia&gt; x = 10
10

julia&gt; r"$x"
r"$x"

julia&gt; "$x"
"10"

julia&gt; r"\x"
r"\x"

julia&gt; "\x"
ERROR: syntax: invalid escape sequence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 1;

julia&gt; function foobar()
           global x = 2
       end;

julia&gt; foobar();

julia&gt; x
2</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022318Z" creationid="hsugawa8651" creationdate="20181116T022318Z">
        <seg>julia&gt; x = 1;

julia&gt; function foobar()
           global x = 2
       end;

julia&gt; foobar();

julia&gt; x
2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 1; y = 2;

julia&gt; println(x &lt; y ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230124Z" creationid="hsugawa8651" creationdate="20181109T230124Z">
        <seg>julia&gt; x = 1; y = 2;

julia&gt; println(x &lt; y ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 3
3

julia&gt; 2x^2 - 3x + 1
10

julia&gt; 1.5x^2 - .5x + 1
13.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111734Z" creationid="hsugawa8651" creationdate="20181112T111734Z">
        <seg>julia&gt; x = 3
3

julia&gt; 2x^2 - 3x + 1
10

julia&gt; 1.5x^2 - .5x + 1
13.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = 3
3

julia&gt; if x &gt; 0
           "positive!"
       else
           "negative..."
       end
"positive!"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230026Z" creationid="hsugawa8651" creationdate="20181109T230026Z">
        <seg>julia&gt; x = 3
3

julia&gt; if x &gt; 0
           "positive!"
       else
           "negative..."
       end
"positive!"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = :(1 + 2);

julia&gt; e = quote quote $x end end
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    $(Expr(:quote, quote
    &lt;x3/&gt;= none:1 =&lt;x4/&gt;
    $(Expr(:$, :x))
end))
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015204Z" creationid="hsugawa8651" creationdate="20181116T015204Z">
        <seg>julia&gt; x = :(1 + 2);

julia&gt; e = quote quote $x end end
quote
    &lt;x1/&gt;= none:1 =&lt;x2/&gt;
    $(Expr(:quote, quote
    &lt;x3/&gt;= none:1 =&lt;x4/&gt;
    $(Expr(:$, :x))
end))
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = MyNumber(π)
MyNumber(3.141592653589793)

julia&gt; sin(x)
MyNumber(1.2246467991473532e-16)

julia&gt; cos(x)
MyNumber(-1.0)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015544Z" creationid="hsugawa8651" creationdate="20181116T015544Z">
        <seg>julia&gt; x = MyNumber(π)
MyNumber(3.141592653589793)

julia&gt; sin(x)
MyNumber(1.2246467991473532e-16)

julia&gt; cos(x)
MyNumber(-1.0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = SelfReferential();

julia&gt; x === x
true

julia&gt; x === x.obj
true

julia&gt; x === x.obj.obj
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T155909Z" creationid="hsugawa8651" creationdate="20181117T155909Z">
        <seg>julia&gt; x = SelfReferential();

julia&gt; x === x
true

julia&gt; x === x.obj
true

julia&gt; x === x.obj.obj
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; function change_array!(A)
           A[1] = 5
       end
change_array!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025049Z" creationid="hsugawa8651" creationdate="20181110T025049Z">
        <seg>julia&gt; x = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; function change_array!(A)
           A[1] = 5
       end
change_array!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))

julia&gt; x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; bar(x...)
(1, 2, (3, 4))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030112Z" creationid="hsugawa8651" creationdate="20181110T030112Z">
        <seg>julia&gt; x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))

julia&gt; x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; bar(x...)
(1, 2, (3, 4))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = b"123"
3-element Base.CodeUnits{UInt8,String}:
 0x31
 0x32
 0x33

julia&gt; x[1]
0x31

julia&gt; x[1] = 0x32
ERROR: setindex!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021056Z" creationid="hsugawa8651" creationdate="20181116T021056Z">
        <seg>julia&gt; x = b"123"
3-element Base.CodeUnits{UInt8,String}:
 0x31
 0x32
 0x33

julia&gt; x[1]
0x31

julia&gt; x[1] = 0x32
ERROR: setindex!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[3, 3] = -9;

julia&gt; x[1:2, 1:2] = [-1 -4; -2 -5];

julia&gt; x
3×3 Array{Int64,2}:
 -1  -4   7
 -2  -5   8
  3   6  -9</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155453Z" creationid="hsugawa8651" creationdate="20181109T155453Z">
        <seg>julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[3, 3] = -9;

julia&gt; x[1:2, 1:2] = [-1 -4; -2 -5];

julia&gt; x
3×3 Array{Int64,2}:
 -1  -4   7
 -2  -5   8
  3   6  -9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = foo(2); &lt;x1/&gt; note: output is from println() statement in the body
Int64

julia&gt; x           &lt;x2/&gt; now we print x
4

julia&gt; y = foo("bar");
String

julia&gt; y
"barbar"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015701Z" creationid="hsugawa8651" creationdate="20181116T015701Z">
        <seg>julia&gt; x = foo(2); &lt;x1/&gt; note: output is from println() statement in the body
Int64

julia&gt; x           &lt;x2/&gt; now we print x
4

julia&gt; y = foo("bar");
String

julia&gt; y
"barbar"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154823Z" creationid="hsugawa8651" creationdate="20181109T154823Z">
        <seg>julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155304Z" creationid="hsugawa8651" creationdate="20181109T155304Z">
        <seg>julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia&gt; mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia&gt; x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155818Z" creationid="hsugawa8651" creationdate="20181109T155818Z">
        <seg>julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia&gt; mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia&gt; x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = typemax(Int64)
9223372036854775807

julia&gt; x + 1
-9223372036854775808

julia&gt; x + 1 == typemin(Int64)
true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225616Z" creationid="hsugawa8651" creationdate="20181109T225616Z">
        <seg>julia&gt; x = typemax(Int64)
9223372036854775807

julia&gt; x + 1
-9223372036854775808

julia&gt; x + 1 == typemin(Int64)
true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x = typemin(Int64)
-9223372036854775808

julia&gt; x = x - 1
9223372036854775807

julia&gt; typeof(x)
Int64

julia&gt; y = BigInt(typemin(Int64))
-9223372036854775808

julia&gt; y = y - 1
-9223372036854775809

julia&gt; typeof(y)
BigInt</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T111557Z" creationid="hsugawa8651" creationdate="20181112T111557Z">
        <seg>julia&gt; x = typemin(Int64)
-9223372036854775808

julia&gt; x = x - 1
9223372036854775807

julia&gt; typeof(x)
Int64

julia&gt; y = BigInt(typemin(Int64))
-9223372036854775808

julia&gt; y = y - 1
-9223372036854775809

julia&gt; typeof(y)
BigInt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x, y = 1, 2;

julia&gt; function bar()
           x = 10 &lt;x1/&gt; local, no longer a closure variable
           return x + y
       end;

julia&gt; function quz()
           x = 2 &lt;x2/&gt; local
           return bar() + x &lt;x3/&gt; 12 + 2 (x is not modified)
       end;

julia&gt; quz()
14

julia&gt; x, y &lt;x4/&gt; verify that global x and y are unchanged
(1, 2)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022328Z" creationid="hsugawa8651" creationdate="20181116T022328Z">
        <seg>julia&gt; x, y = 1, 2;

julia&gt; function bar()
           x = 10 &lt;x1/&gt; local, no longer a closure variable
           return x + y
       end;

julia&gt; function quz()
           x = 2 &lt;x2/&gt; local
           return bar() + x &lt;x3/&gt; 12 + 2 (x is not modified)
       end;

julia&gt; quz()
14

julia&gt; x, y &lt;x4/&gt; verify that global x and y are unchanged
(1, 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x, y = 1, 2;

julia&gt; function baz()
           x = 2 &lt;x1/&gt; introduces a new local
           function bar()
               x = 10       &lt;x2/&gt; modifies the parent's x
               return x + y &lt;x3/&gt; y is global
           end
           return bar() + x &lt;x4/&gt; 12 + 10 (x is modified in call of bar())
       end;

julia&gt; baz()
22

julia&gt; x, y &lt;x5/&gt; verify that global x and y are unchanged
(1, 2)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022320Z" creationid="hsugawa8651" creationdate="20181116T022320Z">
        <seg>julia&gt; x, y = 1, 2;

julia&gt; function baz()
           x = 2 &lt;x1/&gt; introduces a new local
           function bar()
               x = 10       &lt;x2/&gt; modifies the parent's x
               return x + y &lt;x3/&gt; y is global
           end
           return bar() + x &lt;x4/&gt; 12 + 10 (x is modified in call of bar())
       end;

julia&gt; baz()
22

julia&gt; x, y &lt;x5/&gt; verify that global x and y are unchanged
(1, 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x, y = 1, 2;

julia&gt; function foo()
           x = 2        &lt;x1/&gt; assignment introduces a new local
           return x + y &lt;x2/&gt; y refers to the global
       end;

julia&gt; foo()
4

julia&gt; x
1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022314Z" creationid="hsugawa8651" creationdate="20181116T022314Z">
        <seg>julia&gt; x, y = 1, 2;

julia&gt; function foo()
           x = 2        &lt;x1/&gt; assignment introduces a new local
           return x + y &lt;x2/&gt; y refers to the global
       end;

julia&gt; foo()
4

julia&gt; x
1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x, y = foo(2,3)
(5, 6)

julia&gt; x
5

julia&gt; y
6</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030035Z" creationid="hsugawa8651" creationdate="20181110T030035Z">
        <seg>julia&gt; x, y = foo(2,3)
(5, 6)

julia&gt; x
5

julia&gt; y
6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           println("x: $x, y: $y") &lt;x1/&gt; x is local variable, y the global
           println("z: $z") &lt;x2/&gt; errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022342Z" creationid="hsugawa8651" creationdate="20181116T022342Z">
        <seg>julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           println("x: $x, y: $y") &lt;x1/&gt; x is local variable, y the global
           println("z: $z") &lt;x2/&gt; errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; z = (x = 1; y = 2; x + y)
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225811Z" creationid="hsugawa8651" creationdate="20181109T225811Z">
        <seg>julia&gt; z = (x = 1; y = 2; x + y)
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; z = begin
           x = 1
           y = 2
           x + y
       end
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T225805Z" creationid="hsugawa8651" creationdate="20181109T225805Z">
        <seg>julia&gt; z = begin
           x = 1
           y = 2
           x + y
       end
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; zero(Float32)
0.0f0

julia&gt; zero(1.0)
0.0

julia&gt; one(Int32)
1

julia&gt; one(BigFloat)
1.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112028Z" creationid="hsugawa8651" creationdate="20181112T112028Z">
        <seg>julia&gt; zero(Float32)
0.0f0

julia&gt; zero(1.0)
0.0

julia&gt; one(Int32)
1

julia&gt; one(BigFloat)
1.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia&gt; zeros(Int8, (2, 3))
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia&gt; zeros((2, 3))
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154527Z" creationid="hsugawa8651" creationdate="20181109T154527Z">
        <seg>julia&gt; zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia&gt; zeros(Int8, (2, 3))
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia&gt; zeros((2, 3))
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; δ = 0.00001
1.0e-5

julia&gt; 안녕하세요 = "Hello"
"Hello"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022509Z" creationid="hsugawa8651" creationdate="20181116T022509Z">
        <seg>julia&gt; δ = 0.00001
1.0e-5

julia&gt; 안녕하세요 = "Hello"
"Hello"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>julia&gt; ∑(x,y) = x + y
∑ (generic function with 1 method)

julia&gt; ∑(2, 3)
5</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025648Z" creationid="hsugawa8651" creationdate="20181110T025648Z">
        <seg>julia&gt; ∑(x,y) = x + y
∑ (generic function with 1 method)

julia&gt; ∑(2, 3)
5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastindex(X)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113016Z" creationid="hsugawa8651" creationdate="20181112T113016Z">
        <seg>lastindex(X)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>length(A)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022406Z" creationid="hsugawa8651" creationdate="20181113T022406Z">
        <seg>length(A)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>length(iter)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112217Z" creationid="hsugawa8651" creationdate="20181112T112217Z">
        <seg>length(iter)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>length(iter)&lt;x1/&gt;  and &lt;x2/&gt;size(iter, [dim])&lt;x3/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112314Z" creationid="hsugawa8651" creationdate="20181112T112314Z">
        <seg>length(iter)&lt;x1/&gt;  and &lt;x2/&gt;size(iter, [dim])&lt;x3/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>less than or equal to</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030435Z" creationid="hsugawa8651" creationdate="20181114T030412Z">
        <seg>以下の値以下</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib = Libdl.dlopen("./my_lib.so") &lt;x1/&gt; Open the library explicitly.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152359Z" creationid="hsugawa8651" creationdate="20181117T152359Z">
        <seg>lib = Libdl.dlopen("./my_lib.so") &lt;x1/&gt; Open the library explicitly.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local x::Int8  &lt;x1/&gt; in a local declaration
x::Int8 = 10   &lt;x2/&gt; as the left-hand side of an assignment</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021537Z" creationid="hsugawa8651" creationdate="20181116T021537Z">
        <seg>local x::Int8  &lt;x1/&gt; in a local declaration
x::Int8 = 10   &lt;x2/&gt; as the left-hand side of an assignment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>logical shift&lt;x1/&gt; right</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132309Z" creationid="hsugawa8651" creationdate="20181113T132309Z">
        <seg>論理シフト&lt;x1/&gt;右</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>logical/arithmetic shift left</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132323Z" creationid="hsugawa8651" creationdate="20181113T132323Z">
        <seg>論理/算術シフト左</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m = match(r"^\s*(?:&lt;x1/&gt;|$)", line)
if m === nothing
    println("not a comment")
else
    println("blank or comment")
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020942Z" creationid="hsugawa8651" creationdate="20181116T020942Z">
        <seg>m = match(r"^\s*(?:&lt;x1/&gt;|$)", line)
if m === nothing
    println("not a comment")
else
    println("blank or comment")
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m&lt;x1/&gt;-by-&lt;x2/&gt;n&lt;x3/&gt; identity matrix</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154456Z" creationid="hsugawa8651" creationdate="20181109T154456Z">
        <seg>m&lt;x1/&gt;-by-&lt;x2/&gt;n&lt;x3/&gt;識別マトリクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>macro cmd(str)
    :(cmd_gen($(shell_parse(str)[1])))
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015646Z" creationid="hsugawa8651" creationdate="20181116T015646Z">
        <seg>macro cmd(str)
    :(cmd_gen($(shell_parse(str)[1])))
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>macro dlsym(func, lib)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = $zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
ccall(@dlsym("myfunc", mylibvar), Cvoid, ())</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152331Z" creationid="hsugawa8651" creationdate="20181117T152331Z">
        <seg>macro dlsym(func, lib)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = $zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
ccall(@dlsym("myfunc", mylibvar), Cvoid, ())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>macro r_str(p)
    Regex(p)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015622Z" creationid="hsugawa8651" creationdate="20181116T015622Z">
        <seg>macro r_str(p)
    Regex(p)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>macro time(ex)
    ...
    local val = $(esc(ex))
    ...
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015518Z" creationid="hsugawa8651" creationdate="20181116T015518Z">
        <seg>macro time(ex)
    ...
    local val = $(esc(ex))
    ...
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>macro time(ex)
    return quote
        local t0 = time()
        local val = $ex
        local t1 = time()
        println("elapsed time: ", t1-t0, " seconds")
        val
    end
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015500Z" creationid="hsugawa8651" creationdate="20181116T015500Z">
        <seg>macro time(ex)
    return quote
        local t0 = time()
        local val = $ex
        local t1 = time()
        println("elapsed time: ", t1-t0, " seconds")
        val
    end
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>macro time(expr)
    return :(timeit(() -&gt; $(esc(expr))))
end
function timeit(f)
    t0 = time()
    val = f()
    t1 = time()
    println("elapsed time: ", t1-t0, " seconds")
    return val
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015527Z" creationid="hsugawa8651" creationdate="20181116T015527Z">
        <seg>macro time(expr)
    return :(timeit(() -&gt; $(esc(expr))))
end
function timeit(f)
    t0 = time()
    val = f()
    t1 = time()
    println("elapsed time: ", t1-t0, " seconds")
    return val
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>map(OneTo, size(A))&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022516Z" creationid="hsugawa8651" creationdate="20181113T022516Z">
        <seg>map(OneTo, size(A))&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>map([A, B, C]) do x
    if x &lt; 0 &amp;&amp; iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030213Z" creationid="hsugawa8651" creationdate="20181110T030213Z">
        <seg>map([A, B, C]) do x
    if x &lt; 0 &amp;&amp; iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>map(x-&gt;begin
           if x &lt; 0 &amp;&amp; iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030210Z" creationid="hsugawa8651" creationdate="20181110T030210Z">
        <seg>map(x-&gt;begin
           if x &lt; 0 &amp;&amp; iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maps values to their additive inverses</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131958Z" creationid="hsugawa8651" creationdate="20181113T131958Z">
        <seg>値を加算インスタンスにマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meaning</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150217Z" creationid="hsugawa8651" creationdate="20181117T150217Z">
        <seg>意味</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>min.(x,y)&lt;x1/&gt;, for elementwise operations over arrays or mixtures of arrays and
scalars (a &lt;x2/&gt;Broadcasting&lt;x3/&gt; operation); these have the additional advantage of
"fusing" into a single loop when combined with other dot calls, e.g. &lt;x4/&gt;sin.(cos.(x))&lt;x5/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T161224Z" creationid="hsugawa8651" creationdate="20181114T161224Z">
        <seg>(x,y)&lt;x1/&gt;配列またはアレイの混合物を構成する要素演算に対して&lt;x x1/&gt; スカラー(&lt;x2/&gt;ブロードキャスト&lt;x3/&gt;オペレーション);これらは追加の利点を有する。 他のドット呼び出し(例えば&lt;x4/&gt;sin.(cos.(x))&lt;x5/&gt;)と組み合わされた場合、単一ループへの「融合」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>module
export
import
using
baremodule
function
macro
return
do
begin
end
let
if
for
while
break
continue
try
finally
quote
local
global
const
struct
mutable struct
abstract type
primitive type
where
...
;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T041812Z" creationid="hsugawa8651" creationdate="20181110T041812Z">
        <seg>module
export
import
using
baremodule
function
macro
return
do
begin
end
let
if
for
while
break
continue
try
finally
quote
local
global
const
struct
mutable struct
abstract type
primitive type
where
...
;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021350Z" creationid="hsugawa8651" creationdate="20181116T021350Z">
        <seg>module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>module Bar
export bar
using Foo
function bar(...)
    &lt;x1/&gt; ... refer to Foo.baz as simply baz ....</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025158Z" creationid="hsugawa8651" creationdate="20181110T025158Z">
        <seg>module Bar
export bar
using Foo
function bar(...)
    &lt;x1/&gt; ... refer to Foo.baz as simply baz ....</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>module MyModule
import Base.@time

time() = ... &lt;x1/&gt; compute something

@time time()
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015514Z" creationid="hsugawa8651" creationdate="20181116T015514Z">
        <seg>module MyModule
import Base.@time

time() = ... &lt;x1/&gt; compute something

@time time()
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modulus; satisfies &lt;x1/&gt;x == fld(x,y)*y + mod(x,y)&lt;x2/&gt;; sign matches &lt;x3/&gt;y&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031309Z" creationid="hsugawa8651" creationdate="20181114T031309Z">
        <seg>係数;&lt;x1/&gt;x==fld(x,y)*y+mod(x,y)&lt;x2/&gt;;符号は&lt;x3/&gt;y&lt;x4/&gt;に一致する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>multiply, or matrix multiply</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150250Z" creationid="hsugawa8651" creationdate="20181117T150250Z">
        <seg>乗算する、または行列乗算する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mutable struct NativeType
    p::Ptr{UInt8}
    ...
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021340Z" creationid="hsugawa8651" creationdate="20181116T021340Z">
        <seg>mutable struct NativeType
    p::Ptr{UInt8}
    ...
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mutable struct gsl_permutation
end

&lt;x1/&gt; The corresponding C signature is
&lt;x2/&gt;     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), &lt;x3/&gt; name of C function and library
        Ptr{gsl_permutation},              &lt;x4/&gt; output type
        (Csize_t,),                        &lt;x5/&gt; tuple of input types
        n                                  &lt;x6/&gt; name of Julia variable to pass in
    )
    if output_ptr == C_NULL &lt;x7/&gt; Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151911Z" creationid="hsugawa8651" creationdate="20181117T151911Z">
        <seg>mutable struct gsl_permutation
end

&lt;x1/&gt; The corresponding C signature is
&lt;x2/&gt;     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), &lt;x3/&gt; name of C function and library
        Ptr{gsl_permutation},              &lt;x4/&gt; output type
        (Csize_t,),                        &lt;x5/&gt; tuple of input types
        n                                  &lt;x6/&gt; name of Julia variable to pass in
    )
    if output_ptr == C_NULL &lt;x7/&gt; Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mutable struct&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134317Z" creationid="hsugawa8651" creationdate="20181117T134317Z">
        <seg>mutable struct&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mycompare&lt;x1/&gt;, which will allow you to see the comparisons that &lt;x2/&gt;qsort&lt;x3/&gt; is performing
(and to verify that it is really calling the Julia function that you passed to it).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134203Z" creationid="hsugawa8651" creationdate="20181117T134203Z">
        <seg>&lt;x2/&gt;qsort&lt;x3/&gt;が実行されている比較を表示するためのミコンパレ&lt;x1/&gt; (そして、それが渡されたJulia関数を実際に呼び出していることを確認するためです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>n&lt;x1/&gt; worker processes, while &lt;x2/&gt;--machine-file file&lt;x3/&gt; will launch a worker
for each line in file &lt;x4/&gt;file&lt;x5/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T092316Z" creationid="hsugawa8651" creationdate="20181118T092316Z">
        <seg>&lt;x5/&gt;-p n&lt;x6/&gt; でn&lt;x1/&gt;個のワーカーを追加で起動することができ、 &lt;x2/&gt;--machinefile file&lt;x3/&gt; では &lt;x4/&gt;file&lt;x5/&gt; ファイルの各行ごとにワーカーが起動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name : "$name / $desc"))
        end
    end
    return names
end

&lt;x4/&gt; Surround combining characters with no-break spaces (i.e '\u00A0').</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022226Z" creationid="hsugawa8651" creationdate="20181116T022226Z">
        <seg>name : "$name / $desc"))
        end
    end
    return names
end

&lt;x4/&gt; Surround combining characters with no-break spaces (i.e '\u00A0').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name = "App"
uuid = "8f986787-14fe-4607-ba5d-fbff2944afa9"

[deps]
Priv = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
Pub  = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015858Z" creationid="hsugawa8651" creationdate="20181116T015858Z">
        <seg>name = "App"
uuid = "8f986787-14fe-4607-ba5d-fbff2944afa9"

[deps]
Priv = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
Pub  = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ndims(A)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083058Z" creationid="hsugawa8651" creationdate="20181113T083058Z">
        <seg>ndims(A)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>negative infinity</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110833Z" creationid="hsugawa8651" creationdate="20181112T110833Z">
        <seg>負の無限大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next = iterate(iter)
while next !== nothing
    (i, state) = next
    &lt;x1/&gt; body
    next = iterate(iter, state)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T042115Z" creationid="hsugawa8651" creationdate="20181110T042115Z">
        <seg>next = iterate(iter)
while next !== nothing
    (i, state) = next
    &lt;x1/&gt; body
    next = iterate(iter, state)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not supported by &lt;x1/&gt;ccall&lt;x2/&gt; or &lt;x3/&gt;@cfunction&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151731Z" creationid="hsugawa8651" creationdate="20181117T151731Z">
        <seg>&lt;x1/&gt;ccall&lt;x2/&gt;または&lt;x3/&gt;@cfunction&lt;x4/&gt;ではサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>note
A C function declared to return &lt;x1/&gt;Cvoid&lt;x2/&gt; will return the value &lt;x3/&gt;nothing&lt;x4/&gt; in Julia.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151128Z" creationid="hsugawa8651" creationdate="20181117T151128Z">
        <seg>メモ &lt;x1/&gt;Cvoid&lt;x2/&gt;を返すことを宣言したC関数は、ジュリアでは&lt;x3/&gt;何も返さない&lt;x4/&gt;の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>note
An updating operator rebinds the variable on the left-hand side.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132418Z" creationid="hsugawa8651" creationdate="20181113T132418Z">
        <seg>メモ 更新演算子は、左側の変数を再バインドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>note
C functions that take an argument of the type &lt;x1/&gt;char**&lt;x2/&gt; can be called by using a &lt;x3/&gt;Ptr{Ptr{UInt8}}&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151035Z" creationid="hsugawa8651" creationdate="20181117T151035Z">
        <seg>メモ &lt;x1/&gt;char**&lt;x2/&gt;という型の引数をとるC関数は、&lt;x3/&gt;Ptr{Ptr{UInt8}}&lt;x4/&gt;を使って呼び出すことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>note
For &lt;x1/&gt;wchar_t*&lt;x2/&gt; arguments, the Julia type should be &lt;x3/&gt;`Cwstring`&lt;x4/&gt; (if the C routine expects a NUL-terminated
string) or &lt;x5/&gt;Ptr{Cwchar_t}&lt;x6/&gt; otherwise.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151029Z" creationid="hsugawa8651" creationdate="20181117T151029Z">
        <seg>メモ &lt;x1/&gt;wchar_t*&lt;x2/&gt;引数に対しては、Julia型は&lt;x3/&gt;`Cwstring'&lt;x4/&gt;(もしCルーチンがあると想定した場合)&lt;x4/&gt;でなければなりません。 string)または&lt;x5/&gt;Ptr{Cwchar_t}&lt;x6/&gt;それ以外の場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>note
For Fortran functions taking variable length strings of type &lt;x1/&gt;character(len=*)&lt;x2/&gt; the string lengths
are provided as &lt;x3/&gt;hidden arguments&lt;x4/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151043Z" creationid="hsugawa8651" creationdate="20181117T151043Z">
        <seg>メモ Fortran関数の長さが&lt;x1/&gt;文字(len=*)&lt;x2/&gt;の可変長文字列を持つ場合は、文字列の長さを指定します。 は、&lt;x3/&gt;隠し引数&lt;x4/&gt;として提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>note
The precedence of numeric literal coefficients used for implicit
multiplication is higher than other binary operators such as multiplication
(&lt;x1/&gt;*&lt;x2/&gt;), and division (&lt;x3/&gt;/&lt;x4/&gt;, &lt;x5/&gt;\&lt;x6/&gt;, and &lt;x7/&gt;//&lt;x8/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T093957Z" creationid="hsugawa8651" creationdate="20181118T093857Z">
        <seg>暗黙的に使用される数値リテラル係数の優先順位 乗算は、乗算のような他の二乗演算子よりも高い (&lt;x1/&gt;*&lt;x2/&gt;)、除算(&lt;x3/&gt;/&lt;x4/&gt;、&lt;x5/&gt;\&lt;x6/&gt;、&lt;x7/&gt;/&lt;x8/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>note
You only need to read this chapter if you want to understand the technical details of package loading.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152756Z" creationid="hsugawa8651" creationdate="20181117T152756Z">
        <seg>メモ パッケージのロードに関する技術的な詳細を理解するには、この章を読む必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nothing : (state*state, state+1)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112458Z" creationid="hsugawa8651" creationdate="20181112T112458Z">
        <seg>nothing : (state*state, state+1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nothing : (state*state, state-1)

julia&gt; collect(Iterators.reverse(Squares(4)))
4-element Array{Int64,1}:
 16
  9
  4
  1</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112945Z" creationid="hsugawa8651" creationdate="20181112T112945Z">
        <seg>nothing : (state*state, state-1)

julia&gt; collect(Iterators.reverse(Squares(4)))
4-element Array{Int64,1}:
 16
  9
  4
  1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nothing : throw(AssertionError("1 == 0"))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015430Z" creationid="hsugawa8651" creationdate="20181116T015430Z">
        <seg>nothing : throw(AssertionError("1 == 0"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nothing : throw(AssertionError("1 == 1.0"))
1 == 0 ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015427Z" creationid="hsugawa8651" creationdate="20181116T015427Z">
        <seg>nothing : throw(AssertionError("1 == 1.0"))
1 == 0 ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nothing : throw(AssertionError($(string(ex)))) )
       end
@assert (macro with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015420Z" creationid="hsugawa8651" creationdate="20181116T015420Z">
        <seg>nothing : throw(AssertionError($(string(ex)))) )
       end
@assert (macro with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nothing : throw(AssertionError($msg)))
       end
@assert (macro with 1 method)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015441Z" creationid="hsugawa8651" creationdate="20181116T015441Z">
        <seg>nothing : throw(AssertionError($msg)))
       end
@assert (macro with 1 method)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nothing&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150737Z" creationid="hsugawa8651" creationdate="20181117T150737Z">
        <seg>nothing&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>obj3 = MyModule.someotherfunction(obj2, c)
...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T024805Z" creationid="hsugawa8651" creationdate="20181110T024805Z">
        <seg>obj3 = MyModule.someotherfunction(obj2, c)
...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open("outfile", "w") do io
    write(io, data)
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T030218Z" creationid="hsugawa8651" creationdate="20181110T030218Z">
        <seg>open("outfile", "w") do io
    write(io, data)
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>option will search through parent directories until a Project.toml or JuliaProject.toml file is found.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031541Z" creationid="hsugawa8651" creationdate="20181114T031541Z">
        <seg>オプションは、Project.トミルまたはJuliaProject.トミルファイルが見つかるまで、親ディレクトリを検索します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>p&lt;x1/&gt;, &lt;x2/&gt;q&lt;x3/&gt; and &lt;x4/&gt;n&lt;x5/&gt; from the enclosing scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160657Z" creationid="hsugawa8651" creationdate="20181114T160657Z">
        <seg>p&lt;x1/&gt;、&lt;x2/&gt;q&lt;x3/&gt;、および&lt;x4/&gt;n&lt;x5/&gt;を囲むスコープからの値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>p&lt;x1/&gt;, &lt;x2/&gt;q&lt;x3/&gt; and &lt;x4/&gt;n&lt;x5/&gt; from the enclosing scope.
Captured variables can present performance challenges; see
&lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref man-performance-tips).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134823Z" creationid="hsugawa8651" creationdate="20181117T134823Z">
        <seg>p&lt;x1/&gt;、&lt;x2/&gt;q&lt;x3/&gt;、および&lt;x4/&gt;n&lt;x5/&gt;を囲むスコープからの値。 キャプチャされた変数はパフォーマンス上の問題を提示することがあります。 &lt;x6/&gt;&lt;x7/&gt;&lt;x8/&gt;(@ref manのパフォーマンス・ヒント)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>parametric type instantiation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063146Z" creationid="hsugawa8651" creationdate="20181114T063146Z">
        <seg>パラメトリック・タイプのインスタンス化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>paths = Dict{Tuple{UUID,Symbol},String}(
    (UUID("00000000-0000-0000-0000-000000000000"), :Aardvark) =&gt;
        "/home/me/AnimalPackages/Aardvark/src/Aardvark.jl",
    (UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), :Bobcat) =&gt;
        "/home/me/AnimalPackages/Bobcat/src/Bobcat.jl",
    (UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), :Cobra) =&gt;
        "/home/me/AnimalPackages/Cobra/src/Cobra.jl",
    (UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), :Dingo) =&gt;
        "/home/me/AnimalPackages/Dingo/src/Dingo.jl",
)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020000Z" creationid="hsugawa8651" creationdate="20181116T020000Z">
        <seg>paths = Dict{Tuple{UUID,Symbol},String}(
    (UUID("00000000-0000-0000-0000-000000000000"), :Aardvark) =&gt;
        "/home/me/AnimalPackages/Aardvark/src/Aardvark.jl",
    (UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), :Bobcat) =&gt;
        "/home/me/AnimalPackages/Bobcat/src/Bobcat.jl",
    (UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), :Cobra) =&gt;
        "/home/me/AnimalPackages/Cobra/src/Cobra.jl",
    (UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), :Dingo) =&gt;
        "/home/me/AnimalPackages/Dingo/src/Dingo.jl",
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>paths = Dict{Tuple{UUID,Symbol},String}(
    &lt;x1/&gt; Priv – the private one:
    (UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"), :Priv) =&gt;
        &lt;x2/&gt; relative entry-point inside `App` repo:
        "/home/me/projects/App/deps/Priv/src/Priv.jl",
    &lt;x3/&gt; Priv – the public one:
    (UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"), :Priv) =&gt;
        &lt;x4/&gt; package installed in the system depot:
        "/usr/local/julia/packages/Priv/HDkr/src/Priv.jl",
    &lt;x5/&gt; Pub:
    (UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"), :Pub) =&gt;
        &lt;x6/&gt; package installed in the user depot:
        "/home/me/.julia/packages/Pub/oKpw/src/Pub.jl",
    &lt;x7/&gt; Zebra:
    (UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"), :Zebra) =&gt;
        &lt;x8/&gt; package installed in the system depot:
        "/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl",
)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015934Z" creationid="hsugawa8651" creationdate="20181116T015934Z">
        <seg>paths = Dict{Tuple{UUID,Symbol},String}(
    &lt;x1/&gt; Priv – the private one:
    (UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"), :Priv) =&gt;
        &lt;x2/&gt; relative entry-point inside `App` repo:
        "/home/me/projects/App/deps/Priv/src/Priv.jl",
    &lt;x3/&gt; Priv – the public one:
    (UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"), :Priv) =&gt;
        &lt;x4/&gt; package installed in the system depot:
        "/usr/local/julia/packages/Priv/HDkr/src/Priv.jl",
    &lt;x5/&gt; Pub:
    (UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"), :Pub) =&gt;
        &lt;x6/&gt; package installed in the user depot:
        "/home/me/.julia/packages/Pub/oKpw/src/Pub.jl",
    &lt;x7/&gt; Zebra:
    (UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"), :Zebra) =&gt;
        &lt;x8/&gt; package installed in the system depot:
        "/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl",
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>performs addition</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132011Z" creationid="hsugawa8651" creationdate="20181113T132011Z">
        <seg>追加を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>performs division</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132053Z" creationid="hsugawa8651" creationdate="20181113T132053Z">
        <seg>除算を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>performs multiplication</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132037Z" creationid="hsugawa8651" creationdate="20181113T132037Z">
        <seg>乗算を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>performs subtraction</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132025Z" creationid="hsugawa8651" creationdate="20181113T132025Z">
        <seg>減算を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020328Z" creationid="hsugawa8651" creationdate="20181116T020328Z">
        <seg>pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>positive infinity</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110813Z" creationid="hsugawa8651" creationdate="20181112T110813Z">
        <seg>正の無限大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prefix "not" (logical negation) operator</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032241Z" creationid="hsugawa8651" creationdate="20181114T032241Z">
        <seg>接頭語"not"(論理否定)演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021619Z" creationid="hsugawa8651" creationdate="20181116T021619Z">
        <seg>primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>primitive type «name» «bits» end
primitive type «name» &lt;: «supertype» «bits» end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021627Z" creationid="hsugawa8651" creationdate="20181116T021627Z">
        <seg>primitive type «name» «bits» end
primitive type «name» &lt;: «supertype» «bits» end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>primitive type&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150655Z" creationid="hsugawa8651" creationdate="20181117T150655Z">
        <seg>primitive type&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prod(size(A))&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022410Z" creationid="hsugawa8651" creationdate="20181113T022410Z">
        <seg>prod(size(A))&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>quoted expression</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150259Z" creationid="hsugawa8651" creationdate="20181117T150259Z">
        <seg>引用式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>raises &lt;x1/&gt;x&lt;x2/&gt; to the &lt;x3/&gt;y&lt;x4/&gt;th power</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132134Z" creationid="hsugawa8651" creationdate="20181113T132134Z">
        <seg>&lt;x1/&gt;x&lt;x2/&gt;を&lt;x3/&gt;y&lt;x4/&gt;の累乗に引き上げる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>range a, a+1, a+2, ..., b</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063539Z" creationid="hsugawa8651" creationdate="20181114T063539Z">
        <seg>range a, a+1, a+2, ..., b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>range a, a+s, a+2s, ..., b</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063542Z" creationid="hsugawa8651" creationdate="20181114T063542Z">
        <seg>range a, a+s, a+2s, ..., b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>range of &lt;x1/&gt;n&lt;x2/&gt; linearly spaced elements from &lt;x3/&gt;start&lt;x4/&gt; to &lt;x5/&gt;stop&lt;x6/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154500Z" creationid="hsugawa8651" creationdate="20181109T154500Z">
        <seg>&lt;x1/&gt;n&lt;x2/&gt;の範囲で、&lt;x3/&gt;開始&lt;x4/&gt;から&lt;x5/&gt;&lt;x6/&gt;までの直線的に間隔をあけた要素の範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rather than:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020048Z" creationid="hsugawa8651" creationdate="20181116T020048Z">
        <seg>rather than:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>re = Regex("^\\s*(?:&lt;x1/&gt;|\$)")
for line = lines
    m = match(re, line)
    if m === nothing
        &lt;x2/&gt; non-comment
    else
        &lt;x3/&gt; comment
    end
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015631Z" creationid="hsugawa8651" creationdate="20181116T015631Z">
        <seg>re = Regex("^\\s*(?:&lt;x1/&gt;|\$)")
for line = lines
    m = match(re, line)
    if m === nothing
        &lt;x2/&gt; non-comment
    else
        &lt;x3/&gt; comment
    end
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>remainder</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132141Z" creationid="hsugawa8651" creationdate="20181113T132141Z">
        <seg>残り</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>remainder operator</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032310Z" creationid="hsugawa8651" creationdate="20181114T032310Z">
        <seg>剰余演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133236Z" creationid="hsugawa8651" creationdate="20181117T133236Z">
        <seg>return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>roots = Dict(
    :App  =&gt; UUID("8f986787-14fe-4607-ba5d-fbff2944afa9"),
    :Priv =&gt; UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"),
    :Pub  =&gt; UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015901Z" creationid="hsugawa8651" creationdate="20181116T015901Z">
        <seg>roots = Dict(
    :App  =&gt; UUID("8f986787-14fe-4607-ba5d-fbff2944afa9"),
    :Priv =&gt; UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"),
    :Pub  =&gt; UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>roots = Dict{Symbol,UUID}(
    :Aardvark =&gt; UUID("00000000-0000-0000-0000-000000000000"), &lt;x1/&gt; no project file, nil UUID
    :Bobcat   =&gt; UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), &lt;x2/&gt; dummy UUID based on path
    :Cobra    =&gt; UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), &lt;x3/&gt; UUID from project file
    :Dingo    =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), &lt;x4/&gt; UUID from project file
)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015947Z" creationid="hsugawa8651" creationdate="20181116T015947Z">
        <seg>roots = Dict{Symbol,UUID}(
    :Aardvark =&gt; UUID("00000000-0000-0000-0000-000000000000"), &lt;x1/&gt; no project file, nil UUID
    :Bobcat   =&gt; UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), &lt;x2/&gt; dummy UUID based on path
    :Cobra    =&gt; UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), &lt;x3/&gt; UUID from project file
    :Dingo    =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), &lt;x4/&gt; UUID from project file
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>roots = reduce(merge, reverse([roots₁, roots₂, …]))
graph = reduce(merge, reverse([graph₁, graph₂, …]))
paths = reduce(merge, reverse([paths₁, paths₂, …]))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020006Z" creationid="hsugawa8651" creationdate="20181116T020006Z">
        <seg>roots = reduce(merge, reverse([roots₁, roots₂, …]))
graph = reduce(merge, reverse([graph₁, graph₂, …]))
paths = reduce(merge, reverse([paths₁, paths₂, …]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>round &lt;x1/&gt;x&lt;x2/&gt; to the nearest integer</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031119Z" creationid="hsugawa8651" creationdate="20181114T031119Z">
        <seg>最も近い整数に対して&lt;x1/&gt;x&lt;x2/&gt;を四捨五入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>round &lt;x1/&gt;x&lt;x2/&gt; towards &lt;x3/&gt;-Inf&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031130Z" creationid="hsugawa8651" creationdate="20181114T031125Z">
        <seg>round &lt;x1/&gt;x&lt;x2/&gt; towards &lt;x3/&gt;-Inf&lt;x4/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>separate function arguments or tuple components</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063200Z" creationid="hsugawa8651" creationdate="20181114T063200Z">
        <seg>個別の関数の引数またはタプル・コンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setindex!(A, I...)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022344Z" creationid="hsugawa8651" creationdate="20181113T022344Z">
        <seg>setindex!(A, I...)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setindex!(A, X, I_1, I_2, ..., I_n)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134935Z" creationid="hsugawa8651" creationdate="20181117T134935Z">
        <seg>setindex!(A, X, I_1, I_2, ..., I_n)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setindex!(A, v, I::Vararg{Int, N})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113256Z" creationid="hsugawa8651" creationdate="20181112T113256Z">
        <seg>setindex!(A, v, I::Vararg{Int, N})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setindex!(A, v, i::Int)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113245Z" creationid="hsugawa8651" creationdate="20181112T113245Z">
        <seg>setindex!(A, v, i::Int)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>short-circuiting boolean and</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150227Z" creationid="hsugawa8651" creationdate="20181117T150227Z">
        <seg>短絡ブール値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>short-circuiting boolean or</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150244Z" creationid="hsugawa8651" creationdate="20181117T150244Z">
        <seg>短絡ブール値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>short&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150907Z" creationid="hsugawa8651" creationdate="20181117T150907Z">
        <seg>short&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shorthand for &lt;x1/&gt;cat(A...; dims=1)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154553Z" creationid="hsugawa8651" creationdate="20181109T154553Z">
        <seg>&lt;x1/&gt;cat(A.…;dims=1)&lt;x2/&gt;の短縮形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shorthand for &lt;x1/&gt;cat(A...; dims=2)&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154557Z" creationid="hsugawa8651" creationdate="20181109T154557Z">
        <seg>&lt;x1/&gt;cat(A.…;dims=2)&lt;x2/&gt;の短縮形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>show(io::IO, v::Vector{MyType}) = ...</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021344Z" creationid="hsugawa8651" creationdate="20181116T021344Z">
        <seg>show(io::IO, v::Vector{MyType}) = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022415Z" creationid="hsugawa8651" creationdate="20181113T022415Z">
        <seg>similar(A)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, ::Type{S})&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022423Z" creationid="hsugawa8651" creationdate="20181113T022423Z">
        <seg>similar(A, ::Type{S})&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, ::Type{S}, dims::Dims)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022448Z" creationid="hsugawa8651" creationdate="20181113T022448Z">
        <seg>similar(A, ::Type{S}, dims::Dims)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, ::Type{S}, inds)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022521Z" creationid="hsugawa8651" creationdate="20181113T022521Z">
        <seg>similar(A, ::Type{S}, inds)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, S, Base.to_shape(inds))&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022525Z" creationid="hsugawa8651" creationdate="20181113T022525Z">
        <seg>similar(A, S, Base.to_shape(inds))&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, S, size(A))&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022426Z" creationid="hsugawa8651" creationdate="20181113T022426Z">
        <seg>similar(A, S, size(A))&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, dims::Dims)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022435Z" creationid="hsugawa8651" creationdate="20181113T022435Z">
        <seg>similar(A, dims::Dims)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, eltype(A), dims)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022439Z" creationid="hsugawa8651" creationdate="20181113T022439Z">
        <seg>similar(A, eltype(A), dims)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(A, eltype(A), size(A))&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022419Z" creationid="hsugawa8651" creationdate="20181113T022419Z">
        <seg>similar(A, eltype(A), size(A))&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(T::Union{Type,Function}, inds)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T022608Z" creationid="hsugawa8651" creationdate="20181113T022608Z">
        <seg>similar(T::Union{Type,Function}, inds)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =
    similar(Array{ElType}, axes(bc))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131319Z" creationid="hsugawa8651" creationdate="20181113T131319Z">
        <seg>similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =
    similar(Array{ElType}, axes(bc))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>similar&lt;x1/&gt; supports 1- and 2-argument
forms, in most case you only need to specialize the 3-argument form.) For this to work it's important
that &lt;x2/&gt;SparseArray&lt;x3/&gt; is mutable (supports &lt;x4/&gt;setindex!&lt;x5/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083312Z" creationid="hsugawa8651" creationdate="20181113T083312Z">
        <seg>同様の&lt;x1/&gt;は1と2の引数をサポートします ほとんどの場合、3引数形式の特殊化のみが必要となります。)この場合、重要なのは、このフォームを使用することです。 &lt;x2/&gt;SparseArray&lt;x3/&gt;は可変です(&lt;x4/&gt;setindex!&lt;x5/&gt;をサポートします)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sin.(a)&lt;x1/&gt; to vectorize via &lt;x2/&gt;broadcast&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150008Z" creationid="hsugawa8651" creationdate="20181117T150008Z">
        <seg>sin.(a)&lt;x2/&gt;ブロードキャストを介してベクトル化する&lt;x2/&gt;ブロードキャスト&lt;x/&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>single&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110235Z" creationid="hsugawa8651" creationdate="20181112T110235Z">
        <seg>single&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size(A)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T113213Z" creationid="hsugawa8651" creationdate="20181112T113213Z">
        <seg>size(A)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size(iter, [dim])&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T112237Z" creationid="hsugawa8651" creationdate="20181112T112237Z">
        <seg>size(iter, [dim])&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>splice arguments into a function call or declare a varargs function</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063529Z" creationid="hsugawa8651" creationdate="20181114T063529Z">
        <seg>関数呼び出しに引数を指定するか、またはvarargs関数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>statement separator</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063155Z" creationid="hsugawa8651" creationdate="20181114T063155Z">
        <seg>文区切り文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stdcall&lt;x1/&gt; is unified with the
C calling convention).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133918Z" creationid="hsugawa8651" creationdate="20181117T133918Z">
        <seg>stdcall&lt;x1/&gt;は C呼び出し規約)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022828Z" creationid="hsugawa8651" creationdate="20181116T022828Z">
        <seg>str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stride(A, i::Int)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083446Z" creationid="hsugawa8651" creationdate="20181113T083446Z">
        <seg>stride(A, i::Int)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>strides(A)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T083428Z" creationid="hsugawa8651" creationdate="20181113T083428Z">
        <seg>strides(A)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>string and expression interpolation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032307Z" creationid="hsugawa8651" creationdate="20181114T032307Z">
        <seg>文字列と式の補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct ...; end&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150734Z" creationid="hsugawa8651" creationdate="20181117T150734Z">
        <seg>struct ...; end&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct ArrayAndChar{T,N} &lt;: AbstractArray{T,N}
    data::Array{T,N}
    char::Char
end
Base.size(A::ArrayAndChar) = size(A.data)
Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]
Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val
Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), " with char '", A.char, "'")
&lt;x1/&gt; output</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131355Z" creationid="hsugawa8651" creationdate="20181113T131355Z">
        <seg>struct ArrayAndChar{T,N} &lt;: AbstractArray{T,N}
    data::Array{T,N}
    char::Char
end
Base.size(A::ArrayAndChar) = size(A.data)
Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]
Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val
Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), " with char '", A.char, "'")
&lt;x1/&gt; output</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct B
    A::NTuple{3, Cint}
end
b_a_2 = B.A[3]  &lt;x1/&gt; note the difference in indexing (1-based in Julia, 0-based in C)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151207Z" creationid="hsugawa8651" creationdate="20181117T151207Z">
        <seg>struct B
    A::NTuple{3, Cint}
end
b_a_2 = B.A[3]  &lt;x1/&gt; note the difference in indexing (1-based in Julia, 0-based in C)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct B {
    int A[3];
};
b_a_2 = B.A[2];</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022755Z" creationid="hsugawa8651" creationdate="20181116T022755Z">
        <seg>struct B {
    int A[3];
};
b_a_2 = B.A[2];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct MyNumber
    x::Float64
end
&lt;x1/&gt; output</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T015538Z" creationid="hsugawa8651" creationdate="20181116T015538Z">
        <seg>struct MyNumber
    x::Float64
end
&lt;x1/&gt; output</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct MyStyle &lt;: Broadcast.BroadcastStyle end
Base.BroadcastStyle(::Type{&lt;:MyType}) = MyStyle()</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131135Z" creationid="hsugawa8651" creationdate="20181113T131135Z">
        <seg>struct MyStyle&lt;:Broadcast.BroadcastStyle end#struct MyStyle&lt;:Broadcast.Schedule end# Base.BroadcastStyle(::Type{&lt;:MyType})=MyStyle()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct MyType
    value::String
end

Docs.getdoc(t::MyType) = "Documentation for MyType with value $(t.value)"

x = MyType("x")
y = MyType("y")</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020147Z" creationid="hsugawa8651" creationdate="20181116T020147Z">
        <seg>struct MyType
    value::String
end

Docs.getdoc(t::MyType) = "Documentation for MyType with value $(t.value)"

x = MyType("x")
y = MyType("y")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct NoPad end  &lt;x1/&gt; indicate that no padding is desired, or that it's already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  &lt;x2/&gt; default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  &lt;x3/&gt; indicate the new boundary conditions
end

&lt;x4/&gt; other padding methods go here

function myfilter(A, kernel, ::NoPad)
    &lt;x5/&gt; Here's the "real" implementation of the core computation
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T054503Z" creationid="hsugawa8651" creationdate="20181116T054503Z">
        <seg>struct NoPad end  &lt;x1/&gt; indicate that no padding is desired, or that it's already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  &lt;x2/&gt; default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  &lt;x3/&gt; indicate the new boundary conditions
end

&lt;x4/&gt; other padding methods go here

function myfilter(A, kernel, ::NoPad)
    &lt;x5/&gt; Here's the "real" implementation of the core computation
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct Point{T&lt;:Real} &lt;: Pointy{T}
    x::T
    y::T
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021903Z" creationid="hsugawa8651" creationdate="20181116T021903Z">
        <seg>struct Point{T&lt;:Real} &lt;: Pointy{T}
    x::T
    y::T
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct Rational{T&lt;:Integer} &lt;: Real
    num::T
    den::T
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021908Z" creationid="hsugawa8651" creationdate="20181116T021908Z">
        <seg>struct Rational{T&lt;:Integer} &lt;: Real
    num::T
    den::T
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct SparseVecStyle &lt;: Broadcast.AbstractArrayStyle{1} end
struct SparseMatStyle &lt;: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{&lt;:SparseVector}) = SparseVecStyle()
Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatStyle()</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131845Z" creationid="hsugawa8651" creationdate="20181113T131845Z">
        <seg>struct SparseVecStyle &lt;: Broadcast.AbstractArrayStyle{1} end
struct SparseMatStyle &lt;: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{&lt;:SparseVector}) = SparseVecStyle()
Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatStyle()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct String {
    int strlen;
    char data[];
};</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022823Z" creationid="hsugawa8651" creationdate="20181116T022823Z">
        <seg>struct String {
    int strlen;
    char data[];
};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct T&lt;x1/&gt; (including typedef to a struct)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151517Z" creationid="hsugawa8651" creationdate="20181117T151517Z">
        <seg>struct T&lt;x1/&gt;(構造体に対してtypedefを含む)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct Tuple2{A,B}
    a::A
    b::B
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T021913Z" creationid="hsugawa8651" creationdate="20181116T021913Z">
        <seg>struct Tuple2{A,B}
    a::A
    b::B
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct VecElement{T}
    value::T
end</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T044821Z" creationid="hsugawa8651" creationdate="20181112T044821Z">
        <seg>struct VecElement{T}
    value::T
end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150707Z" creationid="hsugawa8651" creationdate="20181117T150707Z">
        <seg>struct&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub2ind_rec(dims, I...) : throw(BoundsError());

julia&gt; sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;

julia&gt; sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =
           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);

julia&gt; sub2ind_rec((3, 5), 1, 2)
4</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032255Z" creationid="hsugawa8651" creationdate="20181116T032255Z">
        <seg>sub2ind_rec(dims, I...) : throw(BoundsError());

julia&gt; sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;

julia&gt; sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =
           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);

julia&gt; sub2ind_rec((3, 5), 1, 2)
4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sym = Libdl.dlsym(lib, :my_fcn)   &lt;x2/&gt; Get a symbol for the function to call.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T152402Z" creationid="hsugawa8651" creationdate="20181117T152402Z">
        <seg>sym = Libdl.dlsym(lib, :my_fcn)   &lt;x2/&gt; Get a symbol for the function to call.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>symbol a</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063557Z" creationid="hsugawa8651" creationdate="20181114T063557Z">
        <seg>symbol a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the &lt;x1/&gt;bar&lt;x2/&gt; function solves a problem that is better solved with multiple dispatch - defining &lt;x3/&gt;bar(x) = x&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032211Z" creationid="hsugawa8651" creationdate="20181116T032211Z">
        <seg>&lt;x1/&gt;bar&lt;x2/&gt;関数は、複数のディスパッチによって解決される問題を解決します。&lt;x3/&gt;bar(x)=x&lt;x4/&gt;を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the &lt;x1/&gt;baz&lt;x2/&gt; function is pathological</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032215Z" creationid="hsugawa8651" creationdate="20181116T032215Z">
        <seg>&lt;x1/&gt;baz&lt;x2/&gt;関数は病的である</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the &lt;x1/&gt;foo&lt;x2/&gt; function has side-effects (the call to &lt;x3/&gt;Core.println&lt;x4/&gt;), and it is undefined exactly
when, how often or how many times these side-effects will occur</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T032206Z" creationid="hsugawa8651" creationdate="20181116T032206Z">
        <seg>&lt;x1/&gt;foo&lt;x2/&gt;関数は副作用(&lt;x3/&gt;Core.println&lt;x4/&gt;の呼び出し)を持っており、厳密には定義されていません。 これらの副作用が何回、何回発生するか、何回起こるか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the empty tuple</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150252Z" creationid="hsugawa8651" creationdate="20181117T150252Z">
        <seg>空のタプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the identity operation</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131949Z" creationid="hsugawa8651" creationdate="20181113T131949Z">
        <seg>the identity operation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the number of dimensions of &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154242Z" creationid="hsugawa8651" creationdate="20181109T154242Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;の次元数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the number of elements in &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154235Z" creationid="hsugawa8651" creationdate="20181109T154235Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;のエレメント数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the size of &lt;x1/&gt;A&lt;x2/&gt; along dimension &lt;x3/&gt;n&lt;x4/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154250Z" creationid="hsugawa8651" creationdate="20181109T154250Z">
        <seg>&lt;x3/&gt;n&lt;x4/&gt;の寸法に沿って&lt;x1/&gt;A&lt;x2/&gt;の大きさ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the stride (linear index distance between adjacent elements) along dimension &lt;x1/&gt;k&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154305Z" creationid="hsugawa8651" creationdate="20181109T154305Z">
        <seg>寸法&lt;x1/&gt;k&lt;x2/&gt;に沿っての歩幅(隣接する要素間の線形指数の距離)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the elements contained in &lt;x1/&gt;A&lt;x2/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T154231Z" creationid="hsugawa8651" creationdate="20181109T154231Z">
        <seg>&lt;x1/&gt;A&lt;x2/&gt;に含まれるエレメントのタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this argument may be declared as &lt;x1/&gt;Ptr{Cvoid}&lt;x2/&gt;, if it really is just an unknown pointer</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151527Z" creationid="hsugawa8651" creationdate="20181117T151527Z">
        <seg>この引数は、実際には未知のポインタである場合、&lt;x1/&gt;Ptr{Cvoid}&lt;x2/&gt;として宣言されることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>true : odd(n - 1);

julia&gt; odd(n) = (n == 0) ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T022334Z" creationid="hsugawa8651" creationdate="20181116T022334Z">
        <seg>true : odd(n - 1);

julia&gt; odd(n) = (n == 0) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>true&lt;x1/&gt; (1)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110222Z" creationid="hsugawa8651" creationdate="20181112T110222Z">
        <seg>true&lt;x1/&gt; (1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>truncated division; quotient rounded towards zero</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031243Z" creationid="hsugawa8651" creationdate="20181114T031243Z">
        <seg>分割された除算;商は0に向かって丸められます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type annotation or &lt;x1/&gt;`typeassert`&lt;x2/&gt;, depending on context</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063552Z" creationid="hsugawa8651" creationdate="20181114T063552Z">
        <seg>コンテキストに応じて、タイプの注釈または&lt;x1/&gt;`テーペアセルト'&lt;x2/&gt;を入力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>typedef returntype (*functiontype)(argumenttype, ...)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133852Z" creationid="hsugawa8651" creationdate="20181117T133852Z">
        <seg>typedef returntype (*functiontype)(argumenttype, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>typeof(x)&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031111Z" creationid="hsugawa8651" creationdate="20181114T031111Z">
        <seg>typeof(x)&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unary plus</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T094734Z" creationid="hsugawa8651" creationdate="20181118T094734Z">
        <seg>単項プラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unsigned char&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T150854Z" creationid="hsugawa8651" creationdate="20181117T150854Z">
        <seg>unsigned char&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v("yes") : v("no")
no
"no"</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230210Z" creationid="hsugawa8651" creationdate="20181109T230210Z">
        <seg>v("yes") : v("no")
no
"no"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v("yes") : v("no")
yes
"yes"

julia&gt; 1 &gt; 2 ?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T230206Z" creationid="hsugawa8651" creationdate="20181109T230206Z">
        <seg>v("yes") : v("no")
yes
"yes"

julia&gt; 1 &gt; 2 ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>va_arg&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151724Z" creationid="hsugawa8651" creationdate="20181117T151724Z">
        <seg>va_arg&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vector literal constructor (calling &lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref Base.vect))</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063111Z" creationid="hsugawa8651" creationdate="20181114T063111Z">
        <seg>ベクトルリテラルコンストラクタ(calling&lt;x1/&gt;&lt;x2/&gt;&lt;x3/&gt;(@ref Base.vect))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vertical concatenation (calling &lt;x1/&gt;`vcat`&lt;x2/&gt; or &lt;x3/&gt;`hvcat`&lt;x4/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063117Z" creationid="hsugawa8651" creationdate="20181114T063117Z">
        <seg>垂直連結(calling&lt;x1/&gt;`vcat'&lt;x2/&gt;or&lt;x3/&gt;`ホフカト'&lt;x4/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void qsort(void *base, size_t nmemb, size_t size,
           int (*compare)(const void*, const void*));</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T133922Z" creationid="hsugawa8651" creationdate="20181117T133922Z">
        <seg>void qsort(void *base, size_t nmemb, size_t size,
           int (*compare)(const void*, const void*));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void*&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151521Z" creationid="hsugawa8651" creationdate="20181117T151521Z">
        <seg>void*&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151756Z" creationid="hsugawa8651" creationdate="20181117T151756Z">
        <seg>void&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warning</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T155745Z" creationid="hsugawa8651" creationdate="20181109T155745Z">
        <seg>warning</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warning
A return type of &lt;x1/&gt;Union{}&lt;x2/&gt; means the function will not return i.e. C++11 &lt;x3/&gt;[[noreturn]]&lt;x4/&gt; or C11
&lt;x5/&gt;_Noreturn&lt;x6/&gt; (e.g. &lt;x7/&gt;jl_throw&lt;x8/&gt; or &lt;x9/&gt;longjmp&lt;x10/&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151023Z" creationid="hsugawa8651" creationdate="20181117T151023Z">
        <seg>警告 &lt;x1/&gt;Union{}&lt;x2/&gt;の戻り型は、関数がi.すなわちC++11&lt;x3/&gt;[noreturn]&lt;x4/&gt;またはC11を返すことはないことを意味します。 &lt;x5/&gt;_Noreturn&lt;x6/&gt;(例:&lt;x7/&gt;jl_throw&lt;x8/&gt;または&lt;x9/&gt;longjmp&lt;x10/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warning
For string arguments (&lt;x1/&gt;char*&lt;x2/&gt;) the Julia type should be &lt;x3/&gt;Cstring&lt;x4/&gt; (if NUL- terminated data is
expected) or either &lt;x5/&gt;Ptr{Cchar}&lt;x6/&gt; or &lt;x7/&gt;Ptr{UInt8}&lt;x8/&gt; otherwise (these two pointer types have the same
effect), as described above, not &lt;x9/&gt;String&lt;x10/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151012Z" creationid="hsugawa8651" creationdate="20181117T151012Z">
        <seg>警告 文字列引数(&lt;x1/&gt;char*&lt;x2/&gt;)では、Julia型は&lt;x3/&gt;Cstring&lt;x4/&gt;(NUL-terminated dataがある場合)を指定する必要があります。 期待されるか、または&lt;x5/&gt;Ptr{Cchar}&lt;x6/&gt;または&lt;x7/&gt;Ptr{UInt8}&lt;x8/&gt;それ以外の場合(これらの2つのポインタタイプは同じですが、これらのポインタは同じです)。 上述のように、効果は&lt;x9/&gt;String&lt;x10/&gt;ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warning
Fortran compilers &lt;x1/&gt;may&lt;x2/&gt; also add other hidden arguments for pointers, assumed-shape (&lt;x3/&gt;:&lt;x4/&gt;)
and assumed-size (&lt;x5/&gt;*&lt;x6/&gt;) arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151118Z" creationid="hsugawa8651" creationdate="20181117T151118Z">
        <seg>警告 Fortranコンパイラ&lt;x1/&gt;はまた、ポインタに対して他の隠れた引数を追加することができます(&lt;x3/&gt;:&lt;x4/&gt;)。 そして、サイズは(&lt;x5/&gt;*&lt;x6/&gt;)であると考えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warning
Julia's &lt;x1/&gt;Char&lt;x2/&gt; type is 32 bits, which is not the same as the wide character type (&lt;x3/&gt;wchar_t&lt;x4/&gt; or
&lt;x5/&gt;wint_t&lt;x6/&gt;) on all platforms.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151018Z" creationid="hsugawa8651" creationdate="20181117T151018Z">
        <seg>警告 Juliaの&lt;x1/&gt;Char&lt;x2/&gt;型は32ビットで、ワイド文字タイプ(&lt;x3/&gt;wchar_t&lt;x4/&gt;または すべてのプラットフォームで、&lt;x5/&gt;wint_t&lt;x6/&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where &lt;x1/&gt;Style12&lt;x2/&gt; is the &lt;x3/&gt;BroadcastStyle&lt;x4/&gt; you want to choose for outputs involving
arguments of &lt;x5/&gt;Style1&lt;x6/&gt; and &lt;x7/&gt;Style2&lt;x8/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T131746Z" creationid="hsugawa8651" creationdate="20181113T131746Z">
        <seg>ここで、&lt;x1/&gt;Style12&lt;x2/&gt;は、出力を選択する&lt;x3/&gt;BroadcastStyle&lt;x4/&gt;である。 &lt;x5/&gt;Style1&lt;x6/&gt;および&lt;x7/&gt;Style2&lt;x8/&gt;の引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where each &lt;x1/&gt;I_k&lt;x2/&gt; may be a scalar integer, an array of integers, or any other
&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man-supported-index-types).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T160720Z" creationid="hsugawa8651" creationdate="20181109T155116Z">
        <seg>ここで、各&lt;x1/&gt;I_k&lt;x2/&gt;はスカラー整数、整数の配列、またはその他のいずれかである。 &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref manサポートされているインデックス・タイプ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where each &lt;x1/&gt;I_k&lt;x2/&gt; may be a scalar integer, an array of integers, or any other
&lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref man-supported-index-types). This includes
&lt;x6/&gt;`Colon`&lt;x7/&gt; (&lt;x8/&gt;:&lt;x9/&gt;) to select all indices within the entire dimension,
ranges of the form &lt;x10/&gt;a:c&lt;x11/&gt; or &lt;x12/&gt;a:b:c&lt;x13/&gt; to select contiguous or strided
subsections, and arrays of booleans to select elements at their &lt;x14/&gt;true&lt;x15/&gt; indices.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134826Z" creationid="hsugawa8651" creationdate="20181117T134826Z">
        <seg>ここで、各&lt;x1/&gt;I_k&lt;x2/&gt;はスカラー整数、整数の配列、またはその他のいずれかである。 &lt;x3/&gt;&lt;x4/&gt;&lt;x5/&gt;(@ref manサポートされているインデックス・タイプ)。これには、以下のものが含まれます。 &lt;x6/&gt;「コロン」&lt;x7/&gt;(&lt;x8/&gt;:&lt;x9/&gt;)は、次元全体のすべてのインデックスを選択するために使用されます。 &lt;x10/&gt;a:c&lt;x11/&gt;または&lt;x12/&gt;a:b:c&lt;x13/&gt;to select連続またはストライドされたものを選択するための範囲 サブセクションは、&lt;x14/&gt;真の&lt;x15/&gt;インデックスで選択要素を選択するためのブール演算の配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T151831Z" creationid="hsugawa8651" creationdate="20181117T151831Z">
        <seg>width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will add documentation to &lt;x1/&gt;f(x)&lt;x2/&gt; when &lt;x3/&gt;condition()&lt;x4/&gt; is &lt;x5/&gt;true&lt;x6/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020134Z" creationid="hsugawa8651" creationdate="20181116T020134Z">
        <seg>will add documentation to &lt;x1/&gt;f(x)&lt;x2/&gt; when &lt;x3/&gt;condition()&lt;x4/&gt; is &lt;x5/&gt;true&lt;x6/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will behave as if the following were written:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181117T134254Z" creationid="hsugawa8651" creationdate="20181117T134254Z">
        <seg>次のような動作をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with space-separated expressions, horizontal concatenation (calling &lt;x1/&gt;`hcat`&lt;x2/&gt; or &lt;x3/&gt;`hvcat`&lt;x4/&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T063141Z" creationid="hsugawa8651" creationdate="20181114T063141Z">
        <seg>空間的に分離された表現で、水平連結(calling&lt;x1/&gt;`ヘカト'&lt;x2/&gt;または&lt;x3/&gt;'ホフカト''&lt;x4/&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writer = @async write(process, "data")
reader = @async do_compute(read(process, String))
wait(process)
fetch(reader)</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020332Z" creationid="hsugawa8651" creationdate="20181116T020332Z">
        <seg>writer = @async write(process, "data")
reader = @async do_compute(read(process, String))
wait(process)
fetch(reader)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x % T&lt;x1/&gt; converts an integer &lt;x2/&gt;x&lt;x3/&gt; to a value of integer type &lt;x4/&gt;T&lt;x5/&gt; congruent to &lt;x6/&gt;x&lt;x7/&gt; modulo &lt;x8/&gt;2^n&lt;x9/&gt;,
where &lt;x10/&gt;n&lt;x11/&gt; is the number of bits in &lt;x12/&gt;T&lt;x13/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T031040Z" creationid="hsugawa8651" creationdate="20181114T031040Z">
        <seg>x%T&lt;x1/&gt;は整数&lt;x2/&gt;x&lt;x3/&gt;を整数型&lt;x4/&gt;T&lt;x5/&gt;の値に変換し、&lt;x8/&gt;x&lt;x7/&gt;&lt;x8/&gt;2^n&lt;x9/&gt;のモジュロ&lt;x8/&gt;の値に変換する。 ここで、&lt;x10/&gt;n&lt;x11/&gt;は、&lt;x12/&gt;T&lt;x13/&gt;のビット数である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x % y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132137Z" creationid="hsugawa8651" creationdate="20181113T132137Z">
        <seg>x % y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x &amp; y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132238Z" creationid="hsugawa8651" creationdate="20181113T132238Z">
        <seg>x &amp; y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x * y * z *... calls this function with multiple
  arguments, i.e. *(x,y,z...).</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181116T020115Z" creationid="hsugawa8651" creationdate="20181116T020115Z">
        <seg>x * y * z *... calls this function with multiple
  arguments, i.e. *(x,y,z...).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x * y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132028Z" creationid="hsugawa8651" creationdate="20181113T132028Z">
        <seg>x * y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x + y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132002Z" creationid="hsugawa8651" creationdate="20181113T132002Z">
        <seg>x + y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x - y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132014Z" creationid="hsugawa8651" creationdate="20181113T132014Z">
        <seg>x - y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x .+ 3 .* x.^2&lt;x1/&gt; are
equivalent to nested dot calls &lt;x2/&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;x3/&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132615Z" creationid="hsugawa8651" creationdate="20181113T132609Z">
        <seg>x.+3.*x.^2&lt;x1/&gt;は次のとおりです。 ネストされたドット呼び出し&lt;x2/&gt;(+)(x,(*).(3,(^).(x, 2)).())&lt;x3/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x / y, truncated to an integer</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132109Z" creationid="hsugawa8651" creationdate="20181113T132109Z">
        <seg>x/y、整数に切り捨てられます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x / y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132041Z" creationid="hsugawa8651" creationdate="20181113T132041Z">
        <seg>x / y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x &lt;&lt; y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132319Z" creationid="hsugawa8651" creationdate="20181113T132319Z">
        <seg>x &lt;&lt; y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             &lt;x1/&gt; =&gt; (true, false, false)
map(x-&gt;issorted(x[1:k]), (s, ps, qs))  &lt;x2/&gt; =&gt; (true, true, false)
map(x-&gt;issorted(x[k2]), (s, ps, qs))   &lt;x3/&gt; =&gt; (true, false, true)
s[1:k] == ps[1:k]                      &lt;x4/&gt; =&gt; true
s[k2] == qs[k2]                        &lt;x5/&gt; =&gt; true</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T064105Z" creationid="hsugawa8651" creationdate="20181114T064105Z">
        <seg>x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             &lt;x1/&gt; =&gt; (true, false, false)
map(x-&gt;issorted(x[1:k]), (s, ps, qs))  &lt;x2/&gt; =&gt; (true, true, false)
map(x-&gt;issorted(x[k2]), (s, ps, qs))   &lt;x3/&gt; =&gt; (true, false, true)
s[1:k] == ps[1:k]                      &lt;x4/&gt; =&gt; true
s[k2] == qs[k2]                        &lt;x5/&gt; =&gt; true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x &gt;&gt; y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132313Z" creationid="hsugawa8651" creationdate="20181113T132313Z">
        <seg>x &gt;&gt; y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x &gt;&gt;&gt; y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132304Z" creationid="hsugawa8651" creationdate="20181113T132304Z">
        <seg>x &gt;&gt;&gt; y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x \ y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132113Z" creationid="hsugawa8651" creationdate="20181113T132113Z">
        <seg>x \ y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x \| y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132246Z" creationid="hsugawa8651" creationdate="20181113T132246Z">
        <seg>x \| y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x ^ y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132128Z" creationid="hsugawa8651" creationdate="20181113T132128Z">
        <seg>x ^ y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x ÷ y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132058Z" creationid="hsugawa8651" creationdate="20181113T132058Z">
        <seg>x ÷ y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x ⊻ y&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181113T132255Z" creationid="hsugawa8651" creationdate="20181113T132255Z">
        <seg>x ⊻ y&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x&lt;x1/&gt; and &lt;x2/&gt;y&lt;x3/&gt; are identical</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030543Z" creationid="hsugawa8651" creationdate="20181114T030543Z">
        <seg>x&lt;x1/&gt;および&lt;x2/&gt;y&lt;x3/&gt;は同一である</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x&lt;x1/&gt; and &lt;x2/&gt;y&lt;x3/&gt;, avoiding overflow:</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181110T025755Z" creationid="hsugawa8651" creationdate="20181110T025755Z">
        <seg>x&lt;x1/&gt;と&lt;x2/&gt;y&lt;x3/&gt;はオーバーフローを回避します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x&lt;x1/&gt; is a finite number</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030547Z" creationid="hsugawa8651" creationdate="20181114T030547Z">
        <seg>x&lt;x1/&gt;は有限数である</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x&lt;x1/&gt; is infinite</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030555Z" creationid="hsugawa8651" creationdate="20181114T030555Z">
        <seg>x&lt;x1/&gt;は無限です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x&lt;x1/&gt; is not a number</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T030601Z" creationid="hsugawa8651" creationdate="20181114T030601Z">
        <seg>x&lt;x1/&gt;は数値ではありません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.4.3 (2016-01-12 21:37 UTC)
 _/ |\__'_|_|_|\__'_|  |
|__/                   |  x86_64-apple-darwin13.1.0

julia&gt; 1 + 2
3

julia&gt; ans
3</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181118T083825Z" creationid="hsugawa8651" creationdate="20181118T083825Z">
        <seg>| | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.4.3 (2016-01-12 21:37 UTC)
 _/ |\__'_|_|_|\__'_|  |
|__/                   |  x86_64-apple-darwin13.1.0

julia&gt; 1 + 2
3

julia&gt; ans
3| | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.4.3 (2016-01-12 21:37 UTC)
 _/ |\__'_|_|_|\__'_|  |
|__/                   |  x86_64-apple-darwin13.1.0

julia&gt; 1 + 2
3

julia&gt; ans
3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>⊻&lt;x1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181114T032333Z" creationid="hsugawa8651" creationdate="20181114T032333Z">
        <seg>⊻&lt;x1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>✓</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181112T110039Z" creationid="hsugawa8651" creationdate="20181112T110039Z">
        <seg>✓</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>你好!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224500Z" creationid="hsugawa8651" creationdate="20181109T224500Z">
        <seg>你好!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>안녕하세요?</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224507Z" creationid="hsugawa8651" creationdate="20181109T224507Z">
        <seg>안녕하세요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>안녕하세요?")' &gt; &lt;x1/&gt;/.julia/config/startup.jl
$ julia
Greetings!</seg>
      </tuv>
      <tuv lang="JA" changeid="hsugawa8651" changedate="20181109T224503Z" creationid="hsugawa8651" creationdate="20181109T224503Z">
        <seg>안녕하세요?")' &gt; &lt;x1/&gt;/.julia/config/startup.jl
$ julia
Greetings!</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
